.
├── Brewfile
├── CONTRIBUTING.md
├── Dockerfile
├── GenerationScript.sql
├── LICENSE
├── README.md
├── SECURITY.md
├── __tests__
│   └── utils
│       └── app
│           └── importExports.test.ts
├── all_files.txt
├── app
│   ├── api
│   │   ├── auth
│   │   │   └── [...nextauth]
│   │   │       └── route.ts
│   │   ├── chat
│   │   │   └── route.ts
│   │   └── models
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   └── styles
├── chat.config.ts
├── component.txt
├── components
│   ├── Common
│   │   ├── Buttons
│   │   │   ├── MiniButtons.tsx
│   │   │   ├── ModelSelect.tsx
│   │   │   ├── PrimaryButton.tsx
│   │   │   ├── SecondaryButton.tsx
│   │   │   └── SidebarActionButton
│   │   │       ├── SidebarActionButton.tsx
│   │   │       └── index.ts
│   │   ├── Chips
│   │   │   └── Chip.tsx
│   │   ├── ErrorMessageDiv.tsx
│   │   ├── Folder
│   │   │   ├── Folder.tsx
│   │   │   └── index.ts
│   │   ├── Labels
│   │   │   └── PrimaryLabel.tsx
│   │   ├── Search.tsx
│   │   ├── Sidebar
│   │   │   ├── Sidebar.tsx
│   │   │   ├── SidebarButton.tsx
│   │   │   ├── components
│   │   │   │   └── OpenCloseButton.tsx
│   │   │   └── index.ts
│   │   └── Spinner
│   │       ├── Spinner.tsx
│   │       └── index.ts
│   ├── Home
│   │   ├── components
│   │   │   ├── ChatZone
│   │   │   │   ├── ChatZone.context.tsx
│   │   │   │   ├── ChatZone.state.tsx
│   │   │   │   ├── ChatZone.tsx
│   │   │   │   └── Screens
│   │   │   │       ├── Chat
│   │   │   │       │   ├── Chat.context.tsx
│   │   │   │       │   ├── Chat.state.tsx
│   │   │   │       │   ├── Chat.tsx
│   │   │   │       │   ├── ChatInput.tsx
│   │   │   │       │   ├── ChatLoader.tsx
│   │   │   │       │   ├── ChatMessage.tsx
│   │   │   │       │   ├── MemoizedChatMessage.tsx
│   │   │   │       │   ├── PromptList.tsx
│   │   │   │       │   ├── Regenerate.tsx
│   │   │   │       │   ├── Temperature.tsx
│   │   │   │       │   └── VariableModal.tsx
│   │   │   │       └── Settings
│   │   │   │           ├── Settings.context.tsx
│   │   │   │           ├── Settings.state.tsx
│   │   │   │           ├── Settings.tsx
│   │   │   │           └── components
│   │   │   │               ├── SettingComponent.tsx
│   │   │   │               └── SettingsSectionComponent.tsx
│   │   │   ├── Mobile
│   │   │   │   └── Navbar.tsx
│   │   │   ├── PrimaryMenu
│   │   │   │   ├── PrimaryMenu.context.tsx
│   │   │   │   ├── PrimaryMenu.state.tsx
│   │   │   │   ├── PrimaryMenu.tsx
│   │   │   │   └── components
│   │   │   │       ├── ActivityBar
│   │   │   │       │   ├── ActivityBar.tsx
│   │   │   │       │   └── components
│   │   │   │       │       ├── ActivityBarButton.tsx
│   │   │   │       │       └── ActivityBarTab.tsx
│   │   │   │       └── Menu
│   │   │   │           ├── Menu.tsx
│   │   │   │           └── components
│   │   │   │               └── Screens
│   │   │   │                   ├── Calendar
│   │   │   │                   │   ├── Calendar.context.tsx
│   │   │   │                   │   ├── Calendar.tsx
│   │   │   │                   │   └── components
│   │   │   │                   │       ├── DataTable.tsx
│   │   │   │                   │       ├── DateCell.tsx
│   │   │   │                   │       └── columns.tsx
│   │   │   │                   ├── Conversations
│   │   │   │                   │   ├── Conversations.context.tsx
│   │   │   │                   │   ├── Conversations.state.tsx
│   │   │   │                   │   ├── Conversations.tsx
│   │   │   │                   │   └── components
│   │   │   │                   │       ├── ClearConversations.tsx
│   │   │   │                   │       ├── ConversationComponent.tsx
│   │   │   │                   │       ├── ConversationList.tsx
│   │   │   │                   │       ├── ConversationsSettings.tsx
│   │   │   │                   │       └── Folders.tsx
│   │   │   │                   ├── Prompts
│   │   │   │                   │   ├── Prompts.context.tsx
│   │   │   │                   │   ├── Prompts.state.tsx
│   │   │   │                   │   ├── Prompts.tsx
│   │   │   │                   │   └── components
│   │   │   │                   │       ├── Folders.tsx
│   │   │   │                   │       ├── PromptComponent.tsx
│   │   │   │                   │       ├── PromptList.tsx
│   │   │   │                   │       ├── PromptModal.tsx
│   │   │   │                   │       └── PromptbarSettings.tsx
│   │   │   │                   └── SystemPrompts
│   │   │   │                       ├── SystemPrompts.context.tsx
│   │   │   │                       ├── SystemPrompts.state.tsx
│   │   │   │                       ├── SystemPrompts.tsx
│   │   │   │                       └── components
│   │   │   │                           ├── Folders.tsx
│   │   │   │                           ├── ModelsList.tsx
│   │   │   │                           ├── SystemPromptComponent.tsx
│   │   │   │                           ├── SystemPromptEditModal.tsx
│   │   │   │                           ├── SystemPromptList.tsx
│   │   │   │                           └── SystemPromptModal.tsx
│   │   │   ├── SecondaryMenu
│   │   │   │   ├── SecondaryMenu.context.tsx
│   │   │   │   ├── SecondaryMenu.state.tsx
│   │   │   │   ├── SecondaryMenu.tsx
│   │   │   │   └── components
│   │   │   │       ├── ActivityBar
│   │   │   │       │   ├── ActivityBar.tsx
│   │   │   │       │   └── components
│   │   │   │       │       ├── ActivityBarButton.tsx
│   │   │   │       │       └── ActivityBarTab.tsx
│   │   │   │       └── Menu
│   │   │   │           ├── Menu.tsx
│   │   │   │           └── components
│   │   │   │               └── Screens
│   │   │   │                   └── ModelSettings
│   │   │   │                       ├── ModelSettings.tsx
│   │   │   │                       └── components
│   │   │   │                           ├── InfoTooltip.tsx
│   │   │   │                           ├── ModelSelect.tsx
│   │   │   │                           ├── SystemPromptSelect.tsx
│   │   │   │                           └── Temperature.tsx
│   │   │   └── Settings
│   │   │       └── Import.tsx
│   │   ├── home.context.tsx
│   │   ├── home.state.tsx
│   │   ├── home.tsx
│   │   └── index.tsx
│   └── Markdown
│       ├── CodeBlock.tsx
│       └── MemoizedReactMarkdown.tsx
├── hooks
│   ├── useCreateReducer.ts
│   └── useFetch.ts
├── lib
│   └── graph.js
├── middleware.ts
├── next-env.d.ts
├── next-i18next.config.js
├── next.config.js
├── package-lock.json
├── package.json
├── postcss.config.js
├── prettier.config.js
├── public
│   ├── PoiesisLogo.svg
│   ├── cc.svg
│   ├── favicon.ico
│   ├── icon-256.svg
│   ├── icon-64.svg
│   ├── locales
│   │   ├── ar
│   │   │   ├── chat.json
│   │   │   ├── common.json
│   │   │   ├── markdown.json
│   │   │   ├── promptbar.json
│   │   │   ├── settings.json
│   │   │   └── sidebar.json
│   │   ├── bn
│   │   │   ├── chat.json
│   │   │   ├── common.json
│   │   │   ├── markdown.json
│   │   │   ├── promptbar.json
│   │   │   ├── settings.json
│   │   │   └── sidebar.json
│   │   ├── ca
│   │   │   ├── chat.json
│   │   │   ├── common.json
│   │   │   ├── markdown.json
│   │   │   ├── promptbar.json
│   │   │   └── sidebar.json
│   │   ├── de
│   │   │   ├── chat.json
│   │   │   ├── common.json
│   │   │   ├── markdown.json
│   │   │   ├── promptbar.json
│   │   │   ├── settings.json
│   │   │   └── sidebar.json
│   │   ├── en
│   │   │   └── common.json
│   │   ├── es
│   │   │   ├── chat.json
│   │   │   ├── common.json
│   │   │   ├── markdown.json
│   │   │   ├── promptbar.json
│   │   │   ├── settings.json
│   │   │   └── sidebar.json
│   │   ├── fi
│   │   │   ├── chat.json
│   │   │   ├── common.json
│   │   │   ├── markdown.json
│   │   │   ├── promptbar.json
│   │   │   ├── settings.json
│   │   │   └── sidebar.json
│   │   ├── fr
│   │   │   ├── chat.json
│   │   │   ├── common.json
│   │   │   ├── markdown.json
│   │   │   ├── promptbar.json
│   │   │   ├── settings.json
│   │   │   └── sidebar.json
│   │   ├── he
│   │   │   ├── chat.json
│   │   │   ├── common.json
│   │   │   ├── markdown.json
│   │   │   ├── promptbar.json
│   │   │   ├── settings.json
│   │   │   └── sidebar.json
│   │   ├── id
│   │   │   ├── chat.json
│   │   │   ├── common.json
│   │   │   ├── markdown.json
│   │   │   ├── promptbar.json
│   │   │   ├── settings.json
│   │   │   └── sidebar.json
│   │   ├── it
│   │   │   ├── chat.json
│   │   │   ├── common.json
│   │   │   ├── markdown.json
│   │   │   ├── promptbar.json
│   │   │   ├── settings.json
│   │   │   └── sidebar.json
│   │   ├── ja
│   │   │   ├── chat.json
│   │   │   ├── common.json
│   │   │   ├── markdown.json
│   │   │   ├── promptbar.json
│   │   │   ├── settings.json
│   │   │   └── sidebar.json
│   │   ├── ko
│   │   │   ├── chat.json
│   │   │   ├── common.json
│   │   │   ├── markdown.json
│   │   │   ├── promptbar.json
│   │   │   ├── settings.json
│   │   │   └── sidebar.json
│   │   ├── pl
│   │   │   ├── chat.json
│   │   │   ├── common.json
│   │   │   ├── markdown.json
│   │   │   ├── promptbar.json
│   │   │   ├── settings.json
│   │   │   └── sidebar.json
│   │   ├── pt
│   │   │   ├── chat.json
│   │   │   ├── common.json
│   │   │   ├── markdown.json
│   │   │   ├── promptbar.json
│   │   │   ├── settings.json
│   │   │   └── sidebar.json
│   │   ├── ro
│   │   │   ├── chat.json
│   │   │   ├── common.json
│   │   │   ├── markdown.json
│   │   │   ├── promptbar.json
│   │   │   ├── settings.json
│   │   │   └── sidebar.json
│   │   ├── ru
│   │   │   ├── chat.json
│   │   │   ├── common.json
│   │   │   ├── markdown.json
│   │   │   ├── promptbar.json
│   │   │   ├── settings.json
│   │   │   └── sidebar.json
│   │   ├── si
│   │   │   ├── chat.json
│   │   │   ├── common.json
│   │   │   ├── markdown.json
│   │   │   ├── promptbar.json
│   │   │   ├── settings.json
│   │   │   └── sidebar.json
│   │   ├── sv
│   │   │   ├── chat.json
│   │   │   ├── common.json
│   │   │   ├── markdown.json
│   │   │   ├── promptbar.json
│   │   │   ├── settings.json
│   │   │   └── sidebar.json
│   │   ├── te
│   │   │   ├── chat.json
│   │   │   ├── common.json
│   │   │   ├── markdown.json
│   │   │   ├── promptbar.json
│   │   │   ├── settings.json
│   │   │   └── sidebar.json
│   │   ├── tr
│   │   │   ├── chat.json
│   │   │   ├── common.json
│   │   │   ├── markdown.json
│   │   │   ├── promptbar.json
│   │   │   └── sidebar.json
│   │   ├── vi
│   │   │   ├── chat.json
│   │   │   ├── common.json
│   │   │   ├── markdown.json
│   │   │   ├── promptbar.json
│   │   │   ├── settings.json
│   │   │   └── sidebar.json
│   │   └── zh
│   │       ├── chat.json
│   │       ├── common.json
│   │       ├── markdown.json
│   │       ├── promptbar.json
│   │       ├── settings.json
│   │       └── sidebar.json
│   ├── screenshots
│   │   ├── screenshot-1.png
│   │   ├── screenshot-2.png
│   │   ├── screenshot-3.png
│   │   ├── screenshot-4.png
│   │   └── screenshot-5.png
│   └── v.svg
├── services
│   └── errorService.ts
├── styles
│   └── globals.css
├── tailwind.config.js
├── tsconfig.json
├── types
│   ├── ai-models.ts
│   ├── auth-provider.ts
│   ├── auth.ts
│   ├── chat.ts
│   ├── data.ts
│   ├── database.ts
│   ├── env.ts
│   ├── error.ts
│   ├── export.ts
│   ├── folder.ts
│   ├── learning.ts
│   ├── next-auth.d.ts
│   ├── prompt.ts
│   ├── settings.ts
│   └── system-prompt.ts
├── utils
│   ├── app
│   │   ├── auth
│   │   │   ├── constants.ts
│   │   │   ├── helpers.ts
│   │   │   └── providers.ts
│   │   ├── chat.ts
│   │   ├── clean.ts
│   │   ├── codeblock.ts
│   │   ├── const.ts
│   │   ├── debug
│   │   │   └── env-vars.ts
│   │   ├── docker
│   │   │   └── envFix.ts
│   │   ├── extensions
│   │   │   └── database.ts
│   │   ├── handlers
│   │   │   ├── EditMessage.tsx
│   │   │   ├── RegenerateMessage.tsx
│   │   │   ├── SendMessage.tsx
│   │   │   └── helpers
│   │   │       ├── messageReceiver.ts
│   │   │       └── messageSender.ts
│   │   ├── importExport.ts
│   │   ├── retrieval
│   │   │   ├── auth.ts
│   │   │   ├── conversations.ts
│   │   │   ├── database.ts
│   │   │   └── models.ts
│   │   ├── settings
│   │   │   ├── getSettings.ts
│   │   │   └── settingChoices.ts
│   │   ├── storage
│   │   │   ├── conversation.ts
│   │   │   ├── conversations.ts
│   │   │   ├── folder.ts
│   │   │   ├── folders.ts
│   │   │   ├── local
│   │   │   │   ├── apiKey.ts
│   │   │   │   ├── settings.ts
│   │   │   │   └── uiState.ts
│   │   │   ├── message.ts
│   │   │   ├── messages.ts
│   │   │   ├── prompt.ts
│   │   │   ├── prompts.ts
│   │   │   ├── selectedConversation.ts
│   │   │   ├── supabase
│   │   │   │   ├── client-side.ts
│   │   │   │   ├── helpers
│   │   │   │   │   ├── conversation.ts
│   │   │   │   │   ├── conversations.ts
│   │   │   │   │   ├── folder.ts
│   │   │   │   │   ├── folders.ts
│   │   │   │   │   ├── message.ts
│   │   │   │   │   ├── messages.ts
│   │   │   │   │   ├── prompt.ts
│   │   │   │   │   ├── prompts.ts
│   │   │   │   │   ├── systemPrompt.ts
│   │   │   │   │   └── systemPrompts.ts
│   │   │   │   ├── index.ts
│   │   │   │   └── types
│   │   │   │       └── supabase.ts
│   │   │   ├── systemPrompt.ts
│   │   │   └── systemPrompts.ts
│   │   └── time
│   │       └── time.ts
│   ├── data
│   │   └── throttle.ts
│   └── server
│       ├── ai_vendors
│       │   ├── anthropic
│       │   │   ├── getModels.ts
│       │   │   ├── getStream.ts
│       │   │   └── getTokenCount.ts
│       │   ├── getStream.ts
│       │   ├── getTokenCount.ts
│       │   ├── google
│       │   │   ├── getModels.ts
│       │   │   ├── getStream.ts
│       │   │   └── getTokenCount.ts
│       │   └── openai
│       │       ├── getModels.ts
│       │       ├── getStream.ts
│       │       └── getTokenCount.ts
│       └── google.ts
└── vitest.config.ts

108 directories, 346 files
./middleware.ts
import { withAuth } from 'next-auth/middleware';

import { dockerEnvVarFix } from './utils/app/docker/envFix';

const getSecret = () => {
  return dockerEnvVarFix(process.env.NEXTAUTH_SECRET);
};

const getEmailPatterns = () => {
  const patternsString = dockerEnvVarFix(process.env.NEXTAUTH_EMAIL_PATTERNS);
  return patternsString ? patternsString.split(',') : [];
};

export default withAuth({
  callbacks: {
    async authorized({ token }) {
      if (!token?.email) {
        return false;
      } else {
        const patterns = getEmailPatterns();
        if (patterns.length === 0) {
          return true; // No patterns specified, allow access
        }

        const email = token.email.toLowerCase();
        for (const pattern of patterns) {
          const regex = new RegExp(pattern.trim());
          if (email.match(regex)) {
            return true; // Email matches one of the patterns, allow access
          }
        }

        return false; // Email does not match any of the patterns, deny access
      }
    },
  },
  secret: getSecret(),
});
------------------------
./types/data.ts
export interface KeyValuePair {
  key: string;
  value: any;
}
------------------------
./types/auth-provider.ts
export type AuthProvider =
  | 'apple'
  | 'auth0'
  | 'azure'
  | 'cognito'
  | 'discord'
  | 'facebook'
  | 'github'
  | 'gitlab'
  | 'google'
  | 'okta'
  | 'reddit'
  | 'salesforce'
  | 'slack'
  | 'spotify'
  | 'twitch'
  | 'twitter';
------------------------
./types/learning.ts
export interface LearningFile {
  id: string;
  name: string;
  type: 'link' | 'document';
  url?: string;
  tags: string;
  folderId?: string;
  timestamp: string;
}

export interface Namespace {
  namespace: string;
}

export interface LearningResponse {
  message: string;
  metadata: LearningResponseMetadata[];
}

export interface LearningResponseMetadata {
  excerpt: string;
  metadata: {
    description: string;
    language: string;
    source: string;
    title: string;
  };
}
------------------------
./types/prompt.ts
export interface Prompt {
  id: string;
  name: string;
  description: string;
  content: string;
  models: string[];
  folderId: string | null;
}
------------------------
./types/settings.ts
export interface SettingChoice {
  name: string;
  value: string;
  default?: boolean;
}

export interface Setting {
  id: string;
  name: string;
  description: string;
  type: 'choice' | 'string' | 'number' | 'boolean' | 'multiline-string';
  value?: any;
  defaultValue?: any;
  choices?: SettingChoice[];
  min?: number;
  max?: number;
  storage: 'local' | HttpOnlyCookie;
}

export interface HttpOnlyCookie {
  domain: string;
  path: string;
}

export interface SettingsSection {
  id: string;
  name: string;
  settings: Setting[];
}

export interface SavedSetting {
  sectionId: string;
  settingId: string;
  value: any;
}

export const SystemSettings: SettingsSection[] = [
  {
    id: 'personalization',
    name: 'Personalization',
    settings: [
      {
        id: 'theme',
        name: 'Theme',
        description: 'Choose your theme.',
        type: 'choice',
        choices: [
          {
            name: 'Light',
            value: 'light',
          },
          {
            name: 'Dark',
            value: 'dark',
            default: true,
          },
          {
            name: 'Granite',
            value: 'g',
            default: true,
          },
        ],
        storage: 'local',
      },
    ],
  },
  {
    id: 'openai',
    name: 'OpenAI',
    settings: [
      {
        id: 'api_key',
        name: 'API Key',
        description: 'The API key to use for OpenAI models.',
        type: 'string',
        storage: 'local',
      },
      // {
      //   id: 'gpt-3.5-turbo_default_system_prompt',
      //   name: 'GPT-3.5 Default System Prompt',
      //   description: 'The default system prompt to use for GPT-3.5.',
      //   type: 'choice',
      //   choices: [
      //     {
      //       name: 'Default',
      //       value: 'default',
      //     },
      //   ],
      //   storage: 'local',
      // },
      // {
      //   id: 'gpt-4_default_system_prompt',
      //   name: 'GPT-4 Default System Prompt',
      //   description: 'The default system prompt to use for GPT-4.',
      //   type: 'choice',
      //   choices: [
      //     {
      //       name: 'Default',
      //       value: 'default',
      //     },
      //   ],
      //   storage: 'local',
      // },
    ],
  },
  {
    id: 'anthropic',
    name: 'Anthropic',
    settings: [
      {
        id: 'api_key',
        name: 'API Key',
        description: 'The API key to use for Anthropic models.',
        type: 'string',
        storage: 'local',
      },
      // {
      //   id: 'claude-v1_default_system_prompt',
      //   name: 'Claude V1 Default System Prompt',
      //   description: 'The default system prompt to use for Claude V1.',
      //   type: 'choice',
      //   choices: [
      //     {
      //       name: 'Default',
      //       value: 'default',
      //     },
      //   ],
      //   storage: 'local',
      // },
      // {
      //   id: 'claude-v1-100k_default_system_prompt',
      //   name: 'Claude V1 100k Default System Prompt',
      //   description: 'The default system prompt to use for Claude V1 100k.',
      //   type: 'choice',
      //   choices: [
      //     {
      //       name: 'Default',
      //       value: 'default',
      //     },
      //   ],
      //   storage: 'local',
      // },
      // {
      //   id: 'claude-instant-v1_default_system_prompt',
      //   name: 'Claude Instant V1 Default System Prompt',
      //   description: 'The default system prompt to use for Claude Instant V1.',
      //   type: 'choice',
      //   choices: [
      //     {
      //       name: 'Default',
      //       value: 'default',
      //     },
      //   ],
      //   storage: 'local',
      // },
      // {
      //   id: 'claude-instant-v1-100k_default_system_prompt',
      //   name: 'Claude Instant V1 100k Default System Prompt',
      //   description:
      //     'The default system prompt to use for Claude Instant V1 100k.',
      //   type: 'choice',
      //   choices: [
      //     {
      //       name: 'Default',
      //       value: 'default',
      //     },
      //   ],
      //   storage: 'local',
      // },
    ],
  },
  {
    id: 'google',
    name: 'Google',
    settings: [
      {
        id: 'api_key',
        name: 'API Key',
        description: 'The API key to use for PaLM 2 models.',
        type: 'string',
        storage: 'local',
      },
      // {
      //   id: 'claude-v1_default_system_prompt',
      //   name: 'Claude V1 Default System Prompt',
      //   description: 'The default system prompt to use for Claude V1.',
      //   type: 'choice',
      //   choices: [
      //     {
      //       name: 'Default',
      //       value: 'default',
      //     },
      //   ],
      //   storage: 'local',
      // },
      // {
      //   id: 'claude-v1-100k_default_system_prompt',
      //   name: 'Claude V1 100k Default System Prompt',
      //   description: 'The default system prompt to use for Claude V1 100k.',
      //   type: 'choice',
      //   choices: [
      //     {
      //       name: 'Default',
      //       value: 'default',
      //     },
      //   ],
      //   storage: 'local',
      // },
      // {
      //   id: 'claude-instant-v1_default_system_prompt',
      //   name: 'Claude Instant V1 Default System Prompt',
      //   description: 'The default system prompt to use for Claude Instant V1.',
      //   type: 'choice',
      //   choices: [
      //     {
      //       name: 'Default',
      //       value: 'default',
      //     },
      //   ],
      //   storage: 'local',
      // },
      // {
      //   id: 'claude-instant-v1-100k_default_system_prompt',
      //   name: 'Claude Instant V1 100k Default System Prompt',
      //   description:
      //     'The default system prompt to use for Claude Instant V1 100k.',
      //   type: 'choice',
      //   choices: [
      //     {
      //       name: 'Default',
      //       value: 'default',
      //     },
      //   ],
      //   storage: 'local',
      // },
    ],
  },
];
------------------------
./types/next-auth.d.ts
import NextAuth, { DefaultSession } from 'next-auth';

declare module 'next-auth' {
  // Returned by `useSession`, `getSession` and received as a prop on the `SessionProvider` React Context
  interface Session {
    // A JWT which can be used as Authorization header with supabase-js for RLS.
    customAccessToken: string;
    expiresAt: number;
  }
}
------------------------
./types/chat.ts
import { AiModel } from './ai-models';
import { SystemPrompt } from './system-prompt';

export interface Message {
  id: string;
  role: 'assistant' | 'user';
  content: string;
  timestamp: string;
}

export interface ChatBody {
  model: AiModel;
  messages: Message[];
  systemPrompt: SystemPrompt;
  temperature: number;
  apiKey?: string;
}

export interface Conversation {
  id: string;
  name: string;
  messages: Message[];
  model: AiModel;
  systemPrompt: SystemPrompt | null;
  temperature: number;
  folderId: string | null;
  timestamp: string;
}
------------------------
./types/ai-models.ts
export interface AiModel {
  id: string;
  maxLength: number; // maximum length of a message
  tokenLimit: number;
  requestLimit: number;
  vendor: 'OpenAI' | 'Anthropic' | 'Google';
}

export interface PossibleAiModelsInterface {
  [modelId: string]: AiModel;
}

export const PossibleAiModels: PossibleAiModelsInterface = {
  'gpt-3.5-turbo': {
    id: 'gpt-3.5-turbo',
    maxLength: 12000,
    tokenLimit: 4000,
    requestLimit: 3000,
    vendor: 'OpenAI',
  },
  'gpt-35-az': {
    id: 'gpt-35-az',
    maxLength: 12000,
    tokenLimit: 4000,
    requestLimit: 3000,
    vendor: 'OpenAI',
  },
  'gpt-4': {
    id: 'gpt-4',
    maxLength: 24000,
    tokenLimit: 8000,
    requestLimit: 6000,
    vendor: 'OpenAI',
  },
  'gpt-4-32k': {
    id: 'gpt-4-32k',
    maxLength: 96000,
    tokenLimit: 32000,
    requestLimit: 30000,
    vendor: 'OpenAI',
  },
  'gpt-35-turbo': {
    id: String(process.env.NEXT_PUBLIC_AZURE_DEPLOYMENT_ID),
    maxLength: 12000,
    tokenLimit: 4000,
    requestLimit: 3000,
    vendor: 'OpenAI',
  },
  'claude-instant-1': {
    id: 'claude-instant-1',
    maxLength: 400000,
    tokenLimit: 100000,
    requestLimit: 98000,
    vendor: 'Anthropic',
  },
  'claude-2': {
    id: 'claude-2',
    maxLength: 400000,
    tokenLimit: 100000,
    requestLimit: 98000,
    vendor: 'Anthropic',
  },
  bard: {
    id: 'bard',
    maxLength: 12000,
    tokenLimit: 4096,
    requestLimit: 3000,
    vendor: 'Google',
  },
};
------------------------
./types/system-prompt.ts
export interface SystemPrompt {
  id: string;
  name: string;
  content: string;
  folderId: string | null;
  models: string[];
}
------------------------
./types/export.ts
import { Conversation, Message } from './chat';
import { FolderInterface } from './folder';
import { Prompt } from './prompt';
import { SystemPrompt } from './system-prompt';

export type SupportedExportFormats = poiesisPeteExportFormatV1;
export type LatestExportFormat = poiesisPeteExportFormatV1;

export interface poiesisPeteExportFormatV1 {
  app: 'poiesisPete';
  version: 1;
  conversations: Conversation[];
  folders: FolderInterface[];
  message_templates: Prompt[];
  system_prompts: SystemPrompt[];
}
------------------------
./types/database.ts
import { User } from './auth';
import { Conversation, Message } from './chat';
import { FolderInterface } from './folder';
import { Prompt } from './prompt';
import { SystemPrompt } from './system-prompt';

export interface Database {
  name: string;

  connect(args?: any): Promise<void>;
  disconnect(): Promise<void>;

  // ------------------------------Conversation------------------------------
  createConversation(
    user: User,
    newConversation: Conversation,
  ): Promise<boolean>;

  updateConversation(
    user: User,
    updatedConversation: Conversation,
  ): Promise<boolean>;

  deleteConversation(user: User, conversationId: string): Promise<boolean>;

  // ------------------------------Conversations------------------------------
  getConversations(user: User): Promise<Conversation[]>;

  updateConversations(
    user: User,
    updatedConversations: Conversation[],
  ): Promise<boolean>;

  deleteConversations(user: User): Promise<boolean>;

  // ------------------------------Folder------------------------------
  createFolder(user: User, newFolder: FolderInterface): Promise<boolean>;

  updateFolder(user: User, updatedFolder: FolderInterface): Promise<boolean>;

  deleteFolder(user: User, folderId: string): Promise<boolean>;

  // ------------------------------Folders------------------------------
  getFolders(user: User): Promise<FolderInterface[]>;

  updateFolders(
    user: User,
    updatedFolders: FolderInterface[],
  ): Promise<boolean>;

  deleteFolders(user: User, folderIds: string[]): Promise<boolean>;

  // ------------------------------Message------------------------------
  createMessage(
    user: User,
    conversationId: string,
    newMessage: Message,
  ): Promise<boolean>;

  updateMessage(
    user: User,
    conversationId: string,
    updatedMessage: Message,
  ): Promise<boolean>;

  deleteMessage(
    user: User,
    conversationId: string,
    messageId: string,
  ): Promise<boolean>;

  // ------------------------------Messages------------------------------
  getMessages(user: User, conversationId: string): Promise<Message[]>;

  createMessages(
    user: User,
    conversationId: string,
    newMessages: Message[],
  ): Promise<boolean>;

  updateMessages(
    user: User,
    conversationId: string,
    updatedMessages: Message[],
  ): Promise<boolean>;

  deleteMessages(
    user: User,
    conversationId: string,
    messageIds: string[],
  ): Promise<boolean>;

  // ------------------------------Prompt------------------------------
  createPrompt(user: User, newPrompt: Prompt): Promise<boolean>;

  updatePrompt(user: User, updatedPrompt: Prompt): Promise<boolean>;

  deletePrompt(user: User, promptId: string): Promise<boolean>;

  // ------------------------------Prompts------------------------------
  getPrompts(user: User): Promise<Prompt[]>;

  updatePrompts(user: User, updatedPrompts: Prompt[]): Promise<boolean>;

  deletePrompts(user: User, promptIds: string[]): Promise<boolean>;

  // ------------------------------SystemPrompt------------------------------
  createSystemPrompt(
    user: User,
    newSystemPrompt: SystemPrompt,
  ): Promise<boolean>;

  updateSystemPrompt(
    user: User,
    updatedSystemPrompt: SystemPrompt,
  ): Promise<boolean>;

  deleteSystemPrompt(user: User, systemPromptId: string): Promise<boolean>;

  // ------------------------------SystemPrompts------------------------------
  getSystemPrompts(user: User): Promise<SystemPrompt[]>;

  updateSystemPrompts(
    user: User,
    updatedSystemPrompts: SystemPrompt[],
  ): Promise<boolean>;

  deleteSystemPrompts(user: User, systemPromptIds: string[]): Promise<boolean>;
}
------------------------
./types/folder.ts
export interface FolderInterface {
  id: string;
  name: string;
  type: 'chat' | 'prompt' | 'system_prompt';
}
------------------------
./types/env.ts
export interface ProcessEnv {
  OPENAI_API_KEY: string;
  OPENAI_API_HOST?: string;
  OPENAI_API_TYPE?: 'openai' | 'azure';
  OPENAI_API_VERSION?: string;
  OPENAI_ORGANIZATION?: string;
}
------------------------
./types/error.ts
export interface ErrorMessage {
  code: String | null;
  title: String;
  messageLines: String[];
}
------------------------
./types/auth.ts
export interface User {
  email?: string | null;
  image?: string | null;
  name?: string | null;
}

export interface Session {
  user?: User | null;
  customAccessToken?: string;
  expires: string;
}
------------------------
./app/layout.tsx
import { Analytics } from '@vercel/analytics/react';

import { Metadata } from 'next';

import '@/styles/globals.css';

export const metadata: Metadata = {
  title: 'poiesisPete',
  description:
    'Open source chat kit engineered for seamless interaction with AI models',
  viewport:
    'height=device-height, width=device-width, initial-scale=1, user-scalable=no',
};

export default function RootLayout({
  // Layouts must accept a children prop.
  // This will be populated with nested layouts or pages
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <Analytics />
      <body className="h-screen w-screen overflow-hidden overscroll-none">
        {children}
      </body>
    </html>
  );
}
------------------------
./app/api/chat/route.ts
import { getStream } from '@/utils/server/ai_vendors/getStream';
import { getTokenCount } from '@/utils/server/ai_vendors/getTokenCount';

import { ChatBody } from '@/types/chat';

export const runtime = 'edge';

const handler = async (req: Request): Promise<Response> => {
  const { model, messages, apiKey, systemPrompt, temperature } =
    (await req.json()) as ChatBody;

  const { error: tokenCountError, count } = await getTokenCount(
    model,
    systemPrompt.content,
    messages,
  );

  if (tokenCountError) {
    console.error(tokenCountError);
    return new Response('Error', {
      status: 500,
      statusText: tokenCountError,
    });
  }

  const { error: streamError, stream } = await getStream(
    model,
    systemPrompt.content,
    temperature,
    apiKey,
    messages,
    count!,
  );

  if (streamError) {
    console.error(streamError);
    return new Response('Error', {
      status: 500,
      statusText: streamError,
    });
  }

  return new Response(stream);
};

export { handler as GET, handler as POST };
------------------------
./app/api/auth/[...nextauth]/route.ts
import NextAuth, { NextAuthOptions } from 'next-auth';

import { getProviders } from '@/utils/app/auth/providers';
import {
  SUPABASE_JWT_SECRET,
  SUPABASE_SERVICE_ROLE_KEY,
  SUPABASE_URL,
} from '@/utils/app/const';

import { SupabaseAdapter } from '@next-auth/supabase-adapter';
import jwt from 'jsonwebtoken';

const authOptions: NextAuthOptions = {
  providers: await getProviders(),
  session: { strategy: 'jwt' },

  // Supabase adapter is only enabled if JWT secret is specified
  adapter: SUPABASE_JWT_SECRET
    ? SupabaseAdapter({
        url: SUPABASE_URL,
        secret: SUPABASE_SERVICE_ROLE_KEY,
      })
    : undefined,
  callbacks: {
    async session({ session, token }) {
      const signingSecret = SUPABASE_JWT_SECRET;
      if (signingSecret) {
        const payload = {
          aud: 'authenticated',
          exp: Math.floor(new Date(session.expires).getTime() / 1000),
          sub: token.sub,
          email: token.email,
          role: 'authenticated',
        };
        session.customAccessToken = jwt.sign(payload, signingSecret);
      }
      return session;
    },
  },
};

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };
------------------------
./app/api/models/route.ts
import { DEBUG_MODE } from '@/utils/app/const';
import { printEnvVariables } from '@/utils/app/debug/env-vars';
import { getAvailableAnthropicModels } from '@/utils/server/ai_vendors/anthropic/getModels';
import { getAvailablePalm2Models } from '@/utils/server/ai_vendors/google/getModels';
import { getAvailableOpenAIModels } from '@/utils/server/ai_vendors/openai/getModels';

import { AiModel } from '@/types/ai-models';

export const runtime = 'edge';

const handler = async (req: Request): Promise<Response> => {
  try {
    if (DEBUG_MODE) {
      console.log('----------SERVER-SIDE ENVIRONMENT VARIABLES----------');
      printEnvVariables();
    }

    const { openai_key, anthropic_key, palm_key } = (await req.json()) as {
      openai_key: string;
      anthropic_key: string;
      palm_key: string;
    };

    const models: AiModel[] = [];
    const { error: openaiError, data: openaiModels } =
      await getAvailableOpenAIModels(openai_key);
    if (openaiError) {
      console.error('Error getting OpenAI models');
    } else {
      models.push(...(openaiModels as AiModel[]));
    }

    const { data: anthropicModels } = await getAvailableAnthropicModels(
      anthropic_key,
    );
    models.push(...(anthropicModels as AiModel[]));

    const { data: palm2Models } = await getAvailablePalm2Models(palm_key);
    models.push(...(palm2Models as AiModel[]));

    return new Response(JSON.stringify(models), { status: 200 });
  } catch (error) {
    console.error(error);
    return new Response('Error getting available models', { status: 500 });
  }
};

export { handler as GET, handler as POST };
------------------------
./app/page.tsx
'use client';

export { default } from '@/components/Home';
------------------------
./utils/app/const.ts
import { dockerEnvVarFix } from './docker/envFix';

export const DEBUG_MODE =
  dockerEnvVarFix(process.env.NEXT_PUBLIC_DEBUG_MODE) === 'true' || false;

export const DEFAULT_MODEL =
  dockerEnvVarFix(process.env.NEXT_PUBLIC_DEFAULT_MODEL) || 'gpt-3.5-turbo';

export const DEFAULT_OPENAI_SYSTEM_PROMPT =
  dockerEnvVarFix(process.env.NEXT_PUBLIC_DEFAULT_OPENAI_SYSTEM_PROMPT) ||
  "You are ChatGPT, a large language model trained by OpenAI. Follow the user's instructions carefully. Respond using markdown.";

export const DEFAULT_ANTHROPIC_SYSTEM_PROMPT =
  dockerEnvVarFix(process.env.NEXT_PUBLIC_DEFAULT_ANTHROPIC_SYSTEM_PROMPT) ||
  '\n\nHuman: You are Claude, a large language model trained by Anthropic. Follow the my instructions carefully. Respond using markdown.\n\nAssistant: Okay.';

export const DEFAULT_PALM_SYSTEM_PROMPT =
  dockerEnvVarFix(process.env.NEXT_PUBLIC_DEFAULT_PALM_SYSTEM_PROMPT) ||
  "You are Bard, a large language model trained by Google. Follow the user's instructions carefully. Respond using markdown. Always specify the programming language you are using when making a markdown code block.";

export const DEFAULT_TEMPERATURE = parseFloat(
  dockerEnvVarFix(process.env.NEXT_PUBLIC_DEFAULT_TEMPERATURE) || '0.7',
);

export const OPENAI_API_URL =
  dockerEnvVarFix(process.env.OPENAI_API_URL) || 'https://api.openai.com/v1';

export const OPENAI_API_KEY = dockerEnvVarFix(process.env.OPENAI_API_KEY) || '';

export const OPENAI_API_TYPE =
  dockerEnvVarFix(process.env.OPENAI_API_TYPE) || 'openai';

export const OPENAI_API_VERSION =
  dockerEnvVarFix(process.env.OPENAI_API_VERSION) || '2023-03-15-preview';

export const OPENAI_ORGANIZATION =
  dockerEnvVarFix(process.env.OPENAI_ORGANIZATION) || '';

export const ANTHROPIC_API_URL =
  dockerEnvVarFix(process.env.ANTHROPIC_API_URL) ||
  'https://api.anthropic.com/v1';

export const ANTHROPIC_API_KEY =
  dockerEnvVarFix(process.env.ANTHROPIC_API_KEY) || '';

export const ANTHROPIC_API_VERSION =
  dockerEnvVarFix(process.env.ANTHROPIC_API_VERSION) || '2023-06-01';

export const PALM_API_URL =
  dockerEnvVarFix(process.env.PALM_API_URL) ||
  'https://generativelanguage.googleapis.com/v1beta2';

export const PALM_API_KEY = dockerEnvVarFix(process.env.PALM_API_KEY) || '';

export const APP_DOMAIN =
  dockerEnvVarFix(process.env.NEXT_PUBLIC_APP_DOMAIN) ||
  'http://localhost:3000';

export const SUPABASE_URL =
  dockerEnvVarFix(process.env.NEXT_PUBLIC_SUPABASE_URL) ||
  'SUPABASE_URL missing';

export const SUPABASE_SERVICE_ROLE_KEY =
  dockerEnvVarFix(process.env.SUPABASE_SERVICE_ROLE_KEY) || '';

export const SUPABASE_ANON_KEY =
  dockerEnvVarFix(process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY) || '';

export const SUPABASE_JWT_SECRET =
  dockerEnvVarFix(process.env.SUPABASE_JWT_SECRET) || '';
------------------------
./utils/app/settings/settingChoices.ts
import { SettingChoice, SettingsSection } from '@/types/settings';

export const setSettingChoices = (
  settings: SettingsSection[],
  sectionId: string,
  settingId: string,
  newChoices: SettingChoice[],
) => {
  const newSettings = settings.map((section) => {
    if (section.id === sectionId) {
      return {
        ...section,
        settings: section.settings.map((setting) => {
          if (setting.id === settingId) {
            return {
              ...setting,
              choices: newChoices,
            };
          }
          return setting;
        }),
      };
    }
    return section;
  });
  return newSettings;
};
------------------------
./utils/app/settings/getSettings.ts
import { SystemSettings } from '@/types/settings';

export function getSettings() {
  const settings = SystemSettings;
  return settings;
}
------------------------
./utils/app/docker/envFix.ts
// In docker, env files are not parsed correctly, so we remove unintended quotes and newlines
export const dockerEnvVarFix = (envVar: string | undefined) => {
  if (envVar) {
    let newEnvVar = envVar.replaceAll('"', '');
    newEnvVar = newEnvVar.replaceAll('\\n', '\n');
    return newEnvVar;
  } else {
    return undefined;
  }
};
------------------------
./utils/app/auth/helpers.ts
import { getSession } from 'next-auth/react';

import { Session, User } from '@/types/auth';

export const getClientSession = async () => {
  const authjsSession = await getSession();

  if (authjsSession) {
    let user: User | undefined = undefined;
    if (authjsSession.user) {
      user = {
        email: authjsSession?.user?.email,
        name: authjsSession?.user?.name,
        image: authjsSession?.user?.image,
      };
    }

    const session: Session = {
      user: user,
      expires: authjsSession.expires,
      customAccessToken: authjsSession.customAccessToken,
    };

    return session;
  }

  return null;
};

export const getUser = async () => {
  const session = await getClientSession();

  let user = session?.user;

  if (!user) {
    user = {
      email: 'default_user',
      image: null,
      name: 'Default User',
    };
  }

  return user;
};
------------------------
./utils/app/auth/providers.ts
import {
  APPLE_CLIENT_ID,
  APPLE_CLIENT_SECRET,
  AZURE_AD_CLIENT_ID,
  AZURE_AD_CLIENT_SECRET,
  AZURE_AD_TENANT_ID,
  AUTH0_CLIENT_ID,
  AUTH0_CLIENT_SECRET,
  AUTH0_ISSUER,
  COGNITO_CLIENT_ID,
  COGNITO_CLIENT_SECRET,
  DISCORD_CLIENT_ID,
  DISCORD_CLIENT_SECRET,
  FACEBOOK_CLIENT_ID,
  FACEBOOK_CLIENT_SECRET,
  GITHUB_CLIENT_ID,
  GITHUB_CLIENT_SECRET,
  GITLAB_CLIENT_ID,
  GITLAB_CLIENT_SECRET,
  GOOGLE_CLIENT_ID,
  GOOGLE_CLIENT_SECRET,
  OKTA_CLIENT_ID,
  OKTA_CLIENT_SECRET,
  REDDIT_CLIENT_ID,
  REDDIT_CLIENT_SECRET,
  SALESFORCE_CLIENT_ID,
  SALESFORCE_CLIENT_SECRET,
  SLACK_CLIENT_ID,
  SLACK_CLIENT_SECRET,
  SPOTIFY_CLIENT_ID,
  SPOTIFY_CLIENT_SECRET,
  TWITCH_CLIENT_ID,
  TWITCH_CLIENT_SECRET,
  TWITTER_CLIENT_ID,
  TWITTER_CLIENT_SECRET,
} from './constants';

const authorization = {
  params: {
    prompt: 'consent',
    access_type: 'offline',
    response_type: 'code',
  },
};

export async function getProviders() {
  const providers = [];
  if (APPLE_CLIENT_ID) {
    const provider = await import('next-auth/providers/apple');
    const AppleProvider = provider.default;
    providers.push(
      AppleProvider({
        clientId: APPLE_CLIENT_ID!,
        clientSecret: APPLE_CLIENT_SECRET!,
        authorization: authorization,
        allowDangerousEmailAccountLinking: true,
      }),
    );
  }
  if (AUTH0_CLIENT_ID) {
    const provider = await import('next-auth/providers/auth0');
    const Auth0Provider = provider.default;
    providers.push(
      Auth0Provider({
        clientId: AUTH0_CLIENT_ID!,
        clientSecret: AUTH0_CLIENT_SECRET!,
        issuer: AUTH0_ISSUER,
        authorization: authorization,
        allowDangerousEmailAccountLinking: true,
      }),
    );
  }
  if (COGNITO_CLIENT_ID) {
    const provider = await import('next-auth/providers/cognito');
    const CognitoProvider = provider.default;
    providers.push(
      CognitoProvider({
        clientId: COGNITO_CLIENT_ID!,
        clientSecret: COGNITO_CLIENT_SECRET!,
        authorization: authorization,
        allowDangerousEmailAccountLinking: true,
      }),
    );
  }
  if (DISCORD_CLIENT_ID) {
    const provider = await import('next-auth/providers/discord');
    const DiscordProvider = provider.default;
    providers.push(
      DiscordProvider({
        clientId: DISCORD_CLIENT_ID!,
        clientSecret: DISCORD_CLIENT_SECRET!,
        authorization: authorization,
        allowDangerousEmailAccountLinking: true,
      }),
    );
  }
  if (FACEBOOK_CLIENT_ID) {
    const provider = await import('next-auth/providers/facebook');
    const FacebookProvider = provider.default;
    providers.push(
      FacebookProvider({
        clientId: FACEBOOK_CLIENT_ID!,
        clientSecret: FACEBOOK_CLIENT_SECRET!,
        authorization: authorization,
        allowDangerousEmailAccountLinking: true,
      }),
    );
  }
  if (GITHUB_CLIENT_ID) {
    const provider = await import('next-auth/providers/github');
    const GithubProvider = provider.default;
    providers.push(
      GithubProvider({
        clientId: GITHUB_CLIENT_ID!,
        clientSecret: GITHUB_CLIENT_SECRET!,
        authorization: authorization,
        allowDangerousEmailAccountLinking: true,
      }),
    );
  }
  if (GITLAB_CLIENT_ID) {
    const provider = await import('next-auth/providers/gitlab');
    const GitlabProvider = provider.default;
    providers.push(
      GitlabProvider({
        clientId: GITLAB_CLIENT_ID!,
        clientSecret: GITLAB_CLIENT_SECRET!,
        authorization: authorization,
        allowDangerousEmailAccountLinking: true,
      }),
    );
  }
  if (GOOGLE_CLIENT_ID) {
    const provider = await import('next-auth/providers/google');
    const GoogleProvider = provider.default;
    providers.push(
      GoogleProvider({
        clientId: GOOGLE_CLIENT_ID!,
        clientSecret: GOOGLE_CLIENT_SECRET!,
        authorization: authorization,
        allowDangerousEmailAccountLinking: true,
      }),
    );
  }
  if (OKTA_CLIENT_ID) {
    const provider = await import('next-auth/providers/okta');
    const OktaProvider = provider.default;
    providers.push(
      OktaProvider({
        clientId: OKTA_CLIENT_ID!,
        clientSecret: OKTA_CLIENT_SECRET!,
        authorization: authorization,
        allowDangerousEmailAccountLinking: true,
      }),
    );
  }
  if (AZURE_AD_CLIENT_ID) {
    const provider = await import('next-auth/providers/azure-ad');
    const AzureProvider = provider.default;
    providers.push(
      AzureProvider({
        clientId: AZURE_AD_CLIENT_ID!,
        clientSecret: AZURE_AD_CLIENT_SECRET!,
        tenantId: process.env.AZURE_AD_TENANT_ID!,
        authorization: authorization,
        allowDangerousEmailAccountLinking: true,


      }),
    );
  }
  if (REDDIT_CLIENT_ID) {
    const provider = await import('next-auth/providers/reddit');
    const RedditProvider = provider.default;
    providers.push(
      RedditProvider({
        clientId: REDDIT_CLIENT_ID!,
        clientSecret: REDDIT_CLIENT_SECRET!,
        authorization: authorization,
        allowDangerousEmailAccountLinking: true,
      }),
    );
  }
  if (SALESFORCE_CLIENT_ID) {
    const provider = await import('next-auth/providers/salesforce');
    const SalesforceProvider = provider.default;
    providers.push(
      SalesforceProvider({
        clientId: SALESFORCE_CLIENT_ID!,
        clientSecret: SALESFORCE_CLIENT_SECRET!,
        authorization: authorization,
        allowDangerousEmailAccountLinking: true,
      }),
    );
  }

  if (SLACK_CLIENT_ID) {
    const provider = await import('next-auth/providers/slack');
    const SlackProvider = provider.default;
    providers.push(
      SlackProvider({
        clientId: SLACK_CLIENT_ID!,
        clientSecret: SLACK_CLIENT_SECRET!,
        authorization: authorization,
        allowDangerousEmailAccountLinking: true,
      }),
    );
  }

  if (SPOTIFY_CLIENT_ID) {
    const provider = await import('next-auth/providers/spotify');
    const SpotifyProvider = provider.default;
    providers.push(
      SpotifyProvider({
        clientId: SPOTIFY_CLIENT_ID!,
        clientSecret: SPOTIFY_CLIENT_SECRET!,
        authorization: authorization,
        allowDangerousEmailAccountLinking: true,
      }),
    );
  }

  if (TWITCH_CLIENT_ID) {
    const provider = await import('next-auth/providers/twitch');
    const TwitchProvider = provider.default;
    providers.push(
      TwitchProvider({
        clientId: TWITCH_CLIENT_ID!,
        clientSecret: TWITCH_CLIENT_SECRET!,
        authorization: authorization,
        allowDangerousEmailAccountLinking: true,
      }),
    );
  }

  if (TWITTER_CLIENT_ID) {
    const provider = await import('next-auth/providers/twitter');
    const TwitterProvider = provider.default;
    providers.push(
      TwitterProvider({
        clientId: TWITTER_CLIENT_ID!,
        clientSecret: TWITTER_CLIENT_SECRET!,
        authorization: authorization,
        allowDangerousEmailAccountLinking: true,
      }),
    );
  }

  return providers;
}
------------------------
./utils/app/auth/constants.ts
import { dockerEnvVarFix } from '../docker/envFix';

export const APPLE_CLIENT_ID =
  dockerEnvVarFix(process.env.APPLE_CLIENT_ID) || '';

export const APPLE_CLIENT_SECRET =
  dockerEnvVarFix(process.env.APPLE_CLIENT_SECRET) || '';

export const AUTH0_CLIENT_ID =
  dockerEnvVarFix(process.env.AUTH0_CLIENT_ID) || '';

export const AUTH0_CLIENT_SECRET =
  dockerEnvVarFix(process.env.AUTH0_CLIENT_SECRET) || '';

export const AUTH0_ISSUER = dockerEnvVarFix(process.env.AUTH0_ISSUER) || '';

export const COGNITO_CLIENT_ID =
  dockerEnvVarFix(process.env.COGNITO_CLIENT_ID) || '';

export const COGNITO_CLIENT_SECRET =
  dockerEnvVarFix(process.env.COGNITO_CLIENT_SECRET) || '';

export const DISCORD_CLIENT_ID =
  dockerEnvVarFix(process.env.DISCORD_CLIENT_ID) || '';

export const DISCORD_CLIENT_SECRET =
  dockerEnvVarFix(process.env.DISCORD_CLIENT_SECRET) || '';

export const FACEBOOK_CLIENT_ID =
  dockerEnvVarFix(process.env.FACEBOOK_CLIENT_ID) || '';

export const FACEBOOK_CLIENT_SECRET =
  dockerEnvVarFix(process.env.FACEBOOK_CLIENT_SECRET) || '';

export const GITHUB_CLIENT_ID =
  dockerEnvVarFix(process.env.GITHUB_CLIENT_ID) || '';

export const GITHUB_CLIENT_SECRET =
  dockerEnvVarFix(process.env.GITHUB_CLIENT_SECRET) || '';

export const GITLAB_CLIENT_ID =
  dockerEnvVarFix(process.env.GITLAB_CLIENT_ID) || '';

export const GITLAB_CLIENT_SECRET =
  dockerEnvVarFix(process.env.GITLAB_CLIENT_SECRET) || '';

export const GOOGLE_CLIENT_ID =
  dockerEnvVarFix(process.env.GOOGLE_CLIENT_ID) || '';

export const GOOGLE_CLIENT_SECRET =
  dockerEnvVarFix(process.env.GOOGLE_CLIENT_SECRET) || '';

export const OKTA_CLIENT_ID = dockerEnvVarFix(process.env.OKTA_CLIENT_ID) || '';

export const OKTA_CLIENT_SECRET =
  dockerEnvVarFix(process.env.OKTA_CLIENT_SECRET) || '';

export const REDDIT_CLIENT_ID =
  dockerEnvVarFix(process.env.REDDIT_CLIENT_ID) || '';

export const REDDIT_CLIENT_SECRET =
  dockerEnvVarFix(process.env.REDDIT_CLIENT_SECRET) || '';

export const SALESFORCE_CLIENT_ID =
  dockerEnvVarFix(process.env.SALESFORCE_CLIENT_ID) || '';

export const SALESFORCE_CLIENT_SECRET =
  dockerEnvVarFix(process.env.SALESFORCE_CLIENT_SECRET) || '';

export const SLACK_CLIENT_ID =
  dockerEnvVarFix(process.env.SLACK_CLIENT_ID) || '';

export const SLACK_CLIENT_SECRET =
  dockerEnvVarFix(process.env.SLACK_CLIENT_SECRET) || '';

export const SPOTIFY_CLIENT_ID =
  dockerEnvVarFix(process.env.SPOTIFY_CLIENT_ID) || '';

export const SPOTIFY_CLIENT_SECRET =
  dockerEnvVarFix(process.env.SPOTIFY_CLIENT_SECRET) || '';

export const TWITCH_CLIENT_ID =
  dockerEnvVarFix(process.env.TWITCH_CLIENT_ID) || '';

export const TWITCH_CLIENT_SECRET =
  dockerEnvVarFix(process.env.TWITCH_CLIENT_SECRET) || '';

export const TWITTER_CLIENT_ID =
  dockerEnvVarFix(process.env.TWITTER_CLIENT_ID) || '';

export const TWITTER_CLIENT_SECRET =
  dockerEnvVarFix(process.env.TWITTER_CLIENT_SECRET) || '';

export const AZURE_AD_CLIENT_ID = 
  dockerEnvVarFix(process.env.AZURE_AD_CLIENT_ID) || '';
export const AZURE_AD_TENANT_ID = 
  dockerEnvVarFix(process.env.AZURE_AD_TENANT_ID) || '';

export const AZURE_AD_CLIENT_SECRET = 
  dockerEnvVarFix(process.env.AZURE_AD_CLIENT_SECRET) || '';
  


------------------------
./utils/app/codeblock.ts
interface languageMap {
  [key: string]: string | undefined;
}

export const programmingLanguages: languageMap = {
  javascript: '.js',
  python: '.py',
  java: '.java',
  c: '.c',
  cpp: '.cpp',
  'c++': '.cpp',
  'c#': '.cs',
  ruby: '.rb',
  php: '.php',
  swift: '.swift',
  'objective-c': '.m',
  kotlin: '.kt',
  typescript: '.ts',
  go: '.go',
  perl: '.pl',
  rust: '.rs',
  scala: '.scala',
  haskell: '.hs',
  lua: '.lua',
  shell: '.sh',
  sql: '.sql',
  html: '.html',
  css: '.css',
  // add more file extensions here, make sure the key is same as language prop in CodeBlock.tsx component
};

export const generateRandomString = (length: number, lowercase = false) => {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXY3456789'; // excluding similar looking characters like Z, 2, I, 1, O, 0
  let result = '';
  for (let i = 0; i < length; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return lowercase ? result.toLowerCase() : result;
};
------------------------
./utils/app/chat.ts
import { ChatBody, Conversation } from '@/types/chat';
import { SavedSetting } from '@/types/settings';

import { getSavedSettingValue } from './storage/local/settings';

export const sendChatRequest = async (
  conversation: Conversation,
  savedSetting: SavedSetting[],
) => {
  const apiKey: string | undefined = getSavedSettingValue(
    savedSetting,
    conversation.model.vendor.toLowerCase(),
    'api_key',
  );

  const chatBody: ChatBody = {
    model: conversation.model,
    messages: conversation.messages,
    apiKey: apiKey,
    systemPrompt: conversation.systemPrompt!,
    temperature: conversation.temperature,
  };

  let body = JSON.stringify(chatBody);
  const controller = new AbortController();
  const response = await fetch('api/chat', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    signal: controller.signal,
    body,
  });

  return { response: response, controller: controller };
};
------------------------
./utils/app/storage/conversations.ts
import { User } from '@/types/auth';
import { Conversation } from '@/types/chat';
import { Database } from '@/types/database';

export const storageGetConversations = async (
  database: Database,
  user: User,
) => {
  return await database.getConversations(user);
};

export const storageUpdateConversations = async (
  database: Database,
  user: User,
  conversations: Conversation[],
) => {
  await database.updateConversations(user, conversations).then((success) => {
    if (!success) {
      console.error('Failed to update conversations');
    }
  });
};

export const storageDeleteConversations = async (
  database: Database,
  user: User,
) => {
  database.deleteConversations(user).then((success) => {
    if (!success) {
      console.error('Failed to delete conversations');
    }
  });
};
------------------------
./utils/app/storage/folders.ts
import { User } from '@/types/auth';
import { Database } from '@/types/database';
import { FolderInterface } from '@/types/folder';

export const storageGetFolders = async (database: Database, user: User) => {
  return await database.getFolders(user);
};

export const storageUpdateFolders = async (
  database: Database,
  user: User,
  folders: FolderInterface[],
) => {
  await database.updateFolders(user, folders).then((success) => {
    if (!success) {
      console.error('Failed to update folders');
    }
  });
};

export const storageDeleteFolders = async (
  database: Database,
  user: User,
  folderIds: string[],
) => {
  await database.deleteFolders(user, folderIds).then((success) => {
    if (!success) {
      console.error('Failed to delete folders');
    }
  });
};
------------------------
./utils/app/storage/selectedConversation.ts
import { User } from '@/types/auth';
import { Conversation } from '@/types/chat';

export const getSelectedConversation = (user: User) => {
  const itemName = `selectedConversation-${user.email}`;
  return localStorage.getItem(itemName);
};

export const saveSelectedConversation = (
  user: User,
  conversation: Conversation,
) => {
  const itemName = `selectedConversation-${user.email}`;
  localStorage.setItem(itemName, JSON.stringify(conversation));
};

export const deleteSelectedConversation = (user: User) => {
  const itemName = `selectedConversation-${user.email}`;
  localStorage.removeItem(itemName);
};
------------------------
./utils/app/storage/prompt.ts
import { User } from '@/types/auth';
import { Database } from '@/types/database';
import { Prompt } from '@/types/prompt';

export const storageCreatePrompt = (
  database: Database,
  user: User,
  newPrompt: Prompt,
  allPrompts: Prompt[],
) => {
  const updatedPrompts = [...allPrompts, newPrompt];

  database.createPrompt(user, newPrompt).then((success) => {
    if (!success) {
      console.error('Failed to create prompt');
    }
  });

  return updatedPrompts;
};

export const storageUpdatePrompt = (
  database: Database,
  user: User,
  updatedPrompt: Prompt,
  allPrompts: Prompt[],
) => {
  const updatedPrompts = allPrompts.map((c) => {
    if (c.id === updatedPrompt.id) {
      return updatedPrompt;
    }

    return c;
  });

  database.updatePrompt(user, updatedPrompt).then((success) => {
    if (!success) {
      console.error('Failed to update prompt');
    }
  });

  return {
    single: updatedPrompt,
    all: updatedPrompts,
  };
};

export const storageDeletePrompt = (
  database: Database,
  user: User,
  promptId: string,
  allPrompts: Prompt[],
) => {
  const updatedPrompts = allPrompts.filter((p) => p.id !== promptId);

  database.deletePrompt(user, promptId).then((success) => {
    if (!success) {
      console.error('Failed to delete prompt');
    }
  });

  return updatedPrompts;
};
------------------------
./utils/app/storage/messages.ts
import { User } from '@/types/auth';
import { Conversation, Message } from '@/types/chat';
import { Database } from '@/types/database';

export const storageGetMessages = async (
  database: Database,
  user: User,
  selectedConversation: Conversation,
) => {
  return await database.getMessages(user, selectedConversation.id);
};

export const storageCreateMessages = (
  database: Database,
  user: User,
  selectedConversation: Conversation,
  newMessages: Message[],
  allConversations: Conversation[],
) => {
  const messages = selectedConversation.messages;
  const updatedMessages = [...messages, ...newMessages];

  const updatedConversation: Conversation = {
    ...selectedConversation,
    messages: updatedMessages,
  };

  const updatedConversations = allConversations.map((c) => {
    if (c.id === updatedConversation.id) {
      return updatedConversation;
    }

    return c;
  });

  database
    .createMessages(user, selectedConversation.id, newMessages)
    .then((success) => {
      if (!success) {
        console.error('Failed to create messages');
      }
    });

  return {
    single: updatedConversation,
    all: updatedConversations,
  };
};

export const storageUpdateMessages = (
  database: Database,
  user: User,
  selectedConversation: Conversation,
  updatedMessages: Message[],
  allConversations: Conversation[],
) => {
  // Creating a new array that replaces the old messages with the updated messages
  const updatedMessageList = selectedConversation.messages.map((message) => {
    const updatedMessage = updatedMessages.find((m) => m.id === message.id);
    if (updatedMessage) {
      return updatedMessage;
    }
    return message;
  });

  const updatedConversation: Conversation = {
    ...selectedConversation,
    messages: updatedMessageList,
  };

  const updatedConversations = allConversations.map((c) => {
    if (c.id === updatedConversation.id) {
      return updatedConversation;
    }

    return c;
  });

  database.updateMessages(user, selectedConversation.id, updatedMessages);

  return {
    single: updatedConversation,
    all: updatedConversations,
  };
};

export const storageDeleteMessages = (
  database: Database,
  user: User,
  messageIds: string[],
  selectedConversation: Conversation,
  allMessages: Message[],
  allConversations: Conversation[],
) => {
  // Creating a new array of messages that does not include the deleted messages
  const updatedMessages = allMessages.filter(
    (message) => !messageIds.includes(message.id),
  );

  const updatedConversation: Conversation = {
    ...selectedConversation,
    messages: updatedMessages,
  };

  const updatedConversations = allConversations.map((c) => {
    if (c.id === updatedConversation.id) {
      return updatedConversation;
    }

    return c;
  });

  database.deleteMessages(user, selectedConversation.id, messageIds);

  return {
    single: updatedConversation,
    all: updatedConversations,
  };
};
------------------------
./utils/app/storage/systemPrompt.ts
import { User } from '@/types/auth';
import { Database } from '@/types/database';
import { SystemPrompt } from '@/types/system-prompt';

export const storageCreateSystemPrompt = (
  database: Database,
  user: User,
  newSystemPrompt: SystemPrompt,
  allSystemPrompts: SystemPrompt[],
) => {
  const updatedSystemPrompts = [...allSystemPrompts, newSystemPrompt];

  database.createSystemPrompt(user, newSystemPrompt).then((success) => {
    if (!success) {
      console.error('Failed to create system prompt');
    }
  });

  return updatedSystemPrompts;
};

export const storageUpdateSystemPrompt = (
  database: Database,
  user: User,
  updatedSystemPrompt: SystemPrompt,
  allPrompts: SystemPrompt[],
) => {
  const updatedSystemPrompts = allPrompts.map((c) => {
    if (c.id === updatedSystemPrompt.id) {
      return updatedSystemPrompt;
    }

    return c;
  });

  database.updateSystemPrompt(user, updatedSystemPrompt).then((success) => {
    if (!success) {
      console.error('Failed to update system prompt');
    }
  });

  return {
    single: updatedSystemPrompt,
    all: updatedSystemPrompts,
  };
};

export const storageDeleteSystemPrompt = (
  database: Database,
  user: User,
  promptId: string,
  allPrompts: SystemPrompt[],
) => {
  const updatedSystemPrompts = allPrompts.filter((p) => p.id !== promptId);

  database.deleteSystemPrompt(user, promptId).then((success) => {
    if (!success) {
      console.error('Failed to delete system prompt');
    }
  });

  return updatedSystemPrompts;
};
------------------------
./utils/app/storage/supabase/types/supabase.ts
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[];

export interface SupaDatabase {
  public: {
    Tables: {
      conversations: {
        Row: {
          folder_id: string | null;
          id: string;
          model_id: string;
          name: string;
          system_prompt_id: string | null;
          temperature: number;
          timestamp: string;
          user_id: string;
        };
        Insert: {
          folder_id?: string | null;
          id?: string;
          model_id: string;
          name: string;
          system_prompt_id?: string | null;
          temperature: number;
          timestamp: string;
          user_id?: string;
        };
        Update: {
          folder_id?: string | null;
          id?: string;
          model_id?: string;
          name?: string;
          system_prompt_id?: string | null;
          temperature?: number;
          timestamp?: string;
          user_id?: string;
        };
        Relationships: [
          {
            foreignKeyName: 'conversation_owner';
            columns: ['user_id'];
            referencedRelation: 'users';
            referencedColumns: ['id'];
          },
          {
            foreignKeyName: 'conversation_owner_folder';
            columns: ['folder_id'];
            referencedRelation: 'folders';
            referencedColumns: ['id'];
          },
        ];
      };
      folders: {
        Row: {
          folder_type: string;
          id: string;
          name: string;
          user_id: string;
        };
        Insert: {
          folder_type: string;
          id?: string;
          name: string;
          user_id?: string;
        };
        Update: {
          folder_type?: string;
          id?: string;
          name?: string;
          user_id?: string;
        };
        Relationships: [
          {
            foreignKeyName: 'folder_owner';
            columns: ['user_id'];
            referencedRelation: 'users';
            referencedColumns: ['id'];
          },
        ];
      };
      messages: {
        Row: {
          content: string;
          conversation_id: string;
          id: string;
          role: string;
          timestamp: string;
          user_id: string;
        };
        Insert: {
          content: string;
          conversation_id: string;
          id?: string;
          role: string;
          timestamp: string;
          user_id?: string;
        };
        Update: {
          content?: string;
          conversation_id?: string;
          id?: string;
          role?: string;
          timestamp?: string;
          user_id?: string;
        };
        Relationships: [
          {
            foreignKeyName: 'message_owner';
            columns: ['user_id'];
            referencedRelation: 'users';
            referencedColumns: ['id'];
          },
          {
            foreignKeyName: 'message_owner_convo';
            columns: ['conversation_id'];
            referencedRelation: 'conversations';
            referencedColumns: ['id'];
          },
        ];
      };
      prompts: {
        Row: {
          content: string;
          description: string;
          folder_id: string | null;
          id: string;
          models: string[];
          name: string;
          user_id: string;
        };
        Insert: {
          content: string;
          description: string;
          folder_id?: string | null;
          id?: string;
          models: string[];
          name: string;
          user_id?: string;
        };
        Update: {
          content?: string;
          description?: string;
          folder_id?: string | null;
          id?: string;
          models?: string[];
          name?: string;
          user_id?: string;
        };
        Relationships: [
          {
            foreignKeyName: 'prompt_owner';
            columns: ['user_id'];
            referencedRelation: 'users';
            referencedColumns: ['id'];
          },
          {
            foreignKeyName: 'prompt_owner_folder';
            columns: ['folder_id'];
            referencedRelation: 'folders';
            referencedColumns: ['id'];
          },
        ];
      };
      system_prompts: {
        Row: {
          content: string;
          folder_id: string | null;
          id: string;
          models: string[];
          name: string;
          user_id: string;
        };
        Insert: {
          content: string;
          folder_id?: string | null;
          id?: string;
          models: string[];
          name: string;
          user_id?: string;
        };
        Update: {
          content?: string;
          folder_id?: string | null;
          id?: string;
          models?: string[];
          name?: string;
          user_id?: string;
        };
        Relationships: [
          {
            foreignKeyName: 'system_prompt_owner';
            columns: ['user_id'];
            referencedRelation: 'users';
            referencedColumns: ['id'];
          },
          {
            foreignKeyName: 'system_prompt_owner_folder';
            columns: ['folder_id'];
            referencedRelation: 'folders';
            referencedColumns: ['id'];
          },
        ];
      };
    };
    Views: {
      [_ in never]: never;
    };
    Functions: {
      [_ in never]: never;
    };
    Enums: {
      [_ in never]: never;
    };
    CompositeTypes: {
      [_ in never]: never;
    };
  };
}
------------------------
./utils/app/storage/supabase/client-side.ts
import { SupaDatabase } from './types/supabase';
import { User } from '@/types/auth';
import { Conversation, Message } from '@/types/chat';
import { Database } from '@/types/database';
import { FolderInterface } from '@/types/folder';
import { Prompt } from '@/types/prompt';
import { SystemPrompt } from '@/types/system-prompt';

import { OPENAI_API_KEY, SUPABASE_ANON_KEY, SUPABASE_URL } from '../../const';
import {
  supaCreateConversation,
  supaDeleteConversation,
  supaUpdateConversation,
} from './helpers/conversation';
import {
  supaDeleteConversations,
  supaGetConversations,
  supaUpdateConversations,
} from './helpers/conversations';
import {
  supaCreateFolder,
  supaDeleteFolder,
  supaUpdateFolder,
} from './helpers/folder';
import {
  supaDeleteFolders,
  supaGetFolders,
  supaUpdateFolders,
} from './helpers/folders';
import {
  supaCreateMessage,
  supaDeleteMessage,
  supaUpdateMessage,
} from './helpers/message';
import {
  supaCreateMessages,
  supaDeleteMessages,
  supaGetMessages,
  supaUpdateMessages,
} from './helpers/messages';
import {
  supaCreatePrompt,
  supaDeletePrompt,
  supaUpdatePrompt,
} from './helpers/prompt';
import {
  supaDeletePrompts,
  supaGetPrompts,
  supaUpdatePrompts,
} from './helpers/prompts';
import {
  supaCreateSystemPrompt,
  supaDeleteSystemPrompt,
  supaUpdateSystemPrompt,
} from './helpers/systemPrompt';
import {
  supaDeleteSystemPrompts,
  supaGetSystemPrompts,
  supaUpdateSystemPrompts,
} from './helpers/systemPrompts';

import { SupabaseClient, createClient } from '@supabase/supabase-js';

export class ClientDatabase implements Database {
  name = 'supabase';
  supabase: SupabaseClient | null = null;

  async connect({
    customAccessToken,
  }: {
    customAccessToken: string;
  }): Promise<void> {
    if (!this.supabase) {
      this.supabase = createClient<SupaDatabase>(
        SUPABASE_URL,
        SUPABASE_ANON_KEY,
        {
          global: {
            headers: {
              Authorization: `Bearer ${customAccessToken}`,
            },
          },
          auth: {
            persistSession: false,
          },
        },
      );
    }
  }

  async disconnect(): Promise<void> {}

  // -----------------------------------Conversation-----------------------------------

  async createConversation(
    user: User,
    newConversation: Conversation,
  ): Promise<boolean> {
    return await supaCreateConversation(this.supabase!, newConversation);
  }

  async updateConversation(
    user: User,
    updatedConversation: Conversation,
  ): Promise<boolean> {
    return await supaUpdateConversation(this.supabase!, updatedConversation);
  }

  async deleteConversation(
    user: User,
    conversationId: string,
  ): Promise<boolean> {
    return await supaDeleteConversation(this.supabase!, conversationId);
  }

  // -----------------------------------Conversations-----------------------------------
  async getConversations(user: User): Promise<Conversation[]> {
    return await supaGetConversations(this.supabase!);
  }

  async updateConversations(
    user: User,
    updatedConversations: Conversation[],
  ): Promise<boolean> {
    return await supaUpdateConversations(this.supabase!, updatedConversations);
  }

  async deleteConversations(user: User): Promise<boolean> {
    return await supaDeleteConversations(this.supabase!);
  }

  // -----------------------------------Folder-----------------------------------

  async createFolder(user: User, newFolder: FolderInterface): Promise<boolean> {
    return await supaCreateFolder(this.supabase!, newFolder);
  }

  async updateFolder(
    user: User,
    updatedFolder: FolderInterface,
  ): Promise<boolean> {
    return await supaUpdateFolder(this.supabase!, updatedFolder);
  }

  async deleteFolder(user: User, folderId: string): Promise<boolean> {
    return await supaDeleteFolder(this.supabase!, folderId);
  }

  // -----------------------------------Folders-----------------------------------
  async getFolders(user: User): Promise<FolderInterface[]> {
    return await supaGetFolders(this.supabase!);
  }

  async updateFolders(
    user: User,
    updatedFolders: FolderInterface[],
  ): Promise<boolean> {
    return await supaUpdateFolders(this.supabase!, updatedFolders);
  }

  async deleteFolders(user: User, folderIds: string[]): Promise<boolean> {
    return await supaDeleteFolders(this.supabase!, folderIds);
  }

  // -----------------------------------Message-----------------------------------
  async createMessage(
    user: User,
    conversationId: string,
    newMessage: Message,
  ): Promise<boolean> {
    return await supaCreateMessage(this.supabase!, conversationId, newMessage);
  }

  async updateMessage(
    user: User,
    conversationId: string,
    updatedMessage: Message,
  ): Promise<boolean> {
    return await supaUpdateMessage(
      this.supabase!,
      conversationId,
      updatedMessage,
    );
  }

  async deleteMessage(
    user: User,
    conversationId: string,
    messageId: string,
  ): Promise<boolean> {
    return await supaDeleteMessage(this.supabase!, conversationId, messageId);
  }

  // -----------------------------------Messages-----------------------------------
  async getMessages(user: User, conversationId: string): Promise<Message[]> {
    return await supaGetMessages(this.supabase!, conversationId);
  }

  async createMessages(
    user: User,
    conversationId: string,
    newMessages: Message[],
  ): Promise<boolean> {
    return await supaCreateMessages(
      this.supabase!,
      conversationId,
      newMessages,
    );
  }

  async updateMessages(
    user: User,
    conversationId: string,
    updatedMessages: Message[],
  ): Promise<boolean> {
    return await supaUpdateMessages(
      this.supabase!,
      conversationId,
      updatedMessages,
    );
  }

  async deleteMessages(
    user: User,
    conversationId: string,
    messageIds: string[],
  ): Promise<boolean> {
    return await supaDeleteMessages(this.supabase!, conversationId, messageIds);
  }

  // -----------------------------------Prompt-----------------------------------
  async createPrompt(user: User, newPrompt: Prompt): Promise<boolean> {
    return await supaCreatePrompt(this.supabase!, newPrompt);
  }

  async updatePrompt(user: User, updatedPrompt: Prompt): Promise<boolean> {
    return await supaUpdatePrompt(this.supabase!, updatedPrompt);
  }

  async deletePrompt(user: User, promptId: string): Promise<boolean> {
    return await supaDeletePrompt(this.supabase!, promptId);
  }

  // -----------------------------------Prompts-----------------------------------
  async getPrompts(user: User): Promise<Prompt[]> {
    return await supaGetPrompts(this.supabase!);
  }

  async updatePrompts(user: User, updatedPrompts: Prompt[]): Promise<boolean> {
    return await supaUpdatePrompts(this.supabase!, updatedPrompts);
  }

  async deletePrompts(user: User, promptIds: string[]): Promise<boolean> {
    return await supaDeletePrompts(this.supabase!, promptIds);
  }

  // -----------------------------------SystemPrompt-----------------------------------
  async createSystemPrompt(
    user: User,
    newSystemPrompt: SystemPrompt,
  ): Promise<boolean> {
    return await supaCreateSystemPrompt(this.supabase!, newSystemPrompt);
  }

  async updateSystemPrompt(
    user: User,
    updatedSystemPrompt: SystemPrompt,
  ): Promise<boolean> {
    return await supaUpdateSystemPrompt(this.supabase!, updatedSystemPrompt);
  }

  async deleteSystemPrompt(
    user: User,
    systemPromptId: string,
  ): Promise<boolean> {
    return await supaDeleteSystemPrompt(this.supabase!, systemPromptId);
  }

  // -----------------------------------SystemPrompts-----------------------------------
  async getSystemPrompts(user: User): Promise<SystemPrompt[]> {
    return await supaGetSystemPrompts(this.supabase!);
  }

  async updateSystemPrompts(
    user: User,
    updatedSystemPrompts: SystemPrompt[],
  ): Promise<boolean> {
    return await supaUpdateSystemPrompts(this.supabase!, updatedSystemPrompts);
  }

  async deleteSystemPrompts(
    user: User,
    systemPromptIds: string[],
  ): Promise<boolean> {
    return await supaDeleteSystemPrompts(this.supabase!, systemPromptIds);
  }
}
------------------------
./utils/app/storage/supabase/index.ts
export { ClientDatabase } from './client-side';
------------------------
./utils/app/storage/supabase/helpers/conversations.ts
import { SupaDatabase } from '../types/supabase';
import { PossibleAiModels } from '@/types/ai-models';
import { Conversation } from '@/types/chat';
import { SystemPrompt } from '@/types/system-prompt';

import { supaGetMessages } from './messages';
import { supaGetSystemPrompt } from './systemPrompt';

import { SupabaseClient } from '@supabase/supabase-js';

export const supaGetConversations = async (
  supabase: SupabaseClient<SupaDatabase>,
) => {
  const { data: supaConversations, error } = await supabase
    .from('conversations')
    .select('*')
    .order('timestamp', { ascending: true });
  if (error) {
    return [];
  } else {
    const conversations: Conversation[] = [];
    for (const supaConversation of supaConversations) {
      const messages = await supaGetMessages(supabase, supaConversation.id);

      let systemPrompt: SystemPrompt | null = null;
      if (supaConversation.system_prompt_id) {
        systemPrompt = await supaGetSystemPrompt(
          supabase,
          supaConversation.system_prompt_id,
        );
      }

      if (
        supaConversation.model_id === 'claude-instant-v1' ||
        supaConversation.model_id === 'claude-instant-v1-100k'
      ) {
        supaConversation.model_id = 'claude-instant-1';
      } else if (
        supaConversation.model_id === 'claude-v1' ||
        supaConversation.model_id === 'claude-v1-100k'
      ) {
        supaConversation.model_id = 'claude-2';
      }

      const conversation: Conversation = {
        id: supaConversation.id,
        name: supaConversation.name,
        model: PossibleAiModels[supaConversation.model_id],
        systemPrompt: systemPrompt,
        temperature: supaConversation.temperature,
        folderId: supaConversation.folder_id,
        messages: messages,
        timestamp: supaConversation.timestamp,
      };

      conversations.push(conversation);
    }
    return conversations;
  }
};

export const supaUpdateConversations = async (
  supabase: SupabaseClient<SupaDatabase>,
  updatedConversations: Conversation[],
) => {
  for (const conversation of updatedConversations) {
    const { error } = await supabase
      .from('conversations')
      .upsert({
        id: conversation.id,
        name: conversation.name,
        model_id: conversation.model.id,
        system_prompt_id: conversation.systemPrompt?.id || null,
        temperature: conversation.temperature,
        folder_id: conversation.folderId,
        timestamp: conversation.timestamp,
      })
      .eq('id', conversation.id);
    if (error) {
      console.error(error);
      return false;
    }
  }

  return true;
};

export const supaDeleteConversations = async (
  supabase: SupabaseClient<SupaDatabase>,
) => {
  const { error } = await supabase
    .from('conversations')
    .delete()
    .neq('id', '00000000-0000-0000-0000-000000000000');
  if (error) {
    console.error(error);
    return false;
  }
  return true;
};
------------------------
./utils/app/storage/supabase/helpers/folders.ts
import { SupaDatabase } from '../types/supabase';
import { FolderInterface } from '@/types/folder';

import { SupabaseClient } from '@supabase/supabase-js';

export const supaGetFolders = async (
  supabase: SupabaseClient<SupaDatabase>,
) => {
  const { data, error } = await supabase.from('folders').select('*');

  if (error) {
    return [];
  }

  const folders: FolderInterface[] = data.map((supaFolder) => {
    return {
      id: supaFolder.id,
      name: supaFolder.name,
      type: supaFolder.folder_type as FolderInterface['type'],
    };
  });
  return folders;
};

export const supaUpdateFolders = async (
  supabase: SupabaseClient<SupaDatabase>,
  folders: FolderInterface[],
) => {
  const updates = folders.map((folder) =>
    supabase
      .from('folders')
      .upsert({
        id: folder.id,
        name: folder.name,
        folder_type: folder.type,
      })
      .eq('id', folder.id),
  );

  const results = await Promise.all(updates);
  const hasErrors = results.some((result) => result.error);

  return !hasErrors;
};

export const supaDeleteFolders = async (
  supabase: SupabaseClient<SupaDatabase>,
  folderIds: string[],
) => {
  const deletes = folderIds.map((folderId) =>
    supabase.from('folders').delete().eq('id', folderId),
  );

  const results = await Promise.all(deletes);
  const hasErrors = results.some((result) => result.error);

  return !hasErrors;
};
------------------------
./utils/app/storage/supabase/helpers/prompt.ts
import { SupaDatabase } from '../types/supabase';
import { Prompt } from '@/types/prompt';

import { SupabaseClient } from '@supabase/supabase-js';

export const supaCreatePrompt = async (
  supabase: SupabaseClient<SupaDatabase>,
  newPrompt: Prompt,
) => {
  const supaPrompt: SupaDatabase['public']['Tables']['prompts']['Insert'] = {
    id: newPrompt.id,
    content: newPrompt.content,
    description: newPrompt.description,
    folder_id: newPrompt.folderId,
    models: newPrompt.models,
    name: newPrompt.name,
  };

  const { error } = await supabase.from('prompts').insert(supaPrompt);

  if (error) {
    console.error(error);
    return false;
  }
  return true;
};

export const supaUpdatePrompt = async (
  supabase: SupabaseClient<SupaDatabase>,
  updatedPrompt: Prompt,
) => {
  const { error } = await supabase
    .from('prompts')
    .update({
      content: updatedPrompt.content,
      description: updatedPrompt.description,
      folder_id: updatedPrompt.folderId,
      models: updatedPrompt.models,
      name: updatedPrompt.name,
    })
    .eq('id', updatedPrompt.id);

  if (error) {
    console.error(error);
    return false;
  }
  return true;
};

export const supaDeletePrompt = async (
  supabase: SupabaseClient<SupaDatabase>,
  promptId: string,
) => {
  const { error } = await supabase.from('prompts').delete().eq('id', promptId);

  if (error) {
    console.error(error);
    return false;
  }
  return true;
};
------------------------
./utils/app/storage/supabase/helpers/messages.ts
import { SupaDatabase } from '../types/supabase';
import { Message } from '@/types/chat';

import { SupabaseClient } from '@supabase/supabase-js';

export const supaGetMessages = async (
  supabase: SupabaseClient<SupaDatabase>,
  conversationId: string,
) => {
  const { data: supaMessages, error } = await supabase
    .from('messages')
    .select('*')
    .eq('conversation_id', conversationId)
    .order('timestamp', { ascending: true });

  if (error) {
    return [];
  }

  const messages = supaMessages.map((supaMessage) => {
    const message: Message = {
      id: supaMessage.id,
      content: supaMessage.content,
      role: supaMessage.role as Message['role'],
      timestamp: supaMessage.timestamp,
    };

    return message;
  });

  return messages;
};
export const supaCreateMessages = async (
  supabase: SupabaseClient<SupaDatabase>,
  conversationId: string,
  newMessages: Message[],
) => {
  const supaMessages: SupaDatabase['public']['Tables']['messages']['Insert'][] =
    newMessages.map((message) => ({
      id: message.id,
      content: message.content,
      role: message.role,
      conversation_id: conversationId,
      timestamp: message.timestamp,
    }));

  const { error } = await supabase.from('messages').insert(supaMessages);

  if (error) {
    console.error(error);
    return false;
  }
  return true;
};

export const supaUpdateMessages = async (
  supabase: SupabaseClient<SupaDatabase>,
  conversationId: string,
  updatedMessages: Message[],
) => {
  const updates = updatedMessages.map((message) =>
    supabase
      .from('messages')
      .upsert({
        content: message.content,
        role: message.role,
        conversation_id: conversationId,
        timestamp: message.timestamp,
      })
      .eq('id', message.id)
      .eq('conversation_id', conversationId),
  );

  const results = await Promise.all(updates);
  const hasErrors = results.some((result) => result.error);

  return !hasErrors;
};

export const supaDeleteMessages = async (
  supabase: SupabaseClient<SupaDatabase>,
  conversationId: string,
  messageIds: string[],
) => {
  const deletes = messageIds.map((messageId) =>
    supabase
      .from('messages')
      .delete()
      .eq('id', messageId)
      .eq('conversation_id', conversationId),
  );

  const results = await Promise.all(deletes);
  const hasErrors = results.some((result) => result.error);

  return !hasErrors;
};
------------------------
./utils/app/storage/supabase/helpers/systemPrompt.ts
import { SupaDatabase } from '../types/supabase';
import { SystemPrompt } from '@/types/system-prompt';

import { SupabaseClient } from '@supabase/supabase-js';

export const supaCreateSystemPrompt = async (
  supabase: SupabaseClient<SupaDatabase>,
  newPrompt: SystemPrompt,
) => {
  const supaPrompt: SupaDatabase['public']['Tables']['system_prompts']['Insert'] =
    {
      id: newPrompt.id,
      content: newPrompt.content,
      name: newPrompt.name,
      models: newPrompt.models,
    };

  const { error } = await supabase.from('system_prompts').insert(supaPrompt);

  if (error) {
    console.error(error);
    return false;
  }
  return true;
};

export const supaGetSystemPrompt = async (
  supabase: SupabaseClient<SupaDatabase>,
  promptId: string,
) => {
  const { data: supaSystemPrompts, error } = await supabase
    .from('system_prompts')
    .select('*')
    .eq('id', promptId);

  if (error) {
    console.error(error);
    return null;
  }

  if (supaSystemPrompts?.[0]) {
    const supaSystemPrompt = supaSystemPrompts[0];
    const systemPrompt: SystemPrompt = {
      id: supaSystemPrompt.id,
      name: supaSystemPrompt.name,
      models: supaSystemPrompt.models,
      content: supaSystemPrompt.content,
      folderId: supaSystemPrompt.folder_id,
    };

    return systemPrompt;
  }
  return null;
};

export const supaUpdateSystemPrompt = async (
  supabase: SupabaseClient<SupaDatabase>,
  updatedPrompt: SystemPrompt,
) => {
  const { error } = await supabase
    .from('system_prompts')
    .update({
      content: updatedPrompt.content,
      name: updatedPrompt.name,
      models: updatedPrompt.models,
    })
    .eq('id', updatedPrompt.id);

  if (error) {
    console.error(error);
    return false;
  }
  return true;
};

export const supaDeleteSystemPrompt = async (
  supabase: SupabaseClient<SupaDatabase>,
  promptId: string,
) => {
  const { error } = await supabase
    .from('system_prompts')
    .delete()
    .eq('id', promptId);

  if (error) {
    console.error(error);
    return false;
  }
  return true;
};
------------------------
./utils/app/storage/supabase/helpers/prompts.ts
import { SupaDatabase } from '../types/supabase';
import { Prompt } from '@/types/prompt';

import { SupabaseClient } from '@supabase/supabase-js';

export const supaGetPrompts = async (
  supabase: SupabaseClient<SupaDatabase>,
) => {
  const { data: supaPrompts, error } = await supabase
    .from('prompts')
    .select('*');

  if (error) {
    return [];
  }

  const prompts = supaPrompts.map((supaPrompt) => {
    const prompt: Prompt = {
      id: supaPrompt.id,
      content: supaPrompt.content,
      description: supaPrompt.description,
      folderId: supaPrompt.folder_id,
      models: supaPrompt.models,
      name: supaPrompt.name,
    };

    return prompt;
  });

  return prompts;
};

export const supaUpdatePrompts = async (
  supabase: SupabaseClient<SupaDatabase>,
  updatedPrompts: Prompt[],
) => {
  const updates = updatedPrompts.map((prompt) =>
    supabase
      .from('prompts')
      .upsert({
        id: prompt.id,
        content: prompt.content,
        description: prompt.description,
        folder_id: prompt.folderId,
        models: prompt.models,
        name: prompt.name,
      })
      .eq('id', prompt.id),
  );

  const results = await Promise.all(updates);
  const hasErrors = results.some((result) => result.error);

  return !hasErrors;
};

export const supaDeletePrompts = async (
  supabase: SupabaseClient<SupaDatabase>,
  promptIds: string[],
) => {
  const deletes = promptIds.map((promptId) =>
    supabase.from('prompts').delete().eq('id', promptId),
  );

  const results = await Promise.all(deletes);
  const hasErrors = results.some((result) => result.error);

  return !hasErrors;
};
------------------------
./utils/app/storage/supabase/helpers/message.ts
import { SupaDatabase } from '../types/supabase';
import { Message } from '@/types/chat';

import { SupabaseClient } from '@supabase/supabase-js';

export const supaCreateMessage = async (
  supabase: SupabaseClient<SupaDatabase>,
  conversationId: string,
  newMessage: Message,
) => {
  const supaMessage: SupaDatabase['public']['Tables']['messages']['Insert'] = {
    id: newMessage.id,
    content: newMessage.content,
    role: newMessage.role,
    conversation_id: conversationId,
    timestamp: newMessage.timestamp,
  };

  const { error } = await supabase.from('messages').insert(supaMessage);

  if (error) {
    console.error(error);
    return false;
  }
  return true;
};
export const supaUpdateMessage = async (
  supabase: SupabaseClient<SupaDatabase>,
  conversationId: string,
  updatedMessage: Message,
) => {
  const { error } = await supabase
    .from('messages')
    .update({
      content: updatedMessage.content,
      role: updatedMessage.role,
    })
    .eq('id', updatedMessage.id)
    .eq('conversation_id', conversationId);

  if (error) {
    console.error(error);
    return false;
  }
  return true;
};

export const supaDeleteMessage = async (
  supabase: SupabaseClient<SupaDatabase>,
  conversationId: string,
  messageId: string,
) => {
  const { error } = await supabase
    .from('messages')
    .delete()
    .eq('id', messageId)
    .eq('conversation_id', conversationId);

  if (error) {
    console.error(error);
    return false;
  }
  return true;
};
------------------------
./utils/app/storage/supabase/helpers/folder.ts
import { SupaDatabase } from '../types/supabase';
import { FolderInterface } from '@/types/folder';

import { SupabaseClient } from '@supabase/supabase-js';

export const supaCreateFolder = async (
  supabase: SupabaseClient<SupaDatabase>,
  newFolder: FolderInterface,
) => {
  const supaFolder: SupaDatabase['public']['Tables']['folders']['Insert'] = {
    id: newFolder.id,
    name: newFolder.name,
    folder_type: newFolder.type,
  };
  const { error } = await supabase.from('folders').insert([supaFolder]);

  if (error) {
    console.error(error);
    return false;
  }
  return true;
};

export const supaUpdateFolder = async (
  supabase: SupabaseClient<SupaDatabase>,
  folder: FolderInterface,
) => {
  const { error } = await supabase
    .from('folders')
    .update({
      name: folder.name,
      folder_type: folder.type,
    })
    .eq('id', folder.id);

  if (error) {
    console.error(error);
    return false;
  }
  return true;
};

export const supaDeleteFolder = async (
  supabase: SupabaseClient<SupaDatabase>,
  folderId: string,
) => {
  const { error } = await supabase.from('folders').delete().eq('id', folderId);

  if (error) {
    console.error(error);
    return false;
  }
  return true;
};
------------------------
./utils/app/storage/supabase/helpers/conversation.ts
import { SupaDatabase } from '../types/supabase';
import { Conversation, Message } from '@/types/chat';

import { SupabaseClient } from '@supabase/supabase-js';

export const supaCreateConversation = async (
  supabase: SupabaseClient<SupaDatabase>,
  newConversation: Conversation,
) => {
  const supaConversation: SupaDatabase['public']['Tables']['conversations']['Insert'] =
    {
      id: newConversation.id,
      name: newConversation.name,
      model_id: newConversation.model.id,
      system_prompt_id: newConversation.systemPrompt?.id,
      temperature: newConversation.temperature,
      folder_id: newConversation.folderId,
      timestamp: newConversation.timestamp,
    };

  const { error } = await supabase
    .from('conversations')
    .insert(supaConversation);

  if (error) {
    console.error(error);
    return false;
  }
  return true;
};

export const supaUpdateConversation = async (
  supabase: SupabaseClient<SupaDatabase>,
  updatedConversation: Conversation,
) => {
  const { error } = await supabase
    .from('conversations')
    .upsert({
      id: updatedConversation.id,
      name: updatedConversation.name,
      model_id: updatedConversation.model.id,
      system_prompt_id: updatedConversation.systemPrompt?.id,
      temperature: updatedConversation.temperature,
      folder_id: updatedConversation.folderId,
      timestamp: updatedConversation.timestamp,
    })
    .eq('id', updatedConversation.id);

  if (error) {
    console.error(error);
    return false;
  }
  return true;
};

export const supaDeleteConversation = async (
  supabase: SupabaseClient<SupaDatabase>,
  conversationId: string,
) => {
  const { error } = await supabase
    .from('conversations')
    .delete()
    .match({ id: conversationId });

  if (error) {
    console.error(error);
    return false;
  }
  return true;
};
------------------------
./utils/app/storage/supabase/helpers/systemPrompts.ts
import { SupaDatabase } from '../types/supabase';
import { SystemPrompt } from '@/types/system-prompt';

import { SupabaseClient } from '@supabase/supabase-js';

export const supaGetSystemPrompts = async (
  supabase: SupabaseClient<SupaDatabase>,
) => {
  const { data: supaSystemPrompts, error } = await supabase
    .from('system_prompts')
    .select('*');

  if (error) {
    return [];
  }

  const systemPrompts: SystemPrompt[] = supaSystemPrompts.map((p) => ({
    id: p.id,
    content: p.content,
    name: p.name,
    folderId: p.folder_id,
    models: p.models,
  }));

  return systemPrompts;
};

export const supaUpdateSystemPrompts = async (
  supabase: SupabaseClient<SupaDatabase>,
  updatedSystemPrompts: SystemPrompt[],
) => {
  const updates = updatedSystemPrompts.map((p) =>
    supabase
      .from('system_prompts')
      .update({
        content: p.content,
        name: p.name,
        folder_id: p.folderId,
        models: p.models,
      })
      .eq('id', p.id),
  );

  const results = await Promise.all(updates);
  const hasErrors = results.some((result) => result.error);

  return !hasErrors;
};

export const supaDeleteSystemPrompts = async (
  supabase: SupabaseClient<SupaDatabase>,
  promptIds: string[],
) => {
  const deletes = promptIds.map((id) =>
    supabase.from('system_prompts').delete().eq('id', id),
  );

  const results = await Promise.all(deletes);
  const hasErrors = results.some((result) => result.error);

  return !hasErrors;
};
------------------------
./utils/app/storage/local/apiKey.ts
import { User } from '@/types/auth';

export const localGetAPIKey = (user: User) => {
  const itemName = `apiKey-${user.email}`;
  return localStorage.getItem(itemName);
};

export const localSaveAPIKey = (user: User, apiKey: string) => {
  const itemName = `apiKey-${user.email}`;
  localStorage.setItem(itemName, apiKey);
};

export const localDeleteAPIKey = (user: User) => {
  const itemName = `apiKey-${user.email}`;
  localStorage.removeItem(itemName);
};
------------------------
./utils/app/storage/local/settings.ts
import { User } from '@/types/auth';
import { SavedSetting, SettingsSection } from '@/types/settings';

const STORAGE_KEY = 'saved_settings';

export const getSavedSettings = (user: User): SavedSetting[] => {
  const itemName = `${STORAGE_KEY}-${user.email}`;
  const savedSettingsRaw = localStorage.getItem(itemName);
  if (savedSettingsRaw) {
    try {
      return JSON.parse(savedSettingsRaw) as SavedSetting[];
    } catch (e) {
      return [];
    }
  }
  return [];
};

export const setSavedSettings = (user: User, savedSettings: SavedSetting[]) => {
  const itemName = `${STORAGE_KEY}-${user.email}`;
  localStorage.setItem(itemName, JSON.stringify(savedSettings));
};

export const deleteSettings = (user: User) => {
  const itemName = `${STORAGE_KEY}-${user.email}`;
  localStorage.removeItem(itemName);
};

export const getDefaultValue = (
  settings: SettingsSection[],
  sectionId: string,
  settingId: string,
) => {
  if (!settings) {
    return;
  }
  const section = settings.find((section) => section.id === sectionId);

  if (!section) {
    console.error(`Section ${sectionId} not found`);
    return;
  }

  const setting = section.settings.find((setting) => setting.id === settingId);

  if (!setting) {
    console.error(`Setting ${sectionId}.${settingId} not found`);
    return;
  }

  if (setting.type === 'choice') {
    if (setting.choices) {
      const defaultChoice = setting.choices.find((choice) => choice.default);
      return defaultChoice?.value;
    } else {
      console.error(`Setting ${sectionId}.${settingId} has no choices`);
    }
  } else {
    return setting.defaultValue;
  }
};

export const getSavedSettingValue = (
  savedSettings: SavedSetting[],
  sectionId: string,
  settingId: string,
  settings?: SettingsSection[],
) => {
  const savedSetting = savedSettings.find(
    (savedSetting) =>
      savedSetting.sectionId === sectionId &&
      savedSetting.settingId === settingId,
  );
  if (savedSetting) {
    return savedSetting.value;
  }
  // Return default value if available
  else if (settings) {
    return getDefaultValue(settings, sectionId, settingId);
  }

  return;
};

export const setSavedSetting = (
  user: User,
  sectionId: string,
  settingId: string,
  value: any,
) => {
  const savedSettings = getSavedSettings(user);

  const setting = savedSettings.find(
    (savedSetting) =>
      savedSetting.sectionId === sectionId &&
      savedSetting.settingId === settingId,
  );

  if (!setting) {
    savedSettings.push({
      sectionId: sectionId,
      settingId: settingId,
      value: value,
    });
  } else {
    setting.value = value;
  }
  setSavedSettings(user, savedSettings);
  return savedSettings;
};

// export const addSettingChoice = (
//   user: User,
//   section: string,
//   setting: string,
//   choice: SettingChoice,
// ) => {
//   const settings = getSavedSettings(user);

//   const choices = settings[section].settings[setting].choices;

//   let newChoices = [choice];
//   if (choices !== undefined) {
//     newChoices = [...choices, choice];
//   } else {
//     newChoices = [choice];
//   }

//   const newSettings: Settings = {
//     ...settings,
//     [section]: {
//       ...settings[section],
//       settings: {
//         ...settings[section].settings,
//         [setting]: {
//           ...settings[section].settings[setting],
//           choices: newChoices,
//         },
//       },
//     },
//   };

//   saveSettings(user, newSettings);

//   return newSettings;
// };

//   saveSettings(user, newSettings);

//   return newSettings;
// };
------------------------
./utils/app/storage/local/uiState.ts
import { User } from '@/types/auth';

export const localGetShowPromptBar = (user: User) => {
  const itemName = `showPromptbar-${user.email}`;
  return JSON.parse(localStorage.getItem(itemName) || '[]') as boolean;
};

export const localSaveShowPromptBar = (user: User, show: boolean) => {
  const itemName = `showPromptbar-${user.email}`;
  localStorage.setItem(itemName, JSON.stringify(show));
};

export const localGetShowPrimaryMenu = (user: User) => {
  const itemName = `showPrimaryMenu-${user.email}`;
  return JSON.parse(localStorage.getItem(itemName) || '[]') as boolean;
};

export const localSaveShowPrimaryMenu = (user: User, show: boolean) => {
  const itemName = `showPrimaryMenu-${user.email}`;
  localStorage.setItem(itemName, JSON.stringify(show));
};

export const localGetShowSecondaryMenu = (user: User) => {
  const itemName = `showSecondaryMenu-${user.email}`;
  return JSON.parse(localStorage.getItem(itemName) || '[]') as boolean;
};

export const localSaveShowSecondaryMenu = (user: User, show: boolean) => {
  const itemName = `showSecondaryMenu-${user.email}`;
  localStorage.setItem(itemName, JSON.stringify(show));
};
------------------------
./utils/app/storage/prompts.ts
import { User } from '@/types/auth';
import { Database } from '@/types/database';
import { Prompt } from '@/types/prompt';

export const storageGetPrompts = async (database: Database, user: User) => {
  return await database.getPrompts(user);
};

export const storageUpdatePrompts = async (
  database: Database,
  user: User,
  updatedPrompts: Prompt[],
) => {
  await database.updatePrompts(user, updatedPrompts).then((success) => {
    if (!success) {
      console.error('Failed to update prompts');
    }
  });
};
------------------------
./utils/app/storage/message.ts
import { User } from '@/types/auth';
import { Conversation, Message } from '@/types/chat';
import { Database } from '@/types/database';

export const storageCreateMessage = (
  database: Database,
  user: User,
  selectedConversation: Conversation,
  newMessage: Message,
  allConversations: Conversation[],
) => {
  const messages = selectedConversation.messages;
  const updatedMessages = [...messages, newMessage];
  const updatedConversation: Conversation = {
    ...selectedConversation,
    messages: updatedMessages,
  };
  const updatedConversations = allConversations.map((c) => {
    if (c.id === updatedConversation.id) {
      return updatedConversation;
    }

    return c;
  });

  database
    .createMessage(user, selectedConversation.id, newMessage)
    .then((success) => {
      if (!success) {
        console.error('Failed to create message');
      }
    });

  return { single: updatedConversation, all: updatedConversations };
};

export const storageUpdateMessage = (
  database: Database,
  user: User,
  selectedConversation: Conversation,
  updatedMessage: Message,
  allConversations: Conversation[],
) => {
  const messages = selectedConversation.messages;
  const updatedMessages = messages.map((m) =>
    m.id === updatedMessage.id ? updatedMessage : m,
  );
  const updatedConversation: Conversation = {
    ...selectedConversation,
    messages: updatedMessages,
  };
  const updatedConversations = allConversations.map((c) => {
    if (c.id === updatedConversation.id) {
      return updatedConversation;
    }

    return c;
  });

  database
    .updateMessage(user, selectedConversation.id, updatedMessage)
    .then((success) => {
      if (!success) {
        console.error('Failed to update message');
      }
    });

  return { single: updatedConversation, all: updatedConversations };
};

export const storageDeleteMessage = (
  database: Database,
  user: User,
  selectedConversation: Conversation,
  messageId: string,
) => {
  database
    .deleteMessage(user, selectedConversation.id, messageId)
    .then((success) => {
      if (!success) {
        console.error('Failed to delete message');
      }
    });
};
------------------------
./utils/app/storage/folder.ts
import { User } from '@/types/auth';
import { Database } from '@/types/database';
import { FolderInterface } from '@/types/folder';

import { v4 as uuidv4 } from 'uuid';

export const storageCreateFolder = (
  database: Database,
  user: User,
  name: string,
  folderType: FolderInterface['type'],
  allFolders: FolderInterface[],
) => {
  const newFolder: FolderInterface = {
    id: uuidv4(),
    name,
    type: folderType,
  };

  const updatedFolders = [...allFolders, newFolder];

  database.createFolder(user, newFolder).then((success) => {
    if (!success) {
      console.error('Failed to create folder');
    }
  });

  return updatedFolders;
};

export const storageUpdateFolder = (
  database: Database,
  user: User,
  folderId: string,
  name: string,
  allFolders: FolderInterface[],
) => {
  let updatedFolder: FolderInterface | null = null;
  const updatedFolders = allFolders.map((f) => {
    if (f.id === folderId) {
      updatedFolder = {
        ...f,
        name,
      };

      return updatedFolder;
    }

    return f;
  });

  database.updateFolder(user, updatedFolder!).then((success) => {
    if (!success) {
      console.error('Failed to update folder');
    }
  });

  return updatedFolders;
};

export const storageDeleteFolder = (
  database: Database,
  user: User,
  folderId: string,
  allFolders: FolderInterface[],
) => {
  const updatedFolders = allFolders.filter((f) => f.id !== folderId);

  database.deleteFolder(user, folderId).then((success) => {
    if (!success) {
      console.error('Failed to delete folder');
    }
  });

  return updatedFolders;
};
------------------------
./utils/app/storage/conversation.ts
import { User } from '@/types/auth';
import { Conversation } from '@/types/chat';
import { Database } from '@/types/database';

import { saveSelectedConversation } from './selectedConversation';

export const storageCreateConversation = (
  database: Database,
  user: User,
  newConversation: Conversation,
  allConversations: Conversation[],
) => {
  const updatedConversations = [...allConversations, newConversation];

  database.createConversation(user, newConversation).then((success) => {
    if (!success) {
      console.error('Failed to create conversation');
    }
  });

  return updatedConversations;
};

export const storageUpdateConversation = (
  database: Database,
  user: User,
  updatedConversation: Conversation,
  allConversations: Conversation[],
) => {
  const updatedConversations = allConversations.map((c) => {
    if (c.id === updatedConversation.id) {
      return updatedConversation;
    }

    return c;
  });

  saveSelectedConversation(user, updatedConversation);

  database.updateConversation(user, updatedConversation).then((success) => {
    if (!success) {
      console.error('Failed to update conversation');
    }
  });

  return {
    single: updatedConversation,
    all: updatedConversations,
  };
};

export const storageDeleteConversation = (
  database: Database,
  user: User,
  conversationId: string,
  allConversations: Conversation[],
) => {
  const updatedConversations = allConversations.filter(
    (c) => c.id !== conversationId,
  );

  database.deleteConversation(user, conversationId).then((success) => {
    if (!success) {
      console.error('Failed to delete conversation');
    }
  });

  return updatedConversations;
};
------------------------
./utils/app/storage/systemPrompts.ts
import { User } from '@/types/auth';
import { Database } from '@/types/database';
import { SystemPrompt } from '@/types/system-prompt';

export const storageGetSystemPrompts = async (
  database: Database,
  user: User,
) => {
  return await database.getSystemPrompts(user);
};

export const storageUpdateSystemPrompts = async (
  database: Database,
  user: User,
  updatedSystemPrompts: SystemPrompt[],
) => {
  database.updateSystemPrompts(user, updatedSystemPrompts).then((success) => {
    if (!success) {
      console.error('Failed to update system prompts');
    }
  });
};
------------------------
./utils/app/time/time.ts
import { format } from 'date-fns';

// Function to get timestamp with Timezone Offset
export function getTimestampWithTimezoneOffset(secondsOffset?: number): string {
  // Get current date
  const currentDate = new Date();

  // If secondsOffset is provided, add it to the current date
  if (secondsOffset) {
    currentDate.setSeconds(currentDate.getSeconds() + secondsOffset);
  }

  // Get timezone offset in minutes
  const timezoneOffset = currentDate.getTimezoneOffset();

  // Convert timezone offset from minutes to milliseconds
  const offsetInMilliseconds = timezoneOffset * 60 * 1000;

  // Subtract the offset in milliseconds to get the UTC date
  const utcDate = new Date(currentDate.getTime() - offsetInMilliseconds);

  // Format date to include timezone offset
  const timestampWithOffset = format(utcDate, "yyyy-MM-dd'T'HH:mm:ssXXX");

  return timestampWithOffset;
}
------------------------
./utils/app/extensions/database.ts
import { Database } from '@/types/database';

import { getClientSession } from '../auth/helpers';

import { ChatConfig } from '@/chat.config';

export const getDatabase = async () => {
  const database: Database = new ChatConfig.database();
  let customAccessToken: string | undefined = undefined;
  const session = await getClientSession();
  customAccessToken = session?.customAccessToken;
  await database.connect({ customAccessToken: customAccessToken });
  return database;
};
------------------------
./utils/app/retrieval/conversations.ts
import { Dispatch, useCallback, useEffect, useState } from 'react';

import { ActionType } from '@/hooks/useCreateReducer';

import { PossibleAiModels } from '@/types/ai-models';
import { User } from '@/types/auth';
import { Conversation } from '@/types/chat';
import { Database } from '@/types/database';

import { HomeInitialState } from '@/components/Home/home.state';

import { cleanConversationHistory, cleanSelectedConversation } from '../clean';
import { DEFAULT_MODEL, DEFAULT_TEMPERATURE } from '../const';
import { storageCreateConversation } from '../storage/conversation';
import { storageGetConversations } from '../storage/conversations';
import {
  getSelectedConversation,
  saveSelectedConversation,
} from '../storage/selectedConversation';
import { getTimestampWithTimezoneOffset } from '../time/time';

import { v4 as uuidv4 } from 'uuid';

export const useConversations = (
  homeDispatch: Dispatch<ActionType<HomeInitialState>>,
  database: Database | null,
  user: User | null,
  conversations: Conversation[],
) => {
  const [conversationsLoaded, setConversationsLoaded] = useState(false);

  const fetchModels = useCallback(async () => {
    if (!conversationsLoaded) {
      if (database && user) {
        storageGetConversations(database, user)
          .then((conversationHistory) => {
            if (conversationHistory) {
              const parsedConversationHistory: Conversation[] =
                conversationHistory;
              const cleanedConversations = cleanConversationHistory(
                parsedConversationHistory,
              );

              const selectedConversation = getSelectedConversation(user);

              if (selectedConversation) {
                const parsedSelectedConversation: Conversation =
                  JSON.parse(selectedConversation);
                const cleanedSelectedConversation = cleanSelectedConversation(
                  parsedSelectedConversation,
                );

                homeDispatch({
                  field: 'selectedConversation',
                  value: cleanedSelectedConversation,
                });
              } else if (cleanedConversations.length > 0) {
                homeDispatch({
                  field: 'selectedConversation',
                  value: cleanedConversations[0],
                });
              }

              homeDispatch({
                field: 'conversations',
                value: cleanedConversations,
              });
            }
          })
          .then(() => {
            setConversationsLoaded(true);
          });
      }
    }
  }, [conversationsLoaded, database, homeDispatch, user]);

  useEffect(() => {
    fetchModels();
  }, [fetchModels]);

  const autogenerateConversation = useCallback(async () => {
    if (!database || !user) return;

    const model = PossibleAiModels[DEFAULT_MODEL];
    // const sectionId = model.vendor.toLowerCase();
    // const settingId = `${model.id}_default_system_prompt`;
    // const systemPromptId = getSavedSettingValue(
    //   savedSettings,
    //   sectionId,
    //   settingId,
    //   settings,
    // );

    // const systemPrompt = systemPrompts.find((p) => p.id === systemPromptId);

    const newConversation: Conversation = {
      id: uuidv4(),
      name: 'New Conversation',
      messages: [],
      model: model,
      systemPrompt: null,
      temperature: DEFAULT_TEMPERATURE,
      folderId: null,
      timestamp: getTimestampWithTimezoneOffset(),
    };

    const updatedConversations = storageCreateConversation(
      database,
      user,
      newConversation,
      [],
    );
    homeDispatch({ field: 'selectedConversation', value: newConversation });
    homeDispatch({ field: 'conversations', value: updatedConversations });

    saveSelectedConversation(user, newConversation);
  }, [database, homeDispatch, user]);

  useEffect(() => {
    if (conversations.length === 0 && conversationsLoaded) {
      autogenerateConversation();
    }
  }, [conversations, autogenerateConversation, conversationsLoaded]);
};
------------------------
./utils/app/retrieval/database.ts
import { Dispatch, useCallback, useEffect, useState } from 'react';

import { ActionType } from '@/hooks/useCreateReducer';

import { Database } from '@/types/database';

import { HomeInitialState } from '@/components/Home/home.state';

import { getDatabase } from '../extensions/database';

export const useDatabase = (
  homeDispatch: Dispatch<ActionType<HomeInitialState>>,
  database: Database | null,
) => {
  const fetchDatabase = useCallback(async () => {
    if (!database) {
      const _db = await getDatabase();
      homeDispatch({ field: 'database', value: _db });
    }
  }, [database, homeDispatch]);

  useEffect(() => {
    fetchDatabase();
  }, [fetchDatabase]);

  return;
};
------------------------
./utils/app/retrieval/models.ts
import { Dispatch, useCallback, useEffect } from 'react';

import { ActionType } from '@/hooks/useCreateReducer';

import { AiModel } from '@/types/ai-models';
import { SavedSetting } from '@/types/settings';

import { HomeInitialState } from '@/components/Home/home.state';

import { getSavedSettingValue } from '../storage/local/settings';

export const useModels = (
  homeDispatch: Dispatch<ActionType<HomeInitialState>>,
  savedSettings: SavedSetting[],
  models: AiModel[],
) => {
  const fetchModels = useCallback(async () => {
    if (models.length === 0) {
      const openAiApiKey = getSavedSettingValue(
        savedSettings,
        'openai',
        'api_key',
      );

      const anthropicApiKey = getSavedSettingValue(
        savedSettings,
        'anthropic',
        'api_key',
      );

      const palmApiKey = getSavedSettingValue(
        savedSettings,
        'google',
        'api_key',
      );

      const results = await fetch(`/api/models`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          openai_key: openAiApiKey,
          anthropic_key: anthropicApiKey,
          palm_key: palmApiKey,
        }),
      });

      const models = await results.json();

      homeDispatch({ field: 'models', value: models });
    }
  }, [homeDispatch, models.length, savedSettings]);

  useEffect(() => {
    fetchModels();
  }, [fetchModels]);
};
------------------------
./utils/app/retrieval/auth.ts
import { Dispatch, useCallback, useEffect } from 'react';

import { ActionType } from '@/hooks/useCreateReducer';

import { User } from '@/types/auth';

import { HomeInitialState } from '@/components/Home/home.state';

import { getUser } from '../auth/helpers';
import { DEBUG_MODE } from '../const';
import { printEnvVariables } from '../debug/env-vars';

export const useAuth = (
  homeDispatch: Dispatch<ActionType<HomeInitialState>>,
  user: User | null,
) => {
  const fetchUser = useCallback(async () => {
    if (!user) {
      const _user = await getUser();
      homeDispatch({ field: 'user', value: _user });
    }
  }, [user, homeDispatch]);

  useEffect(() => {
    fetchUser();
  }, [fetchUser]);

  return;
};
------------------------
./utils/app/importExport.ts
import { User } from '@/types/auth';
import { Conversation } from '@/types/chat';
import { Database } from '@/types/database';
import {
  LatestExportFormat,
  SupportedExportFormats,
  poiesisPeteExportFormatV1,
} from '@/types/export';
import { FolderInterface } from '@/types/folder';
import { Prompt } from '@/types/prompt';

import {
  cleanConversationHistory,
  cleanFolders,
  cleanMessageTemplates,
} from './clean';
import {
  storageGetConversations,
  storageUpdateConversations,
} from './storage/conversations';
import { storageGetFolders, storageUpdateFolders } from './storage/folders';
import {
  storageCreateMessages,
  storageUpdateMessages,
} from './storage/messages';
import { storageGetPrompts, storageUpdatePrompts } from './storage/prompts';
import { saveSelectedConversation } from './storage/selectedConversation';
import { deleteSelectedConversation } from './storage/selectedConversation';

export function isExportFormatV1(obj: any): obj is poiesisPeteExportFormatV1 {
  return Array.isArray(obj);
}

export const isLatestExportFormat = isExportFormatV1;

export function cleanData(data: any): LatestExportFormat {
  if (isExportFormatV1(data)) {
    return data;
  }
  {
    // Attempt to convert to poiesisPete format
    return {
      app: 'poiesisPete',
      version: 1,
      conversations: cleanConversationHistory(data.history),
      folders: cleanFolders(data.folders),
      message_templates: cleanMessageTemplates(data.prompts),
      system_prompts: [],
    };
  }
}

function currentDate() {
  const date = new Date();
  const month = date.getMonth() + 1;
  const day = date.getDate();
  return `${month}-${day}`;
}

export const exportData = async (database: Database, user: User) => {
  // TODO: This function is not ready yet
  let history = await storageGetConversations(database, user);
  let folders = await storageGetFolders(database, user);
  let prompts = await storageGetPrompts(database, user);

  const data = {
    app: 'poiesisPete',
    version: 1,
    conversations: history || [],
    folders: folders || [],
    message_templates: prompts || [],
    system_prompts: [],
  } as LatestExportFormat;

  const blob = new Blob([JSON.stringify(data, null, 2)], {
    type: 'application/json',
  });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.download = `poiesisPete_history_${currentDate()}.json`;
  link.href = url;
  link.style.display = 'none';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
};

export const importData = async (
  database: Database,
  user: User,
  data: SupportedExportFormats,
): Promise<LatestExportFormat> => {
  const { conversations, folders, system_prompts, message_templates } =
    cleanData(data);

  console.log('cleaned data', {
    conversations,
    folders,
    system_prompts,
    message_templates,
  });

  // Updating folders
  const oldFolders = await storageGetFolders(database, user);
  const newFolders: FolderInterface[] = [...oldFolders, ...folders].filter(
    (folder, index, self) =>
      index === self.findIndex((f) => f.id === folder.id),
  );

  await storageUpdateFolders(database, user, newFolders);

  // Updating conversations
  const oldConversations = await storageGetConversations(database, user);
  const newConversations: Conversation[] = [
    ...oldConversations,
    ...conversations,
  ].filter(
    (conversation, index, self) =>
      index === self.findIndex((c) => c.id === conversation.id),
  );

  console.log('newHistory', newConversations);

  await storageUpdateConversations(database, user, newConversations);

  // Updating messages
  for (const conversation of conversations) {
    if (conversation.messages.length > 0) {
      storageUpdateMessages(
        database,
        user,
        conversation,
        conversation.messages,
        newConversations,
      );
    }
  }
  if (newConversations.length > 0) {
    saveSelectedConversation(
      user,
      newConversations[newConversations.length - 1],
    );
  } else {
    deleteSelectedConversation(user);
  }

  // Updating prompts
  const oldPrompts = await storageGetPrompts(database, user);
  const newMessageTemplates: Prompt[] = [
    ...oldPrompts,
    ...message_templates,
  ].filter(
    (prompt, index, self) =>
      index === self.findIndex((p) => p.id === prompt.id),
  );

  console.log('newPrompts', newMessageTemplates);

  storageUpdatePrompts(database, user, newMessageTemplates);

  return {
    app: 'poiesisPete',
    version: 1,
    conversations: newConversations,
    folders: newFolders,
    message_templates: newMessageTemplates,
    system_prompts: system_prompts,
  };
};
------------------------
./utils/app/clean.ts
import { PossibleAiModels } from '@/types/ai-models';
import { Conversation, Message } from '@/types/chat';
import { FolderInterface } from '@/types/folder';
import { Prompt } from '@/types/prompt';

import { DEFAULT_TEMPERATURE, OPENAI_API_TYPE } from './const';
import { getTimestampWithTimezoneOffset } from './time/time';

import { v4 as uuidv4 } from 'uuid';

export const cleanSelectedConversation = (conversation: Conversation) => {
  let updatedConversation = conversation;

  if (!updatedConversation.temperature) {
    updatedConversation = {
      ...updatedConversation,
      temperature: updatedConversation.temperature || DEFAULT_TEMPERATURE,
    };
  }

  if (!updatedConversation.folderId) {
    updatedConversation = {
      ...updatedConversation,
      folderId: updatedConversation.folderId || null,
    };
  }

  if (!updatedConversation.messages) {
    updatedConversation = {
      ...updatedConversation,
      messages: updatedConversation.messages || [],
    };
  }

  return updatedConversation;
};

export const cleanFolders = (importedFolders: any[]): FolderInterface[] => {
  if (!Array.isArray(importedFolders)) {
    console.warn('importedFolders is not an array. Returning an empty array.');
    return [];
  }

  const folders = [];
  for (const rawFolder of importedFolders) {
    try {
      const folder: FolderInterface = {
        id: rawFolder.id || uuidv4(),
        name: rawFolder.name || '',
        type: rawFolder.type || 'chat',
      };

      folders.push(folder);
    } catch (error) {
      console.warn(`error while cleaning prompts. Removing culprit`, error);
    }
  }

  return folders;
};

export const cleanMessageTemplates = (importedPrompts: any[]): Prompt[] => {
  if (!Array.isArray(importedPrompts)) {
    console.warn('importedPrompts is not an array. Returning an empty array.');
    return [];
  }

  const prompts = [];
  for (const rawPrompt of importedPrompts) {
    try {
      const prompt: Prompt = {
        id: rawPrompt.id || uuidv4(),
        name: rawPrompt.name || '',
        content: rawPrompt.content || '',
        description: rawPrompt.description || '',
        folderId: rawPrompt.folderId || null,
        models: rawPrompt.models || [],
      };

      prompts.push(prompt);
    } catch (error) {
      console.warn(`error while cleaning prompts. Removing culprit`, error);
    }
  }

  return prompts;
};

export const cleanConversationHistory = (history: any[]): Conversation[] => {
  if (!Array.isArray(history)) {
    console.warn('history is not an array. Returning an empty array.');
    return [];
  }

  const conversations = [];

  for (const raw_conversation of history) {
    try {
      if (!raw_conversation.model_id) {
        raw_conversation.model =
          OPENAI_API_TYPE === 'azure'
            ? PossibleAiModels['gpt-35-az']
            : PossibleAiModels['gpt-3.5-turbo'];
      }

      if (raw_conversation.messages) {
        const messages: Message[] = [];
        let secondsOffset = 0;
        for (const rawMessage of raw_conversation.messages) {
          try {
            const message: Message = {
              id: rawMessage.id || uuidv4(),
              content: rawMessage.content || '',
              timestamp:
                rawMessage.timestamp ||
                getTimestampWithTimezoneOffset(secondsOffset++),
              role: rawMessage.role,
            };
            messages.push(message);
          } catch (error) {
            console.warn(
              `error while cleaning messages' history. Removing culprit`,
              error,
            );
          }
        }
        raw_conversation.messages = messages;
      }

      const conversation: Conversation = {
        id: raw_conversation.id,
        name: raw_conversation.name,
        model: raw_conversation.model,
        systemPrompt: raw_conversation.systemPrompt || null,
        temperature: raw_conversation.temperature || DEFAULT_TEMPERATURE,
        folderId: raw_conversation.folderId || null,
        messages: raw_conversation.messages || [],
        timestamp:
          raw_conversation.timestamp || getTimestampWithTimezoneOffset(),
      };

      conversations.push(conversation);
    } catch (error) {
      console.warn(
        `error while cleaning conversations' history. Removing culprit`,
        error,
      );
    }
  }

  return conversations;
};
------------------------
./utils/app/handlers/RegenerateMessage.tsx
import { MutableRefObject } from 'react';

import { AiModel } from '@/types/ai-models';
import { User } from '@/types/auth';
import { Conversation } from '@/types/chat';
import { Database } from '@/types/database';
import { SavedSetting } from '@/types/settings';
import { SystemPrompt } from '@/types/system-prompt';

import { storageDeleteMessages } from '../storage/messages';
import { messageReceiver } from './helpers/messageReceiver';
import { messageSender } from './helpers/messageSender';

export const regenerateMessageHandler = async (
  user: User,
  stopConversationRef: MutableRefObject<boolean>,
  builtInSystemPrompts: SystemPrompt[],
  selectedConversation: Conversation | undefined,
  conversations: Conversation[],
  database: Database,
  savedSettings: SavedSetting[],
  homeDispatch: React.Dispatch<any>,
) => {
  if (selectedConversation) {
    homeDispatch({ field: 'loading', value: true });
    homeDispatch({ field: 'messageIsStreaming', value: true });

    const deleteCount = 1;

    const conversationLength = selectedConversation.messages.length;
    const messagesToBeDeleted: string[] = [];

    for (let i = 0; i < deleteCount; i++) {
      const currentMessage =
        selectedConversation.messages[conversationLength - 1 - i];
      messagesToBeDeleted.push(currentMessage.id);
    }

    let { single: updatedConversation, all: updatedConversations } =
      storageDeleteMessages(
        database,
        user,
        messagesToBeDeleted,
        selectedConversation,
        selectedConversation.messages,
        conversations,
      );

    homeDispatch({
      field: 'selectedConversation',
      value: updatedConversation,
    });

    const { data, controller } = await messageSender(
      builtInSystemPrompts,
      updatedConversation,
      selectedConversation,
      savedSettings,
      homeDispatch,
    );

    // Failed to send message
    if (!data || !controller) {
      return;
    }

    await messageReceiver(
      user,
      database,
      data,
      controller,
      updatedConversation,
      updatedConversations,
      stopConversationRef,
      homeDispatch,
    );
  }
};
------------------------
./utils/app/handlers/helpers/messageSender.ts
import toast from 'react-hot-toast';

import { Conversation } from '@/types/chat';
import { SavedSetting } from '@/types/settings';
import { SystemPrompt } from '@/types/system-prompt';

import { sendChatRequest } from '../../chat';

export async function messageSender(
  builtInSystemPrompts: SystemPrompt[],
  updatedConversation: Conversation,
  selectedConversation: Conversation,
  savedSettings: SavedSetting[],
  homeDispatch: React.Dispatch<any>,
) {
  let customPrompt = selectedConversation.systemPrompt;

  if (!selectedConversation.systemPrompt) {
    customPrompt = builtInSystemPrompts.filter(
      (prompt) =>
        prompt.name === `${selectedConversation.model.vendor} Built-In`,
    )[0];
  }

  const promptInjectedConversation = {
    ...updatedConversation,
    systemPrompt: customPrompt,
  };

  const { response, controller } = await sendChatRequest(
    promptInjectedConversation,
    savedSettings,
  );

  if (!response.ok) {
    homeDispatch({ field: 'loading', value: false });
    homeDispatch({ field: 'messageIsStreaming', value: false });
    toast.error(response.statusText);
    return { data: null, controller: null };
  }
  const data = response.body;
  if (!data) {
    homeDispatch({ field: 'loading', value: false });
    homeDispatch({ field: 'messageIsStreaming', value: false });
    return { data: null, controller: null };
  }

  homeDispatch({ field: 'loading', value: false });
  return { data, controller };
}
------------------------
./utils/app/handlers/helpers/messageReceiver.ts
import { MutableRefObject } from 'react';

import { User } from '@/types/auth';
import { Conversation, Message } from '@/types/chat';
import { Database } from '@/types/database';

import { storageCreateMessage } from '../../storage/message';
import { saveSelectedConversation } from '../../storage/selectedConversation';
import { getTimestampWithTimezoneOffset } from '../../time/time';

import { v4 as uuidv4 } from 'uuid';

export async function messageReceiver(
  user: User,
  database: Database,
  data: ReadableStream,
  controller: AbortController,
  conversation: Conversation,
  conversations: Conversation[],
  stopConversationRef: MutableRefObject<boolean>,
  homeDispatch: React.Dispatch<any>,
) {
  const reader = data.getReader();
  const decoder = new TextDecoder();
  let done = false;
  let text = '';

  const assistantMessageId = uuidv4();
  const responseMessage: Message = {
    id: assistantMessageId,
    role: 'assistant',
    content: '',
    timestamp: getTimestampWithTimezoneOffset(),
  };
  conversation.messages.push(responseMessage);
  const length = conversation.messages.length;
  while (!done) {
    if (stopConversationRef.current === true) {
      controller.abort();
      done = true;
      break;
    }
    const { value, done: doneReading } = await reader.read();
    done = doneReading;
    const chunkValue = decoder.decode(value);

    text += chunkValue;

    conversation.messages[length - 1].content = text;

    homeDispatch({
      field: 'selectedConversation',
      value: conversation,
    });
  }

  conversation.messages.pop();

  responseMessage.content = text;

  homeDispatch({ field: 'loading', value: false });
  homeDispatch({ field: 'messageIsStreaming', value: false });

  // Saving the response message
  const { single, all } = storageCreateMessage(
    database,
    user,
    conversation,
    responseMessage,
    conversations,
  );

  homeDispatch({
    field: 'selectedConversation',
    value: single,
  });

  homeDispatch({ field: 'conversations', value: all });
  saveSelectedConversation(user, single);
}
------------------------
./utils/app/handlers/SendMessage.tsx
import { MutableRefObject } from 'react';

import { storageCreateMessage } from '@/utils/app/storage/message';

import { User } from '@/types/auth';
import { Conversation, Message } from '@/types/chat';
import { Database } from '@/types/database';
import { SavedSetting } from '@/types/settings';

import { storageUpdateConversation } from '../storage/conversation';
import { messageReceiver } from './helpers/messageReceiver';
import { messageSender } from './helpers/messageSender';

export const sendHandlerFunction = async (
  user: User,
  message: Message,
  stopConversationRef: MutableRefObject<boolean>,
  builtInSystemPrompts: any[],
  selectedConversation: Conversation | undefined,
  conversations: Conversation[],
  database: Database,
  savedSettings: SavedSetting[],
  homeDispatch: React.Dispatch<any>,
) => {
  if (selectedConversation) {
    homeDispatch({ field: 'messageIsStreaming', value: true });
    homeDispatch({ field: 'loading', value: true });

    // Saving the user message
    let { single: updatedConversation, all: updatedConversations } =
      storageCreateMessage(
        database,
        user,
        selectedConversation,
        message,
        conversations,
      );

    homeDispatch({
      field: 'selectedConversation',
      value: updatedConversation,
    });

    // Updating the conversation name
    if (updatedConversation.messages.length === 1) {
      const { content } = message;
      const customName =
        content.length > 30 ? content.substring(0, 30) + '...' : content;
      updatedConversation = {
        ...updatedConversation,
        name: customName,
      };

      // Saving the conversation name
      storageUpdateConversation(
        database,
        user,
        { ...selectedConversation, name: updatedConversation.name },
        updatedConversations,
      );
    }

    {
      const { data, controller } = await messageSender(
        builtInSystemPrompts,
        updatedConversation,
        selectedConversation,
        savedSettings,
        homeDispatch,
      );

      // Failed to send message
      if (!data || !controller) {
        return;
      }

      await messageReceiver(
        user,
        database,
        data,
        controller,
        updatedConversation,
        updatedConversations,
        stopConversationRef,
        homeDispatch,
      );
    }
  }
};
------------------------
./utils/app/handlers/EditMessage.tsx
import { MutableRefObject } from 'react';

import { storageUpdateMessage } from '@/utils/app/storage/message';

import { AiModel } from '@/types/ai-models';
import { User } from '@/types/auth';
import { Conversation, Message } from '@/types/chat';
import { Database } from '@/types/database';
import { SavedSetting } from '@/types/settings';
import { SystemPrompt } from '@/types/system-prompt';

import { storageUpdateConversation } from '../storage/conversation';
import { storageDeleteMessages } from '../storage/messages';
import { messageReceiver } from './helpers/messageReceiver';
import { messageSender } from './helpers/messageSender';

export const editMessageHandler = async (
  user: User,
  message: Message,
  index: number,
  stopConversationRef: MutableRefObject<boolean>,
  builtInSystemPrompts: SystemPrompt[],
  selectedConversation: Conversation | undefined,
  conversations: Conversation[],
  database: Database,
  savedSettings: SavedSetting[],
  homeDispatch: React.Dispatch<any>,
) => {
  if (selectedConversation) {
    homeDispatch({ field: 'loading', value: true });
    homeDispatch({ field: 'messageIsStreaming', value: true });

    const deleteCount = selectedConversation?.messages.length - index - 1;
    let updatedConversation: Conversation;

    if (deleteCount) {
      const conversationLength = selectedConversation.messages.length;
      const messagesToBeDeleted: string[] = [];

      for (let i = 1; i <= deleteCount; i++) {
        const currentMessage =
          selectedConversation.messages[conversationLength - i];
        messagesToBeDeleted.push(currentMessage.id);
      }
      const deleteUpdate = storageDeleteMessages(
        database,
        user,
        messagesToBeDeleted,
        selectedConversation,
        selectedConversation.messages,
        conversations,
      );

      updatedConversation = deleteUpdate.single;
    } else {
      updatedConversation = selectedConversation;
    }

    // Update the user message
    const update1 = storageUpdateMessage(
      database,
      user,
      updatedConversation,
      message,
      conversations,
    );

    updatedConversation = update1.single;
    const updatedConversations = update1.all;

    homeDispatch({
      field: 'selectedConversation',
      value: update1.single,
    });

    // Updating the conversation name
    if (updatedConversation.messages.length === 1) {
      const { content } = message;
      const customName =
        content.length > 30 ? content.substring(0, 30) + '...' : content;
      updatedConversation = {
        ...updatedConversation,
        name: customName,
      };

      // Saving the conversation name
      storageUpdateConversation(
        database,
        user,
        { ...selectedConversation, name: updatedConversation.name },
        updatedConversations,
      );
    }

    const { data, controller } = await messageSender(
      builtInSystemPrompts,
      updatedConversation,
      selectedConversation,
      savedSettings,
      homeDispatch,
    );

    // Failed to send message
    if (!data || !controller) {
      return;
    }

    await messageReceiver(
      user,
      database,
      data,
      controller,
      updatedConversation,
      updatedConversations,
      stopConversationRef,
      homeDispatch,
    );
  }
};
------------------------
./utils/app/debug/env-vars.ts
import { dockerEnvVarFix } from '../docker/envFix';

export function printEnvVariables() {
  const DEFAULT_MODEL = dockerEnvVarFix(process.env.NEXT_PUBLIC_DEFAULT_MODEL);

  const DEFAULT_OPENAI_SYSTEM_PROMPT = dockerEnvVarFix(
    process.env.NEXT_PUBLIC_DEFAULT_OPENAI_SYSTEM_PROMPT,
  );

  const DEFAULT_ANTHROPIC_SYSTEM_PROMPT = dockerEnvVarFix(
    process.env.NEXT_PUBLIC_DEFAULT_ANTHROPIC_SYSTEM_PROMPT,
  );

  const DEFAULT_PALM_SYSTEM_PROMPT = dockerEnvVarFix(
    process.env.NEXT_PUBLIC_DEFAULT_PALM_SYSTEM_PROMPT,
  );

  const DEFAULT_TEMPERATURE = dockerEnvVarFix(
    process.env.NEXT_PUBLIC_DEFAULT_TEMPERATURE,
  );

  const OPENAI_API_URL = dockerEnvVarFix(process.env.OPENAI_API_URL);

  const OPENAI_API_KEY = dockerEnvVarFix(process.env.OPENAI_API_KEY);

  const OPENAI_API_TYPE = dockerEnvVarFix(process.env.OPENAI_API_TYPE);

  const OPENAI_API_VERSION = dockerEnvVarFix(process.env.OPENAI_API_VERSION);

  const OPENAI_ORGANIZATION = dockerEnvVarFix(process.env.OPENAI_ORGANIZATION);
  const ANTHROPIC_API_URL = dockerEnvVarFix(process.env.ANTHROPIC_API_URL);

  const ANTHROPIC_API_KEY = dockerEnvVarFix(process.env.ANTHROPIC_API_KEY);

  const ANTHROPIC_API_VERSION = dockerEnvVarFix(
    process.env.ANTHROPIC_API_VERSION,
  );

  const PALM_API_URL = dockerEnvVarFix(process.env.PALM_API_URL);

  const PALM_API_KEY = dockerEnvVarFix(process.env.PALM_API_KEY);

  const APP_DOMAIN = dockerEnvVarFix(process.env.NEXT_PUBLIC_APP_DOMAIN);

  const SUPABASE_URL = dockerEnvVarFix(process.env.NEXT_PUBLIC_SUPABASE_URL);

  const SUPABASE_SERVICE_ROLE_KEY = dockerEnvVarFix(
    process.env.SUPABASE_SERVICE_ROLE_KEY,
  );
  const SUPABASE_ANON_KEY = dockerEnvVarFix(
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
  );

  const SUPABASE_JWT_SECRET = dockerEnvVarFix(process.env.SUPABASE_JWT_SECRET);

  const DEBUG_MODE = dockerEnvVarFix(process.env.NEXT_PUBLIC_DEBUG_MODE);

  console.log('NEXT_PUBLIC_DEFAULT_MODEL', DEFAULT_MODEL);
  console.log(
    'NEXT_PUBLIC_DEFAULT_OPENAI_SYSTEM_PROMPT',
    DEFAULT_OPENAI_SYSTEM_PROMPT,
  );
  console.log(
    'NEXT_PUBLIC_DEFAULT_ANTHROPIC_SYSTEM_PROMPT',
    DEFAULT_ANTHROPIC_SYSTEM_PROMPT,
  );
  console.log(
    'NEXT_PUBLIC_DEFAULT_PALM_SYSTEM_PROMPT',
    DEFAULT_PALM_SYSTEM_PROMPT,
  );
  console.log('NEXT_PUBLIC_DEFAULT_TEMPERATURE', DEFAULT_TEMPERATURE);
  console.log('OPENAI_API_URL', OPENAI_API_URL);
  console.log('OPENAI_API_KEY', OPENAI_API_KEY);
  console.log('OPENAI_API_TYPE', OPENAI_API_TYPE);
  console.log('OPENAI_API_VERSION', OPENAI_API_VERSION);
  console.log('OPENAI_ORGANIZATION', OPENAI_ORGANIZATION);
  console.log('ANTHROPIC_API_URL', ANTHROPIC_API_URL);
  console.log('ANTHROPIC_API_KEY', ANTHROPIC_API_KEY);
  console.log('ANTHROPIC_API_VERSION', ANTHROPIC_API_VERSION);
  console.log('PALM_API_URL', PALM_API_URL);
  console.log('PALM_API_KEY', PALM_API_KEY);
  console.log('NEXT_PUBLIC_APP_DOMAIN', APP_DOMAIN);
  console.log('NEXT_PUBLIC_SUPABASE_URL', SUPABASE_URL);
  console.log('NEXT_PUBLIC_SUPABASE_ANON_KEY', SUPABASE_ANON_KEY);
  console.log('SUPABASE_SERVICE_ROLE_KEY', SUPABASE_SERVICE_ROLE_KEY);
  console.log('SUPABASE_JWT_SECRET', SUPABASE_JWT_SECRET);
}
------------------------
./utils/server/google.ts
export const cleanSourceText = (text: string) => {
  return text
    .trim()
    .replace(/(\n){4,}/g, '\n\n\n')
    .replace(/\n\n/g, ' ')
    .replace(/ {3,}/g, '  ')
    .replace(/\t/g, '')
    .replace(/\n+(\s*\n)*/g, '\n');
};
------------------------
./utils/server/ai_vendors/google/getModels.ts
import { PALM_API_KEY } from '@/utils/app/const';

import { AiModel, PossibleAiModels } from '@/types/ai-models';

export const config = {
  runtime: 'edge',
};

export async function getAvailablePalm2Models(key?: string) {
  if (!key) {
    key = PALM_API_KEY;

    if (!key) {
      return { data: [] };
    }
  }
  const models: AiModel[] = [PossibleAiModels['bard']];

  return { data: models };
}
------------------------
./utils/server/ai_vendors/google/getTokenCount.ts
import { AiModel } from '@/types/ai-models';
import { Message } from '@/types/chat';

// TODO: This is currently just an estimate. We need to actually count the tokens.
export async function countTokensGoogle(
  model: AiModel,
  systemPrompt: string,
  messages: Message[],
) {
  let tokenCount = systemPrompt.length / 4;

  for (let i = messages.length - 1; i >= 0; i--) {
    const text = `\n\n${messages[i].role}: ${messages[i].content}`;

    if (text.length > 0) {
      tokenCount += text.length / 4;
    }

    if (tokenCount > model.requestLimit) {
      return { error: 'Token limit exceeded' };
    }
  }

  // Convert to integer
  tokenCount = Math.ceil(tokenCount);

  return { count: tokenCount };
}
------------------------
./utils/server/ai_vendors/google/getStream.ts
import { PALM_API_KEY, PALM_API_URL } from '@/utils/app/const';

import { AiModel } from '@/types/ai-models';
import { Message } from '@/types/chat';

import {
  ParsedEvent,
  ReconnectInterval,
  createParser,
} from 'eventsource-parser';

export async function streamPaLM2(
  model: AiModel,
  systemPrompt: string,
  temperature: number,
  apiKey: string | undefined,
  messages: Message[],
  tokenCount: number,
) {
  if (!apiKey) {
    if (!PALM_API_KEY) {
      return { error: 'Missing API key' };
    } else {
      apiKey = PALM_API_KEY;
    }
  }

  let messagesToSend: any[] = [];

  for (let i = messages.length - 1; i >= 0; i--) {
    const message = {
      author: messages[i].role === 'user' ? 'user' : 'model',
      content: messages[i].content,
    };
    messagesToSend = [message, ...messagesToSend];
  }

  const url = `${PALM_API_URL}/models/chat-bison-001:generateMessage?key=${apiKey}`;

  const examples = [
    {
      input: { content: 'Hi' },
      output: {
        content: 'Hi, how can I help you today?',
      },
    },
    {
      input: { content: 'Tell me a joke' },
      output: {
        content:
          "Why don't scientists trust atoms? Because they make up everything!",
      },
    },
    {
      input: { content: 'What can you do?' },
      output: {
        content:
          'I can assist with a variety of tasks, including answering questions, providing information, and more.',
      },
    },
  ];

  const prompt = {
    context: systemPrompt,
    examples: examples,
    messages: [...messagesToSend],
  };

  const body = {
    prompt: prompt,
    temperature: temperature,
    candidate_count: 1,
    top_p: 0.95,
    top_k: 40,
  };

  const res = await fetch(url, {
    headers: {
      'Content-Type': 'application/json',
    },
    method: 'POST',
    body: JSON.stringify(body),
  });

  if (res.status !== 200) {
    let result = await res.text();
    console.error(result);
  }

  const result = await res.json();
  let text = '';

  if (!result.candidates && result.filters.length > 0) {
    text =
      'Bard refused to answer because of reason: ' + result.filters[0].reason;
  } else {
    text = result.candidates[0].content;
  }

  const stream = new ReadableStream({
    start(controller) {
      const encoder = new TextEncoder();
      const queue = encoder.encode(text);
      controller.enqueue(queue);
      controller.close();
    },
  });

  return { stream: stream };
}
------------------------
./utils/server/ai_vendors/getTokenCount.ts
import { AiModel } from '@/types/ai-models';
import { Message } from '@/types/chat';

import { countTokensAnthropic } from './anthropic/getTokenCount';
import { countTokensGoogle } from './google/getTokenCount';
import { countTokensOpenAI } from './openai/getTokenCount';

export async function getTokenCount(
  model: AiModel,
  systemPrompt: string,
  messages: Message[],
) {
  if (model.vendor === 'OpenAI') {
    return countTokensOpenAI(model, systemPrompt, messages);
  } else if (model.vendor === 'Anthropic') {
    return countTokensAnthropic(model, systemPrompt, messages);
  } else if (model.vendor === 'Google') {
    return countTokensGoogle(model, systemPrompt, messages);
  }
  return { error: 'Unknown vendor' };
}
------------------------
./utils/server/ai_vendors/anthropic/getModels.ts
import { ANTHROPIC_API_KEY } from '@/utils/app/const';

import { AiModel, PossibleAiModels } from '@/types/ai-models';

export const config = {
  runtime: 'edge',
};

export async function getAvailableAnthropicModels(key?: string) {
  if (!key) {
    key = ANTHROPIC_API_KEY;

    if (!key) {
      return { data: [] };
    }
  }
  const models: AiModel[] = [
    PossibleAiModels['claude-instant-1'],
    PossibleAiModels['claude-2'],
  ];

  return { data: models };
}
------------------------
./utils/server/ai_vendors/anthropic/getTokenCount.ts
import { AiModel } from '@/types/ai-models';
import { Message } from '@/types/chat';

// TODO: This is currently just an estimate. We need to actually count the tokens.
export async function countTokensAnthropic(
  model: AiModel,
  systemPrompt: string,
  messages: Message[],
) {
  let tokenCount = systemPrompt.length / 4;

  for (let i = messages.length - 1; i >= 0; i--) {
    const text = `\n\n${messages[i].role}: ${messages[i].content}`;

    if (text.length > 0) {
      tokenCount += text.length / 4;
    }

    if (tokenCount > model.requestLimit) {
      return { error: 'Token limit exceeded' };
    }
  }

  // Convert to integer
  tokenCount = Math.ceil(tokenCount);

  return { count: tokenCount };
}
------------------------
./utils/server/ai_vendors/anthropic/getStream.ts
import {
  ANTHROPIC_API_KEY,
  ANTHROPIC_API_URL,
  ANTHROPIC_API_VERSION,
} from '@/utils/app/const';

import { AiModel } from '@/types/ai-models';
import { Message } from '@/types/chat';

import {
  ParsedEvent,
  ReconnectInterval,
  createParser,
} from 'eventsource-parser';

export async function streamAnthropic(
  model: AiModel,
  systemPrompt: string,
  temperature: number,
  apiKey: string | undefined,
  messages: Message[],
  tokenCount: number,
) {
  if (!apiKey) {
    if (!ANTHROPIC_API_KEY) {
      return { error: 'Missing API key' };
    } else {
      apiKey = ANTHROPIC_API_KEY;
    }
  }

  let prompt = systemPrompt;

  let parsedMessages = '';
  for (let i = messages.length - 1; i >= 0; i--) {
    const parsedMessage = `\n\n${
      messages[i].role === 'user' ? 'Human' : 'Assistant'
    }: ${messages[i].content}`;
    parsedMessages = parsedMessage + parsedMessages;
  }

  prompt += parsedMessages;

  prompt += '\n\nAssistant:';

  let url = `${ANTHROPIC_API_URL}/complete`;

  const res = await fetch(url, {
    headers: {
      'Content-Type': 'application/json',
      'anthropic-version': ANTHROPIC_API_VERSION,
      'x-api-key': apiKey,
    },
    method: 'POST',
    body: JSON.stringify({
      prompt: prompt,
      model: model.id,
      max_tokens_to_sample: model.tokenLimit - tokenCount,
      stop_sequences: ['\n\nUser:'],
      temperature: temperature,
      stream: true,
    }),
  });

  const encoder = new TextEncoder();
  const decoder = new TextDecoder();

  if (res.status !== 200) {
    const result = await res.json();
    if (result.error) {
      return { error: result.error };
    } else {
      throw new Error(
        `Anthropic API returned an error: ${
          decoder.decode(result?.value) || result.statusText
        }`,
      );
    }
  }

  const stream = new ReadableStream({
    async start(controller) {
      const onParse = (event: ParsedEvent | ReconnectInterval) => {
        if (event.type === 'event') {
          const raw_data = event.data;

          try {
            const data = JSON.parse(raw_data);
            if (data.stop_reason != null) {
              controller.close();
              return;
            }
            const text = data.completion;
            const queue = encoder.encode(text);
            controller.enqueue(queue);
          } catch (e) {
            controller.error(e);
          }
        }
      };

      const parser = createParser(onParse);

      for await (const chunk of res.body as any) {
        parser.feed(decoder.decode(chunk));
      }
    },
  });

  return { stream: stream };
}
------------------------
./utils/server/ai_vendors/getStream.ts
import { AiModel } from '@/types/ai-models';
import { Message } from '@/types/chat';

import { streamAnthropic } from './anthropic/getStream';
import { streamPaLM2 } from './google/getStream';
import { streamOpenAI } from './openai/getStream';

export async function getStream(
  model: AiModel,
  systemPrompt: string,
  temperature: number,
  apiKey: string | undefined,
  messages: Message[],
  tokenCount: number,
) {
  if (model.vendor === 'OpenAI') {
    return streamOpenAI(
      model,
      systemPrompt,
      temperature,
      apiKey,
      messages,
      tokenCount,
    );
  } else if (model.vendor === 'Anthropic') {
    return streamAnthropic(
      model,
      systemPrompt,
      temperature,
      apiKey,
      messages,
      tokenCount,
    );
  } else if (model.vendor === 'Google') {
    return streamPaLM2(
      model,
      systemPrompt,
      temperature,
      apiKey,
      messages,
      tokenCount,
    );
  }
  return { error: 'Unknown vendor' };
}
------------------------
./utils/server/ai_vendors/openai/getModels.ts
import {
  OPENAI_API_KEY,
  OPENAI_API_TYPE,
  OPENAI_API_URL,
  OPENAI_API_VERSION,
  OPENAI_ORGANIZATION,
} from '@/utils/app/const';

import { AiModel, PossibleAiModels } from '@/types/ai-models';

export const config = {
  runtime: 'edge',
};

export async function getAvailableOpenAIModels(key?: string) {
  let url = `${OPENAI_API_URL}/models`;
  if (OPENAI_API_TYPE === 'azure') {
    url = `${OPENAI_API_URL}/openai/deployments?api-version=${OPENAI_API_VERSION}`;
  }
  const response = await fetch(url, {
    headers: {
      'Content-Type': 'application/json',
      ...(OPENAI_API_TYPE === 'openai' && {
        Authorization: `Bearer ${key ? key : OPENAI_API_KEY}`,
      }),
      ...(OPENAI_API_TYPE === 'azure' && {
        'api-key': `${key ? key : OPENAI_API_KEY}`,
      }),
      ...(OPENAI_API_TYPE === 'openai' &&
        OPENAI_ORGANIZATION && {
          'OpenAI-Organization': OPENAI_ORGANIZATION,
        }),
    },
  });

  if (response.status !== 200) {
    return { error: response.status, data: response.body };
  }

  const json = await response.json();

  const models: AiModel[] = json.data
    .map((openaiModel: any) => {
      const model_name =
        OPENAI_API_TYPE === 'azure' ? openaiModel.model : openaiModel.id;

      return PossibleAiModels[model_name];
    })
    .filter(Boolean);

  return { data: models };
}
------------------------
./utils/server/ai_vendors/openai/getTokenCount.ts
import { AiModel } from '@/types/ai-models';
import { Message } from '@/types/chat';

// // @ts-expect-error
// import wasm from '../../../../node_modules/@dqbd/tiktoken/lite/tiktoken_bg.wasm?module';

// import tiktokenModel from '@dqbd/tiktoken/encoders/cl100k_base.json';
// import { Tiktoken, init } from '@dqbd/tiktoken/lite/init';

// TODO: Fix tokenizer. Not working with app dir.
export async function countTokensOpenAI(
  model: AiModel,
  systemPrompt: string,
  messages: Message[],
) {
  // await init((imports) => WebAssembly.instantiate(wasm, imports));
  // const encoding = new Tiktoken(
  //   tiktokenModel.bpe_ranks,
  //   tiktokenModel.special_tokens,
  //   tiktokenModel.pat_str,
  // );

  // const prompt_tokens = encoding.encode(systemPrompt);

  // let tokens_per_message = 0;
  // if (model.id === 'gpt-3.5-turbo' || model.id === 'gpt-35-az') {
  //   tokens_per_message = 5;
  // } else if (model.id === 'gpt-4' || model.id === 'gpt-4-32k') {
  //   tokens_per_message = 4;
  // }

  // let tokenCount = prompt_tokens.length + tokens_per_message;

  // for (let i = messages.length - 1; i >= 0; i--) {
  //   const message = {
  //     role: messages[i].role,
  //     content: messages[i].content,
  //   };

  //   const tokens = encoding.encode(message.content);

  //   if (tokens) {
  //     tokenCount += tokens.length + tokens_per_message;
  //   }
  //   if (tokenCount > model.requestLimit) {
  //     encoding.free();
  //     return { error: 'Token limit exceeded' };
  //   }
  // }

  // // every reply is primed with <|start|>assistant<|message|>
  // tokenCount += 3;

  // encoding.free();

  let tokenCount = systemPrompt.length / 4;

  for (let i = messages.length - 1; i >= 0; i--) {
    const text = `\n\n${messages[i].role}: ${messages[i].content}`;

    if (text.length > 0) {
      tokenCount += text.length / 4;
    }

    if (tokenCount > model.requestLimit) {
      return { error: 'Token limit exceeded' };
    }
  }

  // Convert to integer
  tokenCount = Math.ceil(tokenCount);

  return { count: tokenCount };
}
------------------------
./utils/server/ai_vendors/openai/getStream.ts
import {
  OPENAI_API_KEY,
  OPENAI_API_TYPE,
  OPENAI_API_URL,
  OPENAI_API_VERSION,
  OPENAI_ORGANIZATION,
} from '@/utils/app/const';

import { AiModel } from '@/types/ai-models';
import { Message } from '@/types/chat';

import {
  ParsedEvent,
  ReconnectInterval,
  createParser,
} from 'eventsource-parser';

export async function streamOpenAI(
  model: AiModel,
  systemPrompt: string,
  temperature: number,
  apiKey: string | undefined,
  messages: Message[],
  tokenCount: number,
) {
  if (!apiKey) {
    if (!OPENAI_API_KEY) {
      return { error: 'Missing API key' };
    } else {
      apiKey = OPENAI_API_KEY;
    }
  }

  let messagesToSend: any[] = [];

  for (let i = messages.length - 1; i >= 0; i--) {
    const message = {
      role: messages[i].role,
      content: messages[i].content,
    };
    messagesToSend = [message, ...messagesToSend];
  }

  let url = `${OPENAI_API_URL}/chat/completions`;
  if (OPENAI_API_TYPE === 'azure') {
    url = `${OPENAI_API_URL}/openai/deployments/${model.id}/chat/completions?api-version=${OPENAI_API_VERSION}`;
  }
  const res = await fetch(url, {
    headers: {
      'Content-Type': 'application/json',
      ...(OPENAI_API_TYPE === 'openai' && {
        Authorization: `Bearer ${apiKey}`,
      }),
      ...(OPENAI_API_TYPE === 'azure' && {
        'api-key': apiKey,
      }),
      ...(OPENAI_API_TYPE === 'openai' &&
        OPENAI_ORGANIZATION && {
          'OpenAI-Organization': OPENAI_ORGANIZATION,
        }),
    },
    method: 'POST',
    body: JSON.stringify({
      ...(OPENAI_API_TYPE === 'openai' && { model: model.id }),
      messages: [
        {
          role: 'system',
          content: systemPrompt,
        },
        ...messagesToSend,
      ],
      max_tokens: model.tokenLimit - tokenCount,
      temperature: temperature,
      stream: true,
    }),
  });

  const encoder = new TextEncoder();
  const decoder = new TextDecoder();

  if (res.status !== 200) {
    const result = await res.json();
    if (result.error) {
      return { error: result.error };
    } else {
      throw new Error(
        `OpenAI API returned an error: ${
          decoder.decode(result?.value) || result.statusText
        }`,
      );
    }
  }

  const stream = new ReadableStream({
    async start(controller) {
      const onParse = (event: ParsedEvent | ReconnectInterval) => {
        if (event.type === 'event') {
          const data = event.data;
          if (data === '[DONE]') {
            controller.close();
            return;
          }

          try {
            const json = JSON.parse(data);
            if (json.choices[0].finish_reason != null) {
              controller.close();
              return;
            }
            const text = json.choices[0].delta.content;
            const queue = encoder.encode(text);
            controller.enqueue(queue);
          } catch (e) {
            controller.error(e);
          }
        }
      };

      const parser = createParser(onParse);

      for await (const chunk of res.body as any) {
        parser.feed(decoder.decode(chunk));
      }
    },
  });

  return { stream: stream };
}
------------------------
./utils/data/throttle.ts
export function throttle<T extends (...args: any[]) => any>(
  func: T,
  limit: number,
): T {
  let lastFunc: ReturnType<typeof setTimeout>;
  let lastRan: number;

  return ((...args) => {
    if (!lastRan) {
      func(...args);
      lastRan = Date.now();
    } else {
      clearTimeout(lastFunc);
      lastFunc = setTimeout(() => {
        if (Date.now() - lastRan >= limit) {
          func(...args);
          lastRan = Date.now();
        }
      }, limit - (Date.now() - lastRan));
    }
  }) as T;
}
------------------------
./chat.config.ts
import { ClientDatabase } from './utils/app/storage/supabase';

export const ChatConfig = {
  database: ClientDatabase,
};
------------------------
./next-env.d.ts
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.
------------------------
./components/Home/index.tsx
export { default } from './home';
------------------------
./components/Home/home.tsx
import { useCallback, useEffect, useState } from 'react';

import Head from 'next/head';
import Image from 'next/image';

import { useCreateReducer } from '@/hooks/useCreateReducer';

import {
  cleanConversationHistory,
  cleanSelectedConversation,
} from '@/utils/app/clean';
import {
  DEBUG_MODE,
  DEFAULT_ANTHROPIC_SYSTEM_PROMPT,
  DEFAULT_MODEL,
  DEFAULT_OPENAI_SYSTEM_PROMPT,
  DEFAULT_PALM_SYSTEM_PROMPT,
  DEFAULT_TEMPERATURE,
} from '@/utils/app/const';
import { printEnvVariables } from '@/utils/app/debug/env-vars';
import { useAuth } from '@/utils/app/retrieval/auth';
import { useConversations } from '@/utils/app/retrieval/conversations';
import { useDatabase } from '@/utils/app/retrieval/database';
import { useModels } from '@/utils/app/retrieval/models';
import { getSettings } from '@/utils/app/settings/getSettings';
import { setSettingChoices } from '@/utils/app/settings/settingChoices';
import {
  storageCreateConversation,
  storageUpdateConversation,
} from '@/utils/app/storage/conversation';
import {
  storageGetConversations,
  storageUpdateConversations,
} from '@/utils/app/storage/conversations';
import {
  storageCreateFolder,
  storageDeleteFolder,
  storageUpdateFolder,
} from '@/utils/app/storage/folder';
import { storageGetFolders } from '@/utils/app/storage/folders';
import {
  getSavedSettingValue,
  getSavedSettings,
  setSavedSettings,
} from '@/utils/app/storage/local/settings';
import {
  localGetShowPrimaryMenu,
  localGetShowSecondaryMenu,
} from '@/utils/app/storage/local/uiState';
import {
  storageDeleteMessages,
  storageUpdateMessages,
} from '@/utils/app/storage/messages';
import {
  storageGetPrompts,
  storageUpdatePrompts,
} from '@/utils/app/storage/prompts';
import {
  getSelectedConversation,
  saveSelectedConversation,
} from '@/utils/app/storage/selectedConversation';
import { storageGetSystemPrompts } from '@/utils/app/storage/systemPrompts';
import { getTimestampWithTimezoneOffset } from '@/utils/app/time/time';

import { AiModel, PossibleAiModels } from '@/types/ai-models';
import { Conversation, Message } from '@/types/chat';
import { KeyValuePair } from '@/types/data';
import { FolderInterface } from '@/types/folder';
import { Prompt } from '@/types/prompt';
import { SettingChoice } from '@/types/settings';
import { SystemPrompt } from '@/types/system-prompt';

import { ChatZone } from './components/ChatZone/ChatZone';
import { Navbar } from './components/Mobile/Navbar';
import { PrimaryMenu } from '@/components/Home/components/PrimaryMenu/PrimaryMenu';
import { SecondaryMenu } from '@/components/Home/components/SecondaryMenu/SecondaryMenu';

import HomeContext from './home.context';
import { HomeInitialState, initialState } from './home.state';

import { v4 as uuidv4 } from 'uuid';

const Home = () => {
  const [debugLogPrinted, setDebugLogPrinted] = useState(false);

  const contextValue = useCreateReducer<HomeInitialState>({
    initialState,
  });

  const {
    state: {
      database,
      display,
      lightMode,
      folders,
      conversations,
      selectedConversation,
      prompts,
      systemPrompts,
      user,
      savedSettings,
      settings,
      models,
      builtInSystemPrompts,
      settingsLoaded,
    },
    dispatch,
  } = contextValue;

  useEffect(() => {
    if (DEBUG_MODE) {
      if (!debugLogPrinted) {
        console.log('----------CLIENT-SIDE ENVIRONMENT VARIABLES----------');
        printEnvVariables();
        setDebugLogPrinted(true);
      }
    }
  }, [debugLogPrinted]);

  // AUTH ---------------------------------------------------------
  useAuth(dispatch, user);

  // DATABASE ---------------------------------------------------------
  useDatabase(dispatch, database);

  // MODELS ----------------------------------------------
  useModels(dispatch, savedSettings, models);

  // CONVERSATIONS ---------------------------------------------------------
  useConversations(dispatch, database, user, conversations);

  const handleSelectConversation = (conversation: Conversation) => {
    if (!database || !user) return;
    dispatch({
      field: 'selectedConversation',
      value: conversation,
    });

    dispatch({
      field: 'display',
      value: 'chat',
    });

    saveSelectedConversation(user, conversation);
  };

  // FOLDER OPERATIONS  --------------------------------------------

  const handleCreateFolder = async (
    name: string,
    type: FolderInterface['type'],
  ) => {
    if (!database || !user) return;

    const updatedFolders = storageCreateFolder(
      database,
      user,
      name,
      type,
      folders,
    );

    dispatch({ field: 'folders', value: updatedFolders });
  };

  const handleDeleteFolder = async (folderId: string) => {
    if (!database || !user) return;

    const updatedFolders = folders.filter((f) => f.id !== folderId);
    dispatch({ field: 'folders', value: updatedFolders });

    const updatedConversations: Conversation[] = conversations.map((c) => {
      if (c.folderId === folderId) {
        return {
          ...c,
          folderId: null,
        };
      }

      return c;
    });

    dispatch({ field: 'conversations', value: updatedConversations });

    const updatedPrompts: Prompt[] = prompts.map((p) => {
      if (p.folderId === folderId) {
        return {
          ...p,
          folderId: null,
        };
      }

      return p;
    });

    dispatch({ field: 'prompts', value: updatedPrompts });

    await storageUpdateConversations(database, user, updatedConversations);
    await storageUpdatePrompts(database, user, updatedPrompts);
    storageDeleteFolder(database, user, folderId, folders);
  };

  const handleUpdateFolder = async (folderId: string, name: string) => {
    if (!database || !user) return;
    const updatedFolders = storageUpdateFolder(
      database,
      user,
      folderId,
      name,
      folders,
    );

    dispatch({ field: 'folders', value: updatedFolders });
  };

  // CONVERSATION OPERATIONS  --------------------------------------------

  const autoUpdateConversations = useCallback(
    async (oldConversations: Conversation[]) => {
      if (!database || !user) return;
      for (const conversation of oldConversations) {
        if (conversation.systemPrompt) {
          const systemPrompt = systemPrompts.find(
            (p) => p.id === conversation.systemPrompt?.id,
          );

          if (systemPrompt) {
            conversation.systemPrompt = systemPrompt;
          } else {
            conversation.systemPrompt = null;
          }
        }
      }

      storageUpdateConversations(database, user, oldConversations);

      dispatch({ field: 'conversations', value: oldConversations });
    },
    [database, user, systemPrompts, dispatch],
  );

  useEffect(() => {
    if (conversations.length > 0) {
      autoUpdateConversations(conversations);
    }
  }, [autoUpdateConversations, conversations, systemPrompts]);

  const handleNewConversation = async () => {
    if (!database || !user) return;
    if (savedSettings && settings) {
      const lastConversation = conversations[conversations.length - 1];

      const model = lastConversation?.model || PossibleAiModels[DEFAULT_MODEL];
      // const sectionId = model.vendor.toLowerCase();
      // const settingId = `${model.id}_default_system_prompt`;
      // const systemPromptId = getSavedSettingValue(
      //   savedSettings,
      //   sectionId,
      //   settingId,
      //   settings,
      // );

      // const systemPrompt = systemPrompts.find((p) => p.id === systemPromptId);

      const newConversation: Conversation = {
        id: uuidv4(),
        name: 'New Conversation',
        messages: [],
        model: model,
        systemPrompt: null,
        temperature: DEFAULT_TEMPERATURE,
        folderId: null,
        timestamp: getTimestampWithTimezoneOffset(),
      };

      const updatedConversations = storageCreateConversation(
        database,
        user,
        newConversation,
        conversations,
      );
      dispatch({ field: 'selectedConversation', value: newConversation });
      dispatch({ field: 'conversations', value: updatedConversations });

      saveSelectedConversation(user, newConversation);

      dispatch({ field: 'loading', value: false });
    }
  };

  const generateBuiltInSystemPrompts = useCallback(() => {
    const vendors: AiModel['vendor'][] = ['Anthropic', 'OpenAI', 'Google'];

    const newSystemPrompts: SystemPrompt[] = [];
    for (const vendor of vendors) {
      let systemPrompt: SystemPrompt;
      const systemPromptId = uuidv4();
      if (vendor === 'Anthropic') {
        systemPrompt = {
          id: systemPromptId,
          name: `${vendor} Built-In`,
          content: DEFAULT_ANTHROPIC_SYSTEM_PROMPT,
          folderId: null,
          models: models
            .filter((m) => m.vendor === 'Anthropic')
            .map((m) => m.id),
        };
        newSystemPrompts.push(systemPrompt);
      } else if (vendor === 'OpenAI') {
        systemPrompt = {
          id: systemPromptId,
          name: `${vendor} Built-In`,
          content: DEFAULT_OPENAI_SYSTEM_PROMPT,
          folderId: null,
          models: models.filter((m) => m.vendor === 'OpenAI').map((m) => m.id),
        };
        newSystemPrompts.push(systemPrompt);
      } else if (vendor === 'Google') {
        systemPrompt = {
          id: systemPromptId,
          name: `${vendor} Built-In`,
          content: DEFAULT_PALM_SYSTEM_PROMPT,
          folderId: null,
          models: models.filter((m) => m.vendor === 'Google').map((m) => m.id),
        };

        newSystemPrompts.push(systemPrompt);
      }
    }

    dispatch({ field: 'builtInSystemPrompts', value: newSystemPrompts });
  }, [dispatch, models]);

  useEffect(() => {
    if (builtInSystemPrompts.length === 0) {
      generateBuiltInSystemPrompts();
    }
  }, [builtInSystemPrompts, generateBuiltInSystemPrompts]);

  const handleUpdateConversation = (
    conversation: Conversation,
    data: KeyValuePair,
  ) => {
    if (!database || !user) return;

    const updatedConversation = {
      ...conversation,
      [data.key]: data.value,
    };

    let update: {
      single: Conversation;
      all: Conversation[];
    };

    if (data.key === 'messages') {
      const messages = conversation.messages;
      const updatedMessageList = data.value as Message[];

      const deletedMessages = messages.filter(
        (m) => !updatedMessageList.includes(m),
      );

      const updatedMessages = messages.filter((m) =>
        updatedMessageList.includes(m),
      );

      const deletedMessageIds = deletedMessages.map((m) => m.id);

      const cleaned = storageDeleteMessages(
        database,
        user,
        deletedMessageIds,
        conversation,
        messages,
        conversations,
      );

      const cleanConversation = cleaned.single;
      const cleanConversations = cleaned.all;

      update = storageUpdateMessages(
        database,
        user,
        cleanConversation,
        updatedMessages,
        cleanConversations,
      );
    } else {
      update = storageUpdateConversation(
        database,
        user,
        updatedConversation,
        conversations,
      );
    }

    dispatch({ field: 'selectedConversation', value: update.single });
    dispatch({ field: 'conversations', value: update.all });
    saveSelectedConversation(user, update.single);
  };

  // EFFECTS  --------------------------------------------

  useEffect(() => {
    if (window.innerWidth < 640) {
      dispatch({ field: 'showPrimaryMenu', value: false });
      dispatch({ field: 'showSecondaryMenu', value: false });
    }
  }, [dispatch, selectedConversation, display]);

  // ON LOAD --------------------------------------------

  useEffect(() => {
    if (!database || !user) return;

    if (window.innerWidth < 640) {
      dispatch({ field: 'showPrimaryMenu', value: false });
    }

    const showPrimaryMenu = localGetShowPrimaryMenu(user);
    if (showPrimaryMenu) {
      dispatch({ field: 'showPrimaryMenu', value: showPrimaryMenu });
    }

    const showSecondaryMenu = localGetShowSecondaryMenu(user);
    if (showSecondaryMenu) {
      dispatch({ field: 'showSecondaryMenu', value: showSecondaryMenu });
    }

    storageGetFolders(database, user).then((folders) => {
      if (folders) {
        dispatch({ field: 'folders', value: folders });
      }
    });

    storageGetPrompts(database, user).then((prompts) => {
      if (prompts) {
        dispatch({ field: 'prompts', value: prompts });
      }
    });
  }, [user, database, dispatch]);

  // SETTINGS --------------------------------------------

  useEffect(() => {
    if (!database || !user) return;

    const settings = getSettings();
    dispatch({ field: 'settings', value: settings });

    storageGetSystemPrompts(database, user).then((systemPrompts) => {
      const choices: SettingChoice[] = systemPrompts.map((sp) => {
        return { name: sp.name, value: sp.id };
      });
      choices.push({ name: 'Built-In', value: '0', default: true });
      const newSettings = setSettingChoices(
        settings,
        'general',
        'defaultSystemPromptId',
        choices,
      );

      dispatch({ field: 'settings', value: newSettings });
      dispatch({ field: 'systemPrompts', value: systemPrompts });
    });
  }, [dispatch, database, user]);

  useEffect(() => {
    if (!database || !user) return;

    if (!settingsLoaded) {
      const newSavedSettings = getSavedSettings(user);

      dispatch({
        field: 'savedSettings',
        value: newSavedSettings,
      });

      dispatch({
        field: 'settingsLoaded',
        value: true,
      });
    }
  }, [dispatch, savedSettings, user, settingsLoaded, database]);

  useEffect(() => {
    if (savedSettings && settings) {
      const lightMode = getSavedSettingValue(
        savedSettings,
        'personalization',
        'theme',
        settings,
      );

      dispatch({
        field: 'lightMode',
        value: lightMode,
      });
    }
  }, [savedSettings, settings, dispatch]);

  if (user && database && conversations.length > 0) {
    return (
      <HomeContext.Provider
        value={{
          ...contextValue,
          handleNewConversation,
          handleCreateFolder,
          handleDeleteFolder,
          handleUpdateFolder,
          handleSelectConversation,
          handleUpdateConversation,
        }}
      >
        {selectedConversation && (
          <div
            className={`relative flex-col text-sm overflow-y-hidden h-full max-h-full w-full
          text-black dark:text-white ${lightMode} m-0 p-0 overflow-hidden`}
          >
            <div className="absolute top-0 z-50 w-full sm:hidden">
              <Navbar
                selectedConversation={selectedConversation}
                onNewConversation={handleNewConversation}
              />
            </div>
            <div className="flex flex-shrink w-full h-full max-h-full pt-[50px] sm:pt-0 overflow-hidden overscroll-none">
              <PrimaryMenu />
              <ChatZone />
              <SecondaryMenu />
            </div>
          </div>
        )}
      </HomeContext.Provider>
    );
  } else {
    let text = '';

    if (!user) {
      text = 'Initializing Auth System...';
    } else if (!database) {
      text = 'Initializing Database...';
    } else if (conversations.length === 0) {
      text = 'Loading Conversations...';
    }

    return (
      <div
        className={`relative flex-col text-sm overflow-y-hidden h-full max-h-full w-full
          ${lightMode || 'dark'} m-0 p-0 overflow-hidden`}
      >
        <div
          className="flex flex-col items-center justify-center h-screen w-screen bg-[#ffffff]
        dark:bg-[#1f2428] dark:text-[#f0f0f0]"
        >
          <div className="flex flex-col items-center justify-center">
            <div className="flex flex-row items-center justify-center">
              <Image
                className="animate-bounce"
                width={256}
                height={256}
                src="/icon-256.svg"
                alt="poiesisPete Logo"
                priority
              />
            </div>
            <div className="flex flex-row items-center justify-center">
              <h2 className="text-xl font-bold text-primary-500">{text}</h2>
            </div>
          </div>
        </div>
      </div>
    );
  }
};
export default Home;
------------------------
./components/Home/components/Settings/Import.tsx
import { IconFileImport } from '@tabler/icons-react';
import { FC } from 'react';

import { useTranslation } from 'next-i18next';

import { SupportedExportFormats } from '@/types/export';

import { SidebarButton } from '@/components/Common/Sidebar/SidebarButton';

interface Props {
  onImport: (data: SupportedExportFormats) => void;
}

export const Import: FC<Props> = ({ onImport }) => {
  const { t } = useTranslation('sidebar');
  return (
    <>
      <input
        id="import-file"
        className="sr-only"
        tabIndex={-1}
        type="file"
        accept=".json"
        onChange={(e) => {
          if (!e.target.files?.length) return;

          const file = e.target.files[0];
          const reader = new FileReader();
          reader.onload = (e) => {
            let json = JSON.parse(e.target?.result as string);
            onImport(json);
          };
          reader.readAsText(file);
        }}
      />

      <SidebarButton
        text={t('Import data')}
        icon={<IconFileImport size={18} />}
        onClick={() => {
          const importFile = document.querySelector(
            '#import-file',
          ) as HTMLInputElement;
          if (importFile) {
            importFile.click();
          }
        }}
      />
    </>
  );
};
------------------------
./components/Home/components/PrimaryMenu/PrimaryMenu.context.tsx
import { Dispatch, createContext } from 'react';

import { ActionType } from '@/hooks/useCreateReducer';

import { PrimaryMenuInitialState } from './PrimaryMenu.state';

export interface PrimaryMenuContextProps {
  state: PrimaryMenuInitialState;
  dispatch: Dispatch<ActionType<PrimaryMenuInitialState>>;
}

const PrimaryMenuContext = createContext<PrimaryMenuContextProps>(undefined!);

export default PrimaryMenuContext;
------------------------
./components/Home/components/PrimaryMenu/PrimaryMenu.tsx
import { IconBulb, IconDeviceLaptop, IconMessages, IconCalendar } from '@tabler/icons-react';

import { useCreateReducer } from '@/hooks/useCreateReducer';

import ActivityBar from './components/ActivityBar/ActivityBar';
import Menu from './components/Menu/Menu';
import { Conversations } from './components/Menu/components/Screens/Conversations/Conversations';
import Prompts from './components/Menu/components/Screens/Prompts/Prompts';
import SystemPrompts from './components/Menu/components/Screens/SystemPrompts/SystemPrompts';

import PrimaryMenuContext from './PrimaryMenu.context';
import { PrimaryMenuInitialState, initialState } from './PrimaryMenu.state';

import  Calendar from './components/Menu/components/Screens/Calendar/Calendar';
import { SessionProvider } from 'next-auth/react';

export const PrimaryMenu = () => {
  const primaryMenuContextValue = useCreateReducer<PrimaryMenuInitialState>({
    initialState,
  });

  const icons = [
    <IconMessages size={28} key={0} />,
    <IconBulb size={28} key={1} />,
    <IconDeviceLaptop size={28} key={2} />,
    <IconCalendar size={28} key={3} />,
  ];

  const screens = [
    <Conversations key={0} />,
    <Prompts key={1} />,
    <SystemPrompts key={2} />,
    <Calendar />
  ];

  return (
    
    <SessionProvider>
      <PrimaryMenuContext.Provider value={primaryMenuContextValue}>
        <ActivityBar icons={icons}></ActivityBar>
        <Menu screens={screens}></Menu>
      </PrimaryMenuContext.Provider>
    </SessionProvider>
  );
};
------------------------
./components/Home/components/PrimaryMenu/components/Menu/components/Screens/SystemPrompts/SystemPrompts.tsx
import { IconFolderPlus, IconMistOff } from '@tabler/icons-react';
import { useContext, useEffect } from 'react';
import { useTranslation } from 'react-i18next';

import { useCreateReducer } from '@/hooks/useCreateReducer';

import { storageUpdateConversations } from '@/utils/app/storage/conversations';
import {
  storageCreateSystemPrompt,
  storageDeleteSystemPrompt,
  storageUpdateSystemPrompt,
} from '@/utils/app/storage/systemPrompt';

import { SystemPrompt } from '@/types/system-prompt';

import { SystemPromptFolders } from './components/Folders';
import { SystemPromptList } from './components/SystemPromptList';
import { PrimaryButtonAlt } from '@/components/Common/Buttons/PrimaryButton';
import { SecondaryButton } from '@/components/Common/Buttons/SecondaryButton';
import Search from '@/components/Common/Search';
import HomeContext from '@/components/Home/home.context';

import SystemPromptsContext from './SystemPrompts.context';
import { SystemPromptsInitialState, initialState } from './SystemPrompts.state';

import { v4 as uuidv4 } from 'uuid';

const SystemPrompts = () => {
  const { t } = useTranslation('systemPrompts');

  const systemPromptsContextValue = useCreateReducer<SystemPromptsInitialState>(
    {
      initialState,
    },
  );

  const {
    state: {
      systemPrompts,
      database,
      user,
      models,
      conversations,
      selectedConversation,
    },
    dispatch: homeDispatch,
    handleCreateFolder,
  } = useContext(HomeContext);

  const {
    state: { searchTerm, filteredSystemPrompts },
    dispatch: promptDispatch,
  } = systemPromptsContextValue;

  const handleCreateSystemPrompt = async () => {
    const newSystemPrompt: SystemPrompt = {
      id: uuidv4(),
      name: `${t('New System Prompt')}`,
      content: '',
      folderId: null,
      models: [],
    };

    const updatedSystemPrompts = storageCreateSystemPrompt(
      database!,
      user!,
      newSystemPrompt,
      systemPrompts,
    );

    homeDispatch({ field: 'systemPrompts', value: updatedSystemPrompts });
  };

  const handleUpdateSystemPrompt = (updatedSystemPrompt: SystemPrompt) => {
    let update: {
      single: SystemPrompt;
      all: SystemPrompt[];
    };

    update = storageUpdateSystemPrompt(
      database!,
      user!,
      updatedSystemPrompt,
      systemPrompts,
    );

    homeDispatch({ field: 'systemPrompts', value: update.all });
  };

  const handleDeleteSystemPrompt = (systemPromptId: string) => {
    const updatedSystemPrompts = systemPrompts.filter(
      (s) => s.id !== systemPromptId,
    );

    storageDeleteSystemPrompt(database!, user!, systemPromptId, systemPrompts);

    for (const model of models) {
      // const sectionId = model.vendor.toLowerCase();
      // const settingId = `${model.id}_default_system_prompt`;
      // const modelDefaultSystemPromptId = getSavedSettingValue(
      //   savedSettings,
      //   sectionId,
      //   settingId,
      //   settings,
      // );

      // if (modelDefaultSystemPromptId === systemPromptId) {
      //   // Resetting default system prompt to built-in
      //   setSavedSetting(user, sectionId, settingId, null);
      // }
      homeDispatch({ field: 'systemPrompts', value: updatedSystemPrompts });
    }

    const updatedConversations = [];
    for (const conversation of conversations) {
      if (conversation.systemPrompt?.id === systemPromptId) {
        const updatedConversation = {
          ...conversation,
          systemPrompt: null,
        };
        updatedConversations.push(updatedConversation);
      } else {
        updatedConversations.push(conversation);
      }
    }

    if (selectedConversation?.systemPrompt?.id === systemPromptId) {
      const updatedSelectedConversation = {
        ...selectedConversation,
        systemPrompt: null,
      };
      homeDispatch({
        field: 'selectedConversation',
        value: updatedSelectedConversation,
      });
    }

    storageUpdateConversations(database!, user!, updatedConversations);
  };

  const handleDrop = (e: any) => {
    if (e.dataTransfer) {
      const systemPrompt = JSON.parse(e.dataTransfer.getData('system_prompt'));

      const updatedSystemPrompt = {
        ...systemPrompt,
        folderId: e.target.dataset.folderId,
      };

      handleUpdateSystemPrompt(updatedSystemPrompt);

      e.target.style.background = 'none';
    }
  };

  useEffect(() => {
    if (searchTerm) {
      promptDispatch({
        field: 'filteredSystemPrompts',
        value: systemPrompts.filter((systemPrompt) => {
          const searchable =
            systemPrompt.name.toLowerCase() +
            ' ' +
            systemPrompt.models.join(' ').toLowerCase() +
            ' ' +
            systemPrompt.content.toLowerCase();
          return searchable.includes(searchTerm.toLowerCase());
        }),
      });
    } else {
      promptDispatch({
        field: 'filteredSystemPrompts',
        value: systemPrompts,
      });
    }
  }, [searchTerm, systemPrompts, promptDispatch]);

  const allowDrop = (e: any) => {
    e.preventDefault();
  };

  const highlightDrop = (e: any) => {
    e.target.style.background = '#343541';
  };

  const removeHighlight = (e: any) => {
    e.target.style.background = 'none';
  };

  const doSearch = (term: string) =>
    promptDispatch({ field: 'searchTerm', value: term });

  const createFolder = () =>
    handleCreateFolder(t('New folder'), 'system_prompt');

  return (
    <SystemPromptsContext.Provider
      value={{
        ...systemPromptsContextValue,
        handleCreateSystemPrompt,
        handleUpdateSystemPrompt,
        handleDeleteSystemPrompt,
      }}
    >
      <div className="flex items-center gap-x-2">
        <PrimaryButtonAlt
          onClick={() => {
            handleCreateSystemPrompt();
            doSearch('');
          }}
        >
          {t('New system prompt')}
        </PrimaryButtonAlt>
        <SecondaryButton onClick={createFolder}>
          <IconFolderPlus size={16} />
        </SecondaryButton>
      </div>
      <Search
        placeholder={t('Search...') || ''}
        searchTerm={searchTerm}
        onSearch={doSearch}
      />

      <div className="flex-grow overflow-auto">
        {filteredSystemPrompts?.length > 0 && (
          <div
            className="flex border-b pb-2
          border-theme-button-border-light dark:border-theme-button-border-dark"
          >
            <SystemPromptFolders />
          </div>
        )}

        {filteredSystemPrompts?.length > 0 ? (
          <div
            className="pt-2"
            onDrop={handleDrop}
            onDragOver={allowDrop}
            onDragEnter={highlightDrop}
            onDragLeave={removeHighlight}
          >
            <SystemPromptList
              systemPrompts={filteredSystemPrompts.filter(
                (systemPrompt) => !systemPrompt.folderId,
              )}
            />
          </div>
        ) : (
          <div className="mt-8 select-none text-center text-black dark:text-white opacity-50">
            <IconMistOff className="mx-auto mb-3" />
            <span className="text-[14px] leading-normal">{t('No data.')}</span>
          </div>
        )}
      </div>
    </SystemPromptsContext.Provider>
  );
};

export default SystemPrompts;
------------------------
./components/Home/components/PrimaryMenu/components/Menu/components/Screens/SystemPrompts/SystemPrompts.context.tsx
import { Dispatch, createContext } from 'react';

import { ActionType } from '@/hooks/useCreateReducer';

import { SystemPrompt } from '@/types/system-prompt';

import { SystemPromptsInitialState } from './SystemPrompts.state';

export interface SystemPromptsContextProps {
  state: SystemPromptsInitialState;
  dispatch: Dispatch<ActionType<SystemPromptsInitialState>>;
  handleCreateSystemPrompt: () => void;
  handleUpdateSystemPrompt: (systemPrompt: SystemPrompt) => void;
  handleDeleteSystemPrompt: (systemPromptId: string) => void;
}

const SystemPromptsContext = createContext<SystemPromptsContextProps>(
  undefined!,
);

export default SystemPromptsContext;
------------------------
./components/Home/components/PrimaryMenu/components/Menu/components/Screens/SystemPrompts/components/Folders.tsx
import { useContext } from 'react';

import { FolderInterface } from '@/types/folder';

import Folder from '@/components/Common/Folder';
import HomeContext from '@/components/Home/home.context';

import SystemPromptsContext from '../SystemPrompts.context';
import { SystemPromptComponent } from './SystemPromptComponent';

export const SystemPromptFolders = () => {
  const {
    state: { folders },
  } = useContext(HomeContext);

  const {
    state: { searchTerm, filteredSystemPrompts },
    handleUpdateSystemPrompt,
  } = useContext(SystemPromptsContext);

  const handleDrop = (e: any, folder: FolderInterface) => {
    if (e.dataTransfer) {
      const prompt = JSON.parse(e.dataTransfer.getData('system_prompt'));

      const updatedPrompt = {
        ...prompt,
        folderId: folder.id,
      };

      handleUpdateSystemPrompt(updatedPrompt);
    }
  };

  const Folders = (currentFolder: FolderInterface) =>
    filteredSystemPrompts
      .filter((p) => p.folderId)
      .map((systemPrompt, index) => {
        if (systemPrompt.folderId === currentFolder.id) {
          return (
            <div
              key={index}
              className="ml-5 gap-2 border-l border-theme-button-border-light dark:border-theme-button-border-dark pl-2"
            >
              <SystemPromptComponent systemPrompt={systemPrompt} />
            </div>
          );
        }
      });

  return (
    <div className="flex w-full flex-col pt-2">
      {folders
        .filter((folder) => folder.type === 'prompt')
        .sort((a, b) => a.name.localeCompare(b.name))
        .map((folder, index) => (
          <Folder
            key={index}
            searchTerm={searchTerm}
            currentFolder={folder}
            handleDrop={handleDrop}
            folderComponent={Folders(folder)}
          />
        ))}
    </div>
  );
};
------------------------
./components/Home/components/PrimaryMenu/components/Menu/components/Screens/SystemPrompts/components/SystemPromptEditModal.tsx
import {
  FC,
  KeyboardEvent,
  useContext,
  useEffect,
  useRef,
  useState,
} from 'react';

import { useTranslation } from 'next-i18next';

import { SystemPrompt } from '@/types/system-prompt';

import { PrimaryButtonAlt } from '@/components/Common/Buttons/PrimaryButton';
import { PrimaryLabel } from '@/components/Common/Labels/PrimaryLabel';

import SystemPromptsContext from '../SystemPrompts.context';
import { ChipList } from './ModelsList';

interface Props {
  systemPrompt: SystemPrompt;
  onClose: () => void;
}

export const SystemPromptEditModal: FC<Props> = ({ systemPrompt, onClose }) => {
  const { handleUpdateSystemPrompt } = useContext(SystemPromptsContext);
  const { t } = useTranslation('systemPrompt');

  const [name, setName] = useState(systemPrompt.name);
  const [content, setContent] = useState(systemPrompt.content);
  const [models, setModels] = useState(systemPrompt.models);

  const modalRef = useRef<HTMLDivElement>(null);
  const nameInputRef = useRef<HTMLInputElement>(null);

  const handleEnter = (e: KeyboardEvent<HTMLDivElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      const updatedPrompt: SystemPrompt = {
        id: systemPrompt.id,
        name: name,
        content: content,
        folderId: systemPrompt.folderId,
        models: models,
      };
      if (updatedPrompt.content !== '') {
        handleUpdateSystemPrompt(updatedPrompt);
        onClose();
      }
    }
  };

  const handleSelectModel = (modelId: string) => {
    if (models.includes(modelId)) {
      // Remove model from list
      setModels(models.filter((model) => model !== modelId));
    } else {
      // Add model to list
      setModels([...models, modelId]);
    }
  };

  useEffect(() => {
    const handleMouseDown = (e: MouseEvent) => {
      if (modalRef.current && !modalRef.current.contains(e.target as Node)) {
        window.addEventListener('mouseup', handleMouseUp);
      }
    };

    const handleMouseUp = (e: MouseEvent) => {
      window.removeEventListener('mouseup', handleMouseUp);
      onClose();
    };

    window.addEventListener('mousedown', handleMouseDown);

    return () => {
      window.removeEventListener('mousedown', handleMouseDown);
    };
  }, [onClose]);

  useEffect(() => {
    nameInputRef.current?.focus();
  }, []);

  return (
    <div
      className="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50"
      onKeyDown={handleEnter}
    >
      <div className="fixed inset-0 z-10 overflow-hidden">
        <div className="flex items-center justify-center min-h-screen px-4 pt-4 pb-20 text-center sm:block sm:p-0">
          <div
            className="hidden sm:inline-block sm:h-screen sm:align-middle"
            aria-hidden="true"
          />

          <div
            ref={modalRef}
            className="dark:border-neutral-400 inline-block max-h-[400px] transform
            overflow-y-hidden rounded-lg border border-gray-300 
            bg-white px-4 pt-5 pb-4 text-left align-bottom shadow-xl
            transition-all dark:bg-[#202123] sm:my-8 sm:max-h-[600px]
            sm:w-full sm:max-w-lg sm:p-6 sm:align-middle"
            role="dialog"
          >
            <label className="mb-2 text-left text-neutral-900 dark:text-neutral-200">
              {t('Name')}
            </label>
            <input
              ref={nameInputRef}
              className="mt-2 mb-4 w-full rounded-lg border border-neutral-500 px-4 py-2 text-neutral-900 shadow focus:outline-none dark:border-neutral-800 dark:border-opacity-50 dark:bg-[#40414F] dark:text-neutral-100"
              placeholder={'A name for your system prompt.'}
              value={name}
              onChange={(e) => setName(e.target.value)}
            />

            <label className="mb-2 text-left text-neutral-900 dark:text-neutral-200">
              {t('Prompt')}
            </label>
            <textarea
              className="mt-2 w-full rounded-lg border border-neutral-500 px-4 py-2 text-neutral-900 shadow focus:outline-none dark:border-neutral-800 dark:border-opacity-50 dark:bg-[#40414F] dark:text-neutral-100"
              style={{ resize: 'none' }}
              placeholder={'Your custom prompt'}
              value={content}
              onChange={(e) => setContent(e.target.value)}
              rows={10}
            />

            <PrimaryLabel
              tip={'The models to make this system prompt available for.'}
            >
              {t('Models')}
            </PrimaryLabel>
            <ChipList
              selectedModels={models}
              handleSelectModel={handleSelectModel}
            />

            <div className="flex space-x-4 mt-4">
              <PrimaryButtonAlt
                onClick={() => {
                  onClose();
                }}
              >
                {t('Cancel')}
              </PrimaryButtonAlt>
              <PrimaryButtonAlt
                onClick={() => {
                  const updatedPrompt: SystemPrompt = {
                    id: systemPrompt.id,
                    name: name,
                    content: content,
                    folderId: systemPrompt.folderId,
                    models: models,
                  };
                  handleUpdateSystemPrompt(updatedPrompt);
                  onClose();
                }}
              >
                {t('Save')}
              </PrimaryButtonAlt>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};
------------------------
./components/Home/components/PrimaryMenu/components/Menu/components/Screens/SystemPrompts/components/SystemPromptComponent.tsx
import {
  IconCheck,
  IconDeviceLaptop,
  IconTrash,
  IconX,
} from '@tabler/icons-react';
import {
  DragEvent,
  MouseEventHandler,
  useContext,
  useEffect,
  useState,
} from 'react';

import { SystemPrompt } from '@/types/system-prompt';

import SidebarActionButton from '@/components/Common/Buttons/SidebarActionButton';

import SystemPromptsContext from '../SystemPrompts.context';
import { SystemPromptEditModal } from './SystemPromptEditModal';

interface Props {
  systemPrompt: SystemPrompt;
}

export const SystemPromptComponent = ({ systemPrompt }: Props) => {
  const {
    handleUpdateSystemPrompt,
    handleDeleteSystemPrompt,
    dispatch: promptDispatch,
  } = useContext(SystemPromptsContext);

  const [showModal, setShowModal] = useState<boolean>(false);
  const [isDeleting, setIsDeleting] = useState(false);
  const [isRenaming, setIsRenaming] = useState(false);
  const [renameValue, setRenameValue] = useState('');

  const handleUpdate = (systemPrompts: SystemPrompt) => {
    handleUpdateSystemPrompt(systemPrompt);
    promptDispatch({ field: 'searchTerm', value: '' });
  };

  const handleDelete: MouseEventHandler<HTMLButtonElement> = (e) => {
    e.stopPropagation();

    if (isDeleting) {
      handleDeleteSystemPrompt(systemPrompt.id);
      promptDispatch({ field: 'searchTerm', value: '' });
    }

    setIsDeleting(false);
  };

  const handleCancelDelete: MouseEventHandler<HTMLButtonElement> = (e) => {
    e.stopPropagation();
    setIsDeleting(false);
  };

  const handleOpenDeleteModal: MouseEventHandler<HTMLButtonElement> = (e) => {
    e.stopPropagation();
    setIsDeleting(true);
  };

  const handleDragStart = (
    e: DragEvent<HTMLButtonElement>,
    systemPrompt: SystemPrompt,
  ) => {
    if (e.dataTransfer) {
      e.dataTransfer.setData('system_prompt', JSON.stringify(systemPrompt));
    }
  };

  useEffect(() => {
    if (isRenaming) {
      setIsDeleting(false);
    } else if (isDeleting) {
      setIsRenaming(false);
    }
  }, [isRenaming, isDeleting]);

  return (
    <div className="relative flex items-center">
      <button
        className="flex w-full cursor-pointer items-center gap-3 rounded-lg p-3 text-sm transition-colors
         duration-200 text-black dark:text-white hover:bg-theme-hover-light dark:hover:bg-theme-hover-dark"
        draggable="true"
        onClick={(e) => {
          e.stopPropagation();
          setShowModal(true);
        }}
        onDragStart={(e) => handleDragStart(e, systemPrompt)}
        onMouseLeave={() => {
          setIsDeleting(false);
          setIsRenaming(false);
          setRenameValue('');
        }}
      >
        <IconDeviceLaptop size={18} />

        <div
          className="relative max-h-5 flex-1 overflow-hidden text-ellipsis whitespace-nowrap
        break-all pr-4 text-left text-[12.5px] leading-3"
        >
          {systemPrompt.name}
        </div>
      </button>

      {(isDeleting || isRenaming) && (
        <div
          className="absolute right-1 z-10 flex
        hover:text-theme-button-icon-hover-light dark:hover:text-theme-button-icon-hover-dark"
        >
          <SidebarActionButton handleClick={handleDelete}>
            <IconCheck size={18} />
          </SidebarActionButton>

          <SidebarActionButton handleClick={handleCancelDelete}>
            <IconX size={18} />
          </SidebarActionButton>
        </div>
      )}

      {!isDeleting && !isRenaming && (
        <div
          className="absolute right-1 z-10 flex
        hover:text-theme-button-icon-hover-light dark:hover:text-theme-button-icon-hover-dark"
        >
          <SidebarActionButton handleClick={handleOpenDeleteModal}>
            <IconTrash size={18} />
          </SidebarActionButton>
        </div>
      )}

      {showModal && (
        <SystemPromptEditModal
          systemPrompt={systemPrompt}
          onClose={() => setShowModal(false)}
          key={systemPrompt.id}
        />
      )}
    </div>
  );
};
------------------------
./components/Home/components/PrimaryMenu/components/Menu/components/Screens/SystemPrompts/components/SystemPromptList.tsx
import { FC } from 'react';

import { SystemPrompt } from '@/types/system-prompt';

import { SystemPromptComponent } from './SystemPromptComponent';

interface Props {
  systemPrompts: SystemPrompt[];
}

export const SystemPromptList: FC<Props> = ({ systemPrompts }) => {
  return (
    <div className="flex w-full flex-col gap-1">
      {systemPrompts
        .slice()
        .reverse()
        .map((systemPrompt, index) => (
          <SystemPromptComponent key={index} systemPrompt={systemPrompt} />
        ))}
    </div>
  );
};
------------------------
./components/Home/components/PrimaryMenu/components/Menu/components/Screens/SystemPrompts/components/SystemPromptModal.tsx
import { FC, KeyboardEvent, useEffect, useRef, useState } from 'react';

import { useTranslation } from 'next-i18next';

import { Prompt } from '@/types/prompt';

import { PrimaryButtonAlt } from '@/components/Common/Buttons/PrimaryButton';

interface Props {
  prompt: Prompt;
  onClose: () => void;
  onUpdatePrompt: (prompt: Prompt) => void;
}

export const PromptModal: FC<Props> = ({ prompt, onClose, onUpdatePrompt }) => {
  const { t } = useTranslation('promptbar');
  const [name, setName] = useState(prompt.name);
  const [description, setDescription] = useState(prompt.description);
  const [content, setContent] = useState(prompt.content);

  const modalRef = useRef<HTMLDivElement>(null);
  const nameInputRef = useRef<HTMLInputElement>(null);

  const handleEnter = (e: KeyboardEvent<HTMLDivElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      onUpdatePrompt({ ...prompt, name, description, content: content.trim() });
      onClose();
    }
  };

  useEffect(() => {
    const handleMouseDown = (e: MouseEvent) => {
      if (modalRef.current && !modalRef.current.contains(e.target as Node)) {
        window.addEventListener('mouseup', handleMouseUp);
      }
    };

    const handleMouseUp = (e: MouseEvent) => {
      window.removeEventListener('mouseup', handleMouseUp);
      onClose();
    };

    window.addEventListener('mousedown', handleMouseDown);

    return () => {
      window.removeEventListener('mousedown', handleMouseDown);
    };
  }, [onClose]);

  useEffect(() => {
    nameInputRef.current?.focus();
  }, []);

  return (
    <div
      className="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50"
      onKeyDown={handleEnter}
    >
      <div className="fixed inset-0 z-10 overflow-hidden">
        <div className="flex items-center justify-center min-h-screen px-4 pt-4 pb-20 text-center sm:block sm:p-0">
          <div
            className="hidden sm:inline-block sm:h-screen sm:align-middle"
            aria-hidden="true"
          />

          <div
            ref={modalRef}
            className="dark:border-netural-400 inline-block max-h-[400px] transform overflow-y-auto rounded-lg border border-gray-300 bg-white px-4 pt-5 pb-4 text-left align-bottom shadow-xl transition-all dark:bg-[#202123] sm:my-8 sm:max-h-[600px] sm:w-full sm:max-w-lg sm:p-6 sm:align-middle"
            role="dialog"
          >
            <div className="text-sm font-bold text-black dark:text-neutral-200">
              {t('Name')}
            </div>
            <input
              ref={nameInputRef}
              className="mt-2 w-full rounded-lg border border-neutral-500 px-4 py-2 text-neutral-900 shadow focus:outline-none dark:border-neutral-800 dark:border-opacity-50 dark:bg-[#40414F] dark:text-neutral-100"
              placeholder={t('A name for your prompt.') || ''}
              value={name}
              onChange={(e) => setName(e.target.value)}
            />

            <div className="mt-6 text-sm font-bold text-black dark:text-neutral-200">
              {t('Description')}
            </div>
            <textarea
              className="mt-2 w-full rounded-lg border border-neutral-500 px-4 py-2 text-neutral-900 shadow focus:outline-none dark:border-neutral-800 dark:border-opacity-50 dark:bg-[#40414F] dark:text-neutral-100"
              style={{ resize: 'none' }}
              placeholder={t('A description for your prompt.') || ''}
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              rows={3}
            />

            <div className="mt-6 text-sm font-bold text-black dark:text-neutral-200">
              {t('Prompt')}
            </div>
            <textarea
              className="mt-2 mb-4 w-full rounded-lg border border-neutral-500 px-4 py-2 text-neutral-900 shadow focus:outline-none dark:border-neutral-800 dark:border-opacity-50 dark:bg-[#40414F] dark:text-neutral-100"
              style={{ resize: 'none' }}
              placeholder={
                t(
                  'Prompt content. Use {{}} to denote a variable. Ex: {{name}} is a {{adjective}} {{noun}}',
                ) || ''
              }
              value={content}
              onChange={(e) => setContent(e.target.value)}
              rows={10}
            />

            <PrimaryButtonAlt
              onClick={() => {
                const updatedPrompt = {
                  ...prompt,
                  name,
                  description,
                  content: content.trim(),
                };

                onUpdatePrompt(updatedPrompt);
                onClose();
              }}
            >
              {t('Save')}
            </PrimaryButtonAlt>
          </div>
        </div>
      </div>
    </div>
  );
};
------------------------
./components/Home/components/PrimaryMenu/components/Menu/components/Screens/SystemPrompts/components/ModelsList.tsx
import { useContext } from 'react';

import { Chip } from '@/components/Common/Chips/Chip';
import HomeContext from '@/components/Home/home.context';

// Return a list of models as chips without any scrolling
export const ChipList = ({
  selectedModels,
  handleSelectModel,
}: {
  selectedModels: string[];
  handleSelectModel: any;
}) => {
  const {
    state: { models },
  } = useContext(HomeContext);

  return (
    <div className="flex flex-wrap space-x-2">
      {models.map((model) => (
        <Chip
          key={model.id}
          id={model.id}
          handleSelect={handleSelectModel}
          isSelected={selectedModels.includes(model.id)}
        >
          {model.id}
        </Chip>
      ))}
    </div>
  );
};
------------------------
./components/Home/components/PrimaryMenu/components/Menu/components/Screens/SystemPrompts/SystemPrompts.state.tsx
import { SystemPrompt } from '@/types/system-prompt';

export interface SystemPromptsInitialState {
  searchTerm: string;
  filteredSystemPrompts: SystemPrompt[];
}

export const initialState: SystemPromptsInitialState = {
  searchTerm: '',
  filteredSystemPrompts: [],
};
------------------------
./components/Home/components/PrimaryMenu/components/Menu/components/Screens/Calendar/Calendar.context.tsx
import { createContext, Dispatch, ReactNode, useReducer } from 'react';

interface CalendarState {
  selectedDate: Date;
  // Add any other state you think is necessary
}
const calendarReducer = (state: CalendarState, action: any): CalendarState => {
    switch (action.type) {
      // Handle your actions here
      default:
        return state;
    }
  };
  

const initialState: CalendarState = {
  selectedDate: new Date(),
};

interface CalendarContextProps {
  children: ReactNode;
}

export const CalendarContext = createContext({});

export const CalendarProvider: React.FC<CalendarContextProps> = ({ children }) => {
  const [state, dispatch] = useReducer(calendarReducer, initialState);  // You'd need to define 'calendarReducer'

  return (
    <CalendarContext.Provider value={{ state, dispatch }}>
      {children}
    </CalendarContext.Provider>
  );
};
------------------------
./components/Home/components/PrimaryMenu/components/Menu/components/Screens/Calendar/Calendar.tsx
import { useContext, useEffect, useState } from 'react';
import { eachDayOfInterval, startOfMonth, endOfMonth, format } from 'date-fns';
import HomeContext from '@/components/Home/home.context';
import {CalendarContext} from './Calendar.context';
import DateCell from './components/DateCell';
import { useSession } from 'next-auth/react';



const Calendar = () => {
    const { data: session } = useSession();

  const {
    state: { currentDate },
  } = useContext(HomeContext);

  const [importantDates, setImportantDates] = useState<string[]>([]);  // Store the important dates as an array of strings

useEffect(() => {
  if (session) {
    fetchImportantDates(session.customAccessToken)
      .then(events => {
        const eventDates = events.map(event => format(new Date(event.start.dateTime), 'yyyy-MM-dd'));
        setImportantDates(eventDates);
      })
      .catch(error => console.error("Couldn't fetch important dates:", error));
  }
}, [session]);

  

  const [dates, setDates] = useState<Date[]>([]);  // Array of dates for the current month

  useEffect(() => {
    const start = startOfMonth(currentDate);
    const end = endOfMonth(currentDate);
    const dateArray = eachDayOfInterval({ start, end });
    setDates(dateArray);
  }, [currentDate]);

  const daysOfWeek = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
  const fetchImportantDates = async (accessToken) => {
    const endpoint = "https://graph.microsoft.com/v1.0/me/events";
    
    const response = await fetch(endpoint, {
      headers: {
        Authorization: `Bearer ${accessToken}`,
        'Content-Type': 'application/json'
      }
    });
  
    if (response.ok) {
      const data = await response.json();
      return data.value; // The events are in the 'value' property.
    } else {
      throw new Error('Failed to fetch events from Microsoft Calendar');
    }
  }
  

  return (
    <CalendarContext.Provider value={{}}>
      <table>
        <thead>
          <tr>
            {daysOfWeek.map((day) => (
              <th key={day}>{day}</th>
            ))}
          </tr>
        </thead>
        <tbody>
          {/* This will render dates in a week-based row format */}
          {[...Array(Math.ceil(dates.length / 7))].map((_, weekIndex) => (
            <tr key={weekIndex}>
              {[...Array(7)].map((_, dayIndex) => {
                const date = dates[weekIndex * 7 + dayIndex];
                return (
                  <td key={dayIndex}>
                    {date && <DateCell key={dayIndex} date={date} isImportant={importantDates.includes(format(date, 'yyyy-MM-dd'))} />
}
                  </td>
                );
              })}
            </tr>
          ))}
        </tbody>
      </table>
    </CalendarContext.Provider>
  );
};

export default Calendar;
------------------------
./components/Home/components/PrimaryMenu/components/Menu/components/Screens/Calendar/components/columns.tsx
------------------------
./components/Home/components/PrimaryMenu/components/Menu/components/Screens/Calendar/components/DateCell.tsx
import { useContext } from 'react';
import HomeContext from '@/components/Home/home.context';

interface DateCellProps {
  date: Date;
  isImportant: boolean;
}

const DateCell: React.FC<DateCellProps> = ({ date, isImportant }) => {
  const {
    state: { currentDate },
  } = useContext(HomeContext);

  // Add any logic or styles based on the comparison between 'date' and 'currentDate'

  return (
    <td>
      {date.getDate()}  {/* Display the date number */}
      {isImportant && <span>*</span>}  {/* Indicate the date is important */}
    </td>
  );
}

export default DateCell;
------------------------
./components/Home/components/PrimaryMenu/components/Menu/components/Screens/Calendar/components/DataTable.tsx
------------------------
./components/Home/components/PrimaryMenu/components/Menu/components/Screens/Conversations/Conversations.context.tsx
import { Dispatch, createContext } from 'react';

import { ActionType } from '@/hooks/useCreateReducer';

import { Conversation } from '@/types/chat';
import { Database } from '@/types/database';
import { SupportedExportFormats } from '@/types/export';

import { ConversationsInitialState } from './Conversations.state';

export interface ConversationsContextProps {
  state: ConversationsInitialState;
  dispatch: Dispatch<ActionType<ConversationsInitialState>>;
  handleDeleteConversation: (conversation: Conversation) => void;
  handleClearConversations: () => void;
  handleExportData: (database: Database) => void;
  handleImportConversations: (data: SupportedExportFormats) => void;
}

const ConversationsContext = createContext<ConversationsContextProps>(
  undefined!,
);

export default ConversationsContext;
------------------------
./components/Home/components/PrimaryMenu/components/Menu/components/Screens/Conversations/Conversations.tsx
import { IconFolderPlus, IconMistOff, IconPlus } from '@tabler/icons-react';
import { useCallback, useContext, useEffect } from 'react';

import { useTranslation } from 'next-i18next';

import { useCreateReducer } from '@/hooks/useCreateReducer';

import { DEFAULT_TEMPERATURE } from '@/utils/app/const';
import { exportData, importData } from '@/utils/app/importExport';
import { storageDeleteConversation } from '@/utils/app/storage/conversation';
import { storageDeleteConversations } from '@/utils/app/storage/conversations';
import {
  storageDeleteFolders,
  storageUpdateFolders,
} from '@/utils/app/storage/folders';
import { localSaveAPIKey } from '@/utils/app/storage/local/apiKey';
import { localSaveShowPrimaryMenu } from '@/utils/app/storage/local/uiState';
import {
  deleteSelectedConversation,
  saveSelectedConversation,
} from '@/utils/app/storage/selectedConversation';

import { Conversation } from '@/types/chat';
import { Database } from '@/types/database';
import { LatestExportFormat, SupportedExportFormats } from '@/types/export';

import { ConversationList } from './components/ConversationList';
import { ConversationsSettings } from './components/ConversationsSettings';
import { ConversationsFolders } from './components/Folders';
import { PrimaryButtonAlt } from '@/components/Common/Buttons/PrimaryButton';
import { SecondaryButton } from '@/components/Common/Buttons/SecondaryButton';
import Search from '@/components/Common/Search';
import HomeContext from '@/components/Home/home.context';

import ConversationsContext from './Conversations.context';
import { ConversationsInitialState, initialState } from './Conversations.state';

import { v4 as uuidv4 } from 'uuid';

export const Conversations = () => {
  const { t } = useTranslation('conversations');

  const conversationsContextValue = useCreateReducer<ConversationsInitialState>(
    {
      initialState,
    },
  );

  const {
    state: {
      conversations,
      showPrimaryMenu,
      defaultModelId,
      database,
      folders,
      user,
    },
    dispatch: homeDispatch,
    handleCreateFolder,
    handleNewConversation,
    handleUpdateConversation,
  } = useContext(HomeContext);

  const {
    state: { searchTerm, filteredConversations },
    dispatch: chatDispatch,
  } = conversationsContextValue;

  const handleExportData = (database: Database) => {
    exportData(database, user!);
  };

  const handleImportConversations = async (data: SupportedExportFormats) => {
    if (!database || !user) return;
    const {
      conversations,
      folders,
      system_prompts,
      message_templates,
    }: LatestExportFormat = await importData(database, user, data);
    homeDispatch({ field: 'conversations', value: conversations });
    homeDispatch({
      field: 'selectedConversation',
      value: conversations[conversations.length - 1],
    });
    homeDispatch({ field: 'folders', value: folders });
    homeDispatch({ field: 'prompts', value: message_templates });
    homeDispatch({ field: 'systemPrompts', value: system_prompts });
  };

  const handleClearConversations = async () => {
    if (!database || !user) return;
    homeDispatch({ field: 'conversations', value: [] });

    const deletedFolders = folders.filter((f) => f.type === 'chat');

    let deletedFolderIds: string[] = [];
    for (const folder of deletedFolders) {
      deletedFolderIds.push(folder.id);
    }

    await storageDeleteConversations(database, user);
    storageDeleteFolders(database, user, deletedFolderIds);
    deleteSelectedConversation(user);

    const updatedFolders = folders.filter((f) => f.type !== 'chat');

    homeDispatch({ field: 'folders', value: updatedFolders });
    storageUpdateFolders(database, user, updatedFolders);
  };

  const handleDeleteConversation = (conversation: Conversation) => {
    if (!database || !user) return;
    const updatedConversations = storageDeleteConversation(
      database,
      user,
      conversation.id,
      conversations,
    );

    homeDispatch({ field: 'conversations', value: updatedConversations });
    chatDispatch({ field: 'searchTerm', value: '' });

    if (updatedConversations.length > 0) {
      homeDispatch({
        field: 'selectedConversation',
        value: updatedConversations[updatedConversations.length - 1],
      });

      saveSelectedConversation(
        user,
        updatedConversations[updatedConversations.length - 1],
      );
    } else {
      deleteSelectedConversation(user);
    }
  };

  const handleDrop = (e: any) => {
    if (e.dataTransfer) {
      const conversation = JSON.parse(e.dataTransfer.getData('conversation'));
      handleUpdateConversation(conversation, { key: 'folderId', value: null });
      chatDispatch({ field: 'searchTerm', value: '' });
      e.target.style.background = 'none';
    }
  };

  useEffect(() => {
    if (searchTerm) {
      chatDispatch({
        field: 'filteredConversations',
        value: conversations.filter((conversation) => {
          const searchable =
            conversation.name.toLocaleLowerCase() +
            ' ' +
            conversation.messages.map((message) => message.content).join(' ');
          return searchable.toLowerCase().includes(searchTerm.toLowerCase());
        }),
      });
    } else {
      chatDispatch({
        field: 'filteredConversations',
        value: conversations,
      });
    }
  }, [searchTerm, conversations, chatDispatch]);

  const doSearch = (term: string) =>
    chatDispatch({ field: 'searchTerm', value: term });

  const createFolder = () => handleCreateFolder(t('New folder'), 'chat');

  const allowDrop = (e: any) => {
    e.preventDefault();
  };

  const highlightDrop = (e: any) => {
    e.target.style.background = '#343541';
  };

  const removeHighlight = (e: any) => {
    e.target.style.background = 'none';
  };

  return (
    <ConversationsContext.Provider
      value={{
        ...conversationsContextValue,
        handleDeleteConversation,
        handleClearConversations,
        handleImportConversations,
        handleExportData,
      }}
    >
      <div className="flex items-center gap-x-2">
        <PrimaryButtonAlt
          onClick={() => {
            handleNewConversation();
            doSearch('');
          }}
        >
          {t('New conversation')}
        </PrimaryButtonAlt>

        <SecondaryButton onClick={createFolder}>
          <IconFolderPlus size={16} />
        </SecondaryButton>
      </div>
      <Search
        placeholder={t('Search...') || ''}
        searchTerm={searchTerm}
        onSearch={doSearch}
      />

      <div className="flex-grow overflow-auto">
        {filteredConversations?.length > 0 && (
          <div
            className="flex border-b pb-2
          border-theme-button-border-light dark:border-theme-button-border-dark"
          >
            <ConversationsFolders searchTerm={searchTerm} />
          </div>
        )}

        {filteredConversations?.length > 0 ? (
          <div
            className="pt-2"
            onDrop={handleDrop}
            onDragOver={allowDrop}
            onDragEnter={highlightDrop}
            onDragLeave={removeHighlight}
          >
            <ConversationList conversations={filteredConversations} />
          </div>
        ) : (
          <div className="mt-8 select-none text-center text-black dark:text-white opacity-50">
            <IconMistOff className="mx-auto mb-3" />
            <span className="text-[14px] leading-normal">{t('No data.')}</span>
          </div>
        )}
      </div>
      <ConversationsSettings />
    </ConversationsContext.Provider>
  );
};
------------------------
./components/Home/components/PrimaryMenu/components/Menu/components/Screens/Conversations/Conversations.state.tsx
import { Conversation } from '@/types/chat';

export interface ConversationsInitialState {
  searchTerm: string;
  filteredConversations: Conversation[];
}

export const initialState: ConversationsInitialState = {
  searchTerm: '',
  filteredConversations: [],
};
------------------------
./components/Home/components/PrimaryMenu/components/Menu/components/Screens/Conversations/components/ClearConversations.tsx
import { IconCheck, IconTrash, IconX } from '@tabler/icons-react';
import { FC, useState } from 'react';

import { useTranslation } from 'next-i18next';

import { SidebarButton } from '@/components/Common/Sidebar/SidebarButton';

interface Props {
  onClearConversations: () => void;
}

export const ClearConversations: FC<Props> = ({ onClearConversations }) => {
  const [isConfirming, setIsConfirming] = useState<boolean>(false);

  const { t } = useTranslation('sidebar');

  const handleClearConversations = () => {
    onClearConversations();
    setIsConfirming(false);
  };

  return isConfirming ? (
    <div className="flex w-full cursor-pointer items-center rounded-lg py-3 px-3 hover:bg-gray-500/10">
      <IconTrash size={18} />

      <div className="ml-3 flex-1 text-left text-[12.5px] leading-3 text-black dark:text-white">
        {t('Are you sure?')}
      </div>

      <div className="flex w-[40px]">
        <IconCheck
          className="ml-auto mr-1 min-w-[20px] text-neutral-400 hover:text-neutral-100"
          size={18}
          onClick={(e) => {
            e.stopPropagation();
            handleClearConversations();
          }}
        />

        <IconX
          className="ml-auto min-w-[20px] text-neutral-400 hover:text-neutral-100"
          size={18}
          onClick={(e) => {
            e.stopPropagation();
            setIsConfirming(false);
          }}
        />
      </div>
    </div>
  ) : (
    <SidebarButton
      text={t('Clear conversations')}
      icon={<IconTrash size={18} />}
      onClick={() => setIsConfirming(true)}
    />
  );
};
------------------------
./components/Home/components/PrimaryMenu/components/Menu/components/Screens/Conversations/components/ConversationList.tsx
import { Conversation } from '@/types/chat';

import { ConversationComponent } from './ConversationComponent';

interface Props {
  conversations: Conversation[];
}

export const ConversationList = ({ conversations }: Props) => {
  return (
    <div className="flex w-full flex-col gap-1">
      {conversations
        .filter((conversation) => !conversation.folderId)
        .slice()
        .reverse()
        .map((conversation, index) => (
          <ConversationComponent key={index} conversation={conversation} />
        ))}
    </div>
  );
};
------------------------
./components/Home/components/PrimaryMenu/components/Menu/components/Screens/Conversations/components/Folders.tsx
import { useContext } from 'react';

import { FolderInterface } from '@/types/folder';

import Folder from '@/components/Common/Folder';
import HomeContext from '@/components/Home/home.context';

import { ConversationComponent } from './ConversationComponent';

interface Props {
  searchTerm: string;
}

export const ConversationsFolders = ({ searchTerm }: Props) => {
  const {
    state: { folders, conversations },
    handleUpdateConversation,
  } = useContext(HomeContext);

  const handleDrop = (e: any, folder: FolderInterface) => {
    if (e.dataTransfer) {
      const conversation = JSON.parse(e.dataTransfer.getData('conversation'));
      handleUpdateConversation(conversation, {
        key: 'folderId',
        value: folder.id,
      });
    }
  };

  const Folders = (currentFolder: FolderInterface) => {
    return (
      conversations &&
      conversations
        .filter((conversation) => conversation.folderId)
        .map((conversation, index) => {
          if (conversation.folderId === currentFolder.id) {
            return (
              <div
                key={index}
                className="ml-5 gap-2 border-l border-theme-button-border-light dark:border-theme-button-border-dark pl-2"
              >
                <ConversationComponent conversation={conversation} />
              </div>
            );
          }
        })
    );
  };

  return (
    <div className="flex w-full flex-col pt-2">
      {folders
        .filter((folder) => folder.type === 'chat')
        .sort((a, b) => a.name.localeCompare(b.name))
        .map((folder, index) => (
          <Folder
            key={index}
            searchTerm={searchTerm}
            currentFolder={folder}
            handleDrop={handleDrop}
            folderComponent={Folders(folder)}
          />
        ))}
    </div>
  );
};
------------------------
./components/Home/components/PrimaryMenu/components/Menu/components/Screens/Conversations/components/ConversationComponent.tsx
import {
  IconCheck,
  IconMessage,
  IconPencil,
  IconTrash,
  IconX,
} from '@tabler/icons-react';
import {
  DragEvent,
  KeyboardEvent,
  MouseEventHandler,
  useContext,
  useEffect,
  useState,
} from 'react';

import { Conversation } from '@/types/chat';

import SidebarActionButton from '@/components/Common/Buttons/SidebarActionButton';
import HomeContext from '@/components/Home/home.context';

import ConversationsContext from '../Conversations.context';

interface Props {
  conversation: Conversation;
}

export const ConversationComponent = ({ conversation }: Props) => {
  const {
    state: { selectedConversation, messageIsStreaming },
    handleSelectConversation,
    handleUpdateConversation,
  } = useContext(HomeContext);

  const { handleDeleteConversation } = useContext(ConversationsContext);

  const [isDeleting, setIsDeleting] = useState(false);
  const [isRenaming, setIsRenaming] = useState(false);
  const [renameValue, setRenameValue] = useState('');

  const handleEnterDown = (e: KeyboardEvent<HTMLDivElement>) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      selectedConversation && handleRename(selectedConversation);
    }
  };

  const handleDragStart = (
    e: DragEvent<HTMLButtonElement>,
    conversation: Conversation,
  ) => {
    if (e.dataTransfer) {
      e.dataTransfer.setData('conversation', JSON.stringify(conversation));
    }
  };

  const handleRename = (conversation: Conversation) => {
    if (renameValue.trim().length > 0) {
      handleUpdateConversation(conversation, {
        key: 'name',
        value: renameValue,
      });
      setRenameValue('');
      setIsRenaming(false);
    }
  };

  const handleConfirm: MouseEventHandler<HTMLButtonElement> = (e) => {
    e.stopPropagation();
    if (isDeleting) {
      handleDeleteConversation(conversation);
    } else if (isRenaming) {
      handleRename(conversation);
    }
    setIsDeleting(false);
    setIsRenaming(false);
  };

  const handleCancel: MouseEventHandler<HTMLButtonElement> = (e) => {
    e.stopPropagation();
    setIsDeleting(false);
    setIsRenaming(false);
  };

  const handleOpenRenameModal: MouseEventHandler<HTMLButtonElement> = (e) => {
    e.stopPropagation();
    setIsRenaming(true);
    selectedConversation && setRenameValue(selectedConversation.name);
  };
  const handleOpenDeleteModal: MouseEventHandler<HTMLButtonElement> = (e) => {
    e.stopPropagation();
    setIsDeleting(true);
  };

  useEffect(() => {
    if (isRenaming) {
      setIsDeleting(false);
    } else if (isDeleting) {
      setIsRenaming(false);
    }
  }, [isRenaming, isDeleting]);

  return (
    <div className="relative flex items-center">
      {isRenaming && selectedConversation?.id === conversation.id ? (
        <div
          className="flex w-full items-center gap-3 rounded-lg text-black dark:text-white
        bg-theme-light dark:bg-theme-dark/90 p-3"
        >
          <IconMessage size={18} />
          <input
            className="mr-12 flex-1 overflow-hidden overflow-ellipsis border-theme-border-light
            dark:border-theme-border-dark bg-transparent text-left text-[12.5px] leading-3 text-black
            dark:text-white outline-none focus:border-neutral-100"
            type="text"
            value={renameValue}
            onChange={(e) => setRenameValue(e.target.value)}
            onKeyDown={handleEnterDown}
            autoFocus
          />
        </div>
      ) : (
        <button
          className={`flex w-full cursor-pointer items-center gap-3 rounded-lg p-3 text-sm transition-colors
          duration-200 text-black dark:text-white ${
            messageIsStreaming ? 'disabled:cursor-not-allowed' : ''
          }
         ${
           !(selectedConversation?.id === conversation.id)
             ? 'hover:bg-theme-hover-light dark:hover:bg-theme-hover-dark'
             : 'bg-theme-selected-light dark:bg-theme-selected-dark'
         }
          `}
          onClick={() => handleSelectConversation(conversation)}
          disabled={messageIsStreaming}
          draggable="true"
          onDragStart={(e) => handleDragStart(e, conversation)}
        >
          <IconMessage size={18} />
          <div
            className={`relative max-h-5 flex-1 overflow-hidden text-ellipsis whitespace-nowrap break-all text-left text-[12.5px] leading-3 ${
              selectedConversation?.id === conversation.id ? 'pr-12' : 'pr-1'
            }`}
          >
            {conversation.name}
          </div>
        </button>
      )}

      {(isDeleting || isRenaming) &&
        selectedConversation?.id === conversation.id && (
          <div className="absolute right-1 z-10 flex">
            <SidebarActionButton handleClick={handleConfirm}>
              <IconCheck size={18} />
            </SidebarActionButton>
            <SidebarActionButton handleClick={handleCancel}>
              <IconX size={18} />
            </SidebarActionButton>
          </div>
        )}

      {selectedConversation?.id === conversation.id &&
        !isDeleting &&
        !isRenaming && (
          <div className="absolute right-1 z-10 flex">
            <SidebarActionButton handleClick={handleOpenRenameModal}>
              <IconPencil size={18} />
            </SidebarActionButton>
            <SidebarActionButton handleClick={handleOpenDeleteModal}>
              <IconTrash size={18} />
            </SidebarActionButton>
          </div>
        )}
    </div>
  );
};
------------------------
./components/Home/components/PrimaryMenu/components/Menu/components/Screens/Conversations/components/ConversationsSettings.tsx
import { IconFileExport, IconLogout, IconSettings } from '@tabler/icons-react';
import { useContext } from 'react';

import { useTranslation } from 'next-i18next';

import { SidebarButton } from '@/components/Common/Sidebar/SidebarButton';
import { Import } from '@/components/Home/components/Settings/Import';
import HomeContext from '@/components/Home/home.context';

import ConversationsContext from '../Conversations.context';
import { ClearConversations } from './ClearConversations';

export const ConversationsSettings = () => {
  const { t } = useTranslation('sidebar');

  const {
    state: { database, conversations },
  } = useContext(HomeContext);

  const {
    handleClearConversations,
    handleImportConversations,
    handleExportData,
  } = useContext(ConversationsContext);

  return (
    <div
      className="flex flex-col items-center space-y-1 border-t
    border-theme-border-light dark:border-theme-border-dark pt-1 text-sm"
    >
      {conversations.length > 0 ? (
        <ClearConversations onClearConversations={handleClearConversations} />
      ) : null}

      <Import onImport={handleImportConversations} />

      {/* <SidebarButton
        text={t('Export data')}
        icon={<IconFileExport size={18} />}
        onClick={() => handleExportData(database!)}
      /> */}
    </div>
  );
};
------------------------
./components/Home/components/PrimaryMenu/components/Menu/components/Screens/Prompts/Prompts.tsx
import { IconFolderPlus, IconMistOff, IconPlus } from '@tabler/icons-react';
import { useContext, useEffect, useState } from 'react';
import { useTranslation } from 'react-i18next';

import { useCreateReducer } from '@/hooks/useCreateReducer';

import {
  storageCreatePrompt,
  storageDeletePrompt,
  storageUpdatePrompt,
} from '@/utils/app/storage/prompt';

import { Prompt } from '@/types/prompt';

import { PromptFolders } from './components/Folders';
import { PromptList } from './components/PromptList';
import { PrimaryButtonAlt } from '@/components/Common/Buttons/PrimaryButton';
import { SecondaryButton } from '@/components/Common/Buttons/SecondaryButton';
import Search from '@/components/Common/Search';
import HomeContext from '@/components/Home/home.context';

import PromptsContext from './Prompts.context';
import { PromptsInitialState, initialState } from './Prompts.state';

import { v4 as uuidv4 } from 'uuid';

const Prompts = () => {
  const { t } = useTranslation('promptbar');

  const promptBarContextValue = useCreateReducer<PromptsInitialState>({
    initialState,
  });

  const {
    state: { prompts, database, user },
    dispatch: homeDispatch,
    handleCreateFolder,
  } = useContext(HomeContext);

  const {
    state: { searchTerm, filteredPrompts },
    dispatch: promptDispatch,
  } = promptBarContextValue;

  const handleCreatePrompt = () => {
    const newPrompt: Prompt = {
      id: uuidv4(),
      name: `Template ${prompts.length + 1}`,
      description: '',
      content: '',
      models: [],
      folderId: null,
    };

    const updatedPrompts = storageCreatePrompt(
      database!,
      user!,
      newPrompt,
      prompts,
    );

    homeDispatch({ field: 'prompts', value: updatedPrompts });
  };

  const handleDeletePrompt = (prompt: Prompt) => {
    const updatedPrompts = storageDeletePrompt(
      database!,
      user!,
      prompt.id,
      prompts,
    );
    homeDispatch({ field: 'prompts', value: updatedPrompts });
  };

  const handleUpdatePrompt = (prompt: Prompt) => {
    const updated = storageUpdatePrompt(database!, user!, prompt, prompts);

    homeDispatch({ field: 'prompts', value: updated.all });
  };

  const handleDrop = (e: any) => {
    if (e.dataTransfer) {
      const prompt = JSON.parse(e.dataTransfer.getData('prompt'));

      const updatedPrompt = {
        ...prompt,
        folderId: e.target.dataset.folderId,
      };

      handleUpdatePrompt(updatedPrompt);

      e.target.style.background = 'none';
    }
  };

  useEffect(() => {
    if (searchTerm) {
      promptDispatch({
        field: 'filteredPrompts',
        value: prompts.filter((prompt) => {
          const searchable =
            prompt.name.toLowerCase() +
            ' ' +
            prompt.description.toLowerCase() +
            ' ' +
            prompt.content.toLowerCase();
          return searchable.includes(searchTerm.toLowerCase());
        }),
      });
    } else {
      promptDispatch({ field: 'filteredPrompts', value: prompts });
    }
  }, [searchTerm, prompts, promptDispatch]);

  const allowDrop = (e: any) => {
    e.preventDefault();
  };

  const highlightDrop = (e: any) => {
    e.target.style.background = '#343541';
  };

  const removeHighlight = (e: any) => {
    e.target.style.background = 'none';
  };

  const doSearch = (term: string) =>
    promptDispatch({ field: 'searchTerm', value: term });

  const createFolder = () => handleCreateFolder(t('New folder'), 'prompt');

  return (
    <PromptsContext.Provider
      value={{
        ...promptBarContextValue,
        handleCreatePrompt,
        handleDeletePrompt,
        handleUpdatePrompt,
      }}
    >
      <div className="flex items-center gap-x-2">
        <PrimaryButtonAlt
          onClick={() => {
            handleCreatePrompt();
            doSearch('');
          }}
        >
          {t('New message template')}
        </PrimaryButtonAlt>

        <SecondaryButton onClick={createFolder}>
          <IconFolderPlus size={16} />
        </SecondaryButton>
      </div>
      <Search
        placeholder={t('Search...') || ''}
        searchTerm={searchTerm}
        onSearch={doSearch}
      />

      <div className="flex-grow overflow-auto">
        {filteredPrompts?.length > 0 && (
          <div
            className="flex border-b pb-2
          border-theme-button-border-light dark:border-theme-button-border-dark"
          >
            <PromptFolders />
          </div>
        )}

        {filteredPrompts?.length > 0 ? (
          <div
            className="pt-2"
            onDrop={handleDrop}
            onDragOver={allowDrop}
            onDragEnter={highlightDrop}
            onDragLeave={removeHighlight}
          >
            <PromptList
              prompts={filteredPrompts.filter((prompt) => !prompt.folderId)}
            />
          </div>
        ) : (
          <div className="mt-8 select-none text-center text-black dark:text-white opacity-50">
            <IconMistOff className="mx-auto mb-3" />
            <span className="text-[14px] leading-normal">{t('No data.')}</span>
          </div>
        )}
      </div>
    </PromptsContext.Provider>
  );
};

export default Prompts;
------------------------
./components/Home/components/PrimaryMenu/components/Menu/components/Screens/Prompts/components/Folders.tsx
import { useContext } from 'react';

import { FolderInterface } from '@/types/folder';

import Folder from '@/components/Common/Folder';
import HomeContext from '@/components/Home/home.context';

import PromptsContext from '../Prompts.context';
import { PromptComponent } from './PromptComponent';

export const PromptFolders = () => {
  const {
    state: { folders },
  } = useContext(HomeContext);

  const {
    state: { searchTerm, filteredPrompts },
    handleUpdatePrompt,
  } = useContext(PromptsContext);

  const handleDrop = (e: any, folder: FolderInterface) => {
    if (e.dataTransfer) {
      const prompt = JSON.parse(e.dataTransfer.getData('prompt'));

      const updatedPrompt = {
        ...prompt,
        folderId: folder.id,
      };

      handleUpdatePrompt(updatedPrompt);
    }
  };

  const Folders = (currentFolder: FolderInterface) =>
    filteredPrompts
      .filter((p) => p.folderId)
      .map((prompt, index) => {
        if (prompt.folderId === currentFolder.id) {
          return (
            <div
              key={index}
              className="ml-5 gap-2 border-l border-theme-button-border-light dark:border-theme-button-border-dark pl-2"
            >
              <PromptComponent prompt={prompt} />
            </div>
          );
        }
      });

  return (
    <div className="flex w-full flex-col pt-2">
      {folders
        .filter((folder) => folder.type === 'prompt')
        .sort((a, b) => a.name.localeCompare(b.name))
        .map((folder, index) => (
          <Folder
            key={index}
            searchTerm={searchTerm}
            currentFolder={folder}
            handleDrop={handleDrop}
            folderComponent={Folders(folder)}
          />
        ))}
    </div>
  );
};
------------------------
./components/Home/components/PrimaryMenu/components/Menu/components/Screens/Prompts/components/PromptComponent.tsx
import {
  IconBulbFilled,
  IconCheck,
  IconTrash,
  IconX,
} from '@tabler/icons-react';
import {
  DragEvent,
  MouseEventHandler,
  useContext,
  useEffect,
  useState,
} from 'react';

import { Prompt } from '@/types/prompt';

import SidebarActionButton from '@/components/Common/Buttons/SidebarActionButton';

import PromptsContext from '../Prompts.context';
import { PromptModal } from './PromptModal';

interface Props {
  prompt: Prompt;
}

export const PromptComponent = ({ prompt }: Props) => {
  const {
    dispatch: promptDispatch,
    handleUpdatePrompt,
    handleDeletePrompt,
  } = useContext(PromptsContext);

  const [showModal, setShowModal] = useState<boolean>(false);
  const [isDeleting, setIsDeleting] = useState(false);
  const [isRenaming, setIsRenaming] = useState(false);
  const [renameValue, setRenameValue] = useState('');

  const handleUpdate = (prompt: Prompt) => {
    handleUpdatePrompt(prompt);
    promptDispatch({ field: 'searchTerm', value: '' });
  };

  const handleDelete: MouseEventHandler<HTMLButtonElement> = (e) => {
    e.stopPropagation();

    if (isDeleting) {
      handleDeletePrompt(prompt);
      promptDispatch({ field: 'searchTerm', value: '' });
    }

    setIsDeleting(false);
  };

  const handleCancelDelete: MouseEventHandler<HTMLButtonElement> = (e) => {
    e.stopPropagation();
    setIsDeleting(false);
  };

  const handleOpenDeleteModal: MouseEventHandler<HTMLButtonElement> = (e) => {
    e.stopPropagation();
    setIsDeleting(true);
  };

  const handleDragStart = (e: DragEvent<HTMLButtonElement>, prompt: Prompt) => {
    if (e.dataTransfer) {
      e.dataTransfer.setData('prompt', JSON.stringify(prompt));
    }
  };

  useEffect(() => {
    if (isRenaming) {
      setIsDeleting(false);
    } else if (isDeleting) {
      setIsRenaming(false);
    }
  }, [isRenaming, isDeleting]);

  return (
    <div className="relative flex items-center">
      <button
        className="flex w-full cursor-pointer items-center gap-3 rounded-lg p-3 text-sm transition-colors
         duration-200 text-black dark:text-white hover:bg-theme-hover-light dark:hover:bg-theme-hover-dark"
        draggable="true"
        onClick={(e) => {
          e.stopPropagation();
          setShowModal(true);
        }}
        onDragStart={(e) => handleDragStart(e, prompt)}
        onMouseLeave={() => {
          setIsDeleting(false);
          setIsRenaming(false);
          setRenameValue('');
        }}
      >
        <IconBulbFilled size={18} />

        <div
          className="relative max-h-5 flex-1 overflow-hidden text-ellipsis whitespace-nowrap
        break-all pr-4 text-left text-[12.5px] leading-3"
        >
          {prompt.name}
        </div>
      </button>

      {(isDeleting || isRenaming) && (
        <div
          className="absolute right-1 z-10 flex
        hover:text-theme-button-icon-hover-light dark:hover:text-theme-button-icon-hover-dark"
        >
          <SidebarActionButton handleClick={handleDelete}>
            <IconCheck size={18} />
          </SidebarActionButton>

          <SidebarActionButton handleClick={handleCancelDelete}>
            <IconX size={18} />
          </SidebarActionButton>
        </div>
      )}

      {!isDeleting && !isRenaming && (
        <div
          className="absolute right-1 z-10 flex
        hover:text-theme-button-icon-hover-light dark:hover:text-theme-button-icon-hover-dark"
        >
          <SidebarActionButton handleClick={handleOpenDeleteModal}>
            <IconTrash size={18} />
          </SidebarActionButton>
        </div>
      )}

      {showModal && (
        <PromptModal
          prompt={prompt}
          onClose={() => setShowModal(false)}
          onUpdatePrompt={handleUpdate}
        />
      )}
    </div>
  );
};
------------------------
./components/Home/components/PrimaryMenu/components/Menu/components/Screens/Prompts/components/PromptModal.tsx
import { FC, KeyboardEvent, useEffect, useRef, useState } from 'react';

import { useTranslation } from 'next-i18next';

import { Prompt } from '@/types/prompt';

import { PrimaryButtonAlt } from '@/components/Common/Buttons/PrimaryButton';

interface Props {
  prompt: Prompt;
  onClose: () => void;
  onUpdatePrompt: (prompt: Prompt) => void;
}

export const PromptModal: FC<Props> = ({ prompt, onClose, onUpdatePrompt }) => {
  const { t } = useTranslation('promptbar');
  const [name, setName] = useState(prompt.name);
  const [description, setDescription] = useState(prompt.description);
  const [content, setContent] = useState(prompt.content);

  const modalRef = useRef<HTMLDivElement>(null);
  const nameInputRef = useRef<HTMLInputElement>(null);

  const handleEnter = (e: KeyboardEvent<HTMLDivElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      onUpdatePrompt({ ...prompt, name, description, content: content.trim() });
      onClose();
    }
  };

  useEffect(() => {
    const handleMouseDown = (e: MouseEvent) => {
      if (modalRef.current && !modalRef.current.contains(e.target as Node)) {
        window.addEventListener('mouseup', handleMouseUp);
      }
    };

    const handleMouseUp = (e: MouseEvent) => {
      window.removeEventListener('mouseup', handleMouseUp);
      onClose();
    };

    window.addEventListener('mousedown', handleMouseDown);

    return () => {
      window.removeEventListener('mousedown', handleMouseDown);
    };
  }, [onClose]);

  useEffect(() => {
    nameInputRef.current?.focus();
  }, []);

  return (
    <div
      className="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50"
      onKeyDown={handleEnter}
    >
      <div className="fixed inset-0 z-10 overflow-hidden">
        <div className="flex items-center justify-center min-h-screen px-4 pt-4 pb-20 text-center sm:block sm:p-0">
          <div
            className="hidden sm:inline-block sm:h-screen sm:align-middle"
            aria-hidden="true"
          />

          <div
            ref={modalRef}
            className="dark:border-netural-400 inline-block max-h-[400px] transform overflow-y-auto rounded-lg border border-gray-300 bg-white px-4 pt-5 pb-4 text-left align-bottom shadow-xl transition-all dark:bg-[#202123] sm:my-8 sm:max-h-[600px] sm:w-full sm:max-w-lg sm:p-6 sm:align-middle"
            role="dialog"
          >
            <div className="text-sm font-bold text-black dark:text-neutral-200">
              {t('Name')}
            </div>
            <input
              ref={nameInputRef}
              className="mt-2 w-full rounded-lg border border-neutral-500 px-4 py-2 text-neutral-900 shadow focus:outline-none dark:border-neutral-800 dark:border-opacity-50 dark:bg-[#40414F] dark:text-neutral-100"
              placeholder={t('A name for your prompt.') || ''}
              value={name}
              onChange={(e) => setName(e.target.value)}
            />

            <div className="mt-6 text-sm font-bold text-black dark:text-neutral-200">
              {t('Description')}
            </div>
            <textarea
              className="mt-2 w-full rounded-lg border border-neutral-500 px-4 py-2 text-neutral-900 shadow focus:outline-none dark:border-neutral-800 dark:border-opacity-50 dark:bg-[#40414F] dark:text-neutral-100"
              style={{ resize: 'none' }}
              placeholder={t('A description for your prompt.') || ''}
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              rows={3}
            />

            <div className="mt-6 text-sm font-bold text-black dark:text-neutral-200">
              {t('Prompt')}
            </div>
            <textarea
              className="mt-2 mb-4 w-full rounded-lg border border-neutral-500 px-4 py-2 text-neutral-900 shadow focus:outline-none dark:border-neutral-800 dark:border-opacity-50 dark:bg-[#40414F] dark:text-neutral-100"
              style={{ resize: 'none' }}
              placeholder={
                t(
                  'Prompt content. Use {{}} to denote a variable. Ex: {{name}} is a {{adjective}} {{noun}}',
                ) || ''
              }
              value={content}
              onChange={(e) => setContent(e.target.value)}
              rows={10}
            />

            <PrimaryButtonAlt
              onClick={() => {
                const updatedPrompt = {
                  ...prompt,
                  name,
                  description,
                  content: content.trim(),
                };

                onUpdatePrompt(updatedPrompt);
                onClose();
              }}
            >
              {t('Save')}
            </PrimaryButtonAlt>
          </div>
        </div>
      </div>
    </div>
  );
};
------------------------
./components/Home/components/PrimaryMenu/components/Menu/components/Screens/Prompts/components/PromptList.tsx
import { FC } from 'react';

import { Prompt } from '@/types/prompt';

import { PromptComponent } from './PromptComponent';

interface Props {
  prompts: Prompt[];
}

export const PromptList: FC<Props> = ({ prompts }) => {
  return (
    <div className="flex w-full flex-col gap-1">
      {prompts
        .slice()
        .reverse()
        .map((prompt, index) => (
          <PromptComponent key={index} prompt={prompt} />
        ))}
    </div>
  );
};
------------------------
./components/Home/components/PrimaryMenu/components/Menu/components/Screens/Prompts/components/PromptbarSettings.tsx
import { FC } from 'react';

interface Props {}

export const PromptbarSettings: FC<Props> = () => {
  return <div></div>;
};
------------------------
./components/Home/components/PrimaryMenu/components/Menu/components/Screens/Prompts/Prompts.context.tsx
import { Dispatch, createContext } from 'react';

import { ActionType } from '@/hooks/useCreateReducer';

import { Prompt } from '@/types/prompt';

import { PromptsInitialState } from './Prompts.state';

export interface PromptsContextProps {
  state: PromptsInitialState;
  dispatch: Dispatch<ActionType<PromptsInitialState>>;
  handleCreatePrompt: () => void;
  handleDeletePrompt: (prompt: Prompt) => void;
  handleUpdatePrompt: (prompt: Prompt) => void;
}

const PromptsContext = createContext<PromptsContextProps>(undefined!);

export default PromptsContext;
------------------------
./components/Home/components/PrimaryMenu/components/Menu/components/Screens/Prompts/Prompts.state.tsx
import { Prompt } from '@/types/prompt';

export interface PromptsInitialState {
  searchTerm: string;
  filteredPrompts: Prompt[];
}

export const initialState: PromptsInitialState = {
  searchTerm: '',
  filteredPrompts: [],
};
------------------------
./components/Home/components/PrimaryMenu/components/Menu/Menu.tsx
import { useContext } from 'react';

import HomeContext from '@/components/Home/home.context';

import PrimaryMenuContext from '../../PrimaryMenu.context';

const Menu = ({ screens }: { screens: JSX.Element[] }) => {
  const {
    state: { showPrimaryMenu, showSecondaryMenu },
    dispatch: homeDispatch,
  } = useContext(HomeContext);

  const {
    state: { selectedIndex },
  } = useContext(PrimaryMenuContext);

  const selectedScreen = screens[selectedIndex];

  return (
    <>
      <div
        className={`relative sm:w-[280px] h-full z-40 ${
          !showPrimaryMenu ? 'hidden' : 'left-[0] w-full'
        } flex flex-col space-y-2 bg-theme-primary-menu-light dark:bg-theme-primary-menu-dark p-2 
        text-[14px] transition-all sm:relative sm:top-0 border-theme-border-light
        dark:border-theme-border-dark sm:border-r`}
      >
        {selectedScreen}
      </div>
    </>
  );
};

export default Menu;
------------------------
./components/Home/components/PrimaryMenu/components/ActivityBar/components/ActivityBarButton.tsx
export const ActivityBarButton = ({
  children,
  handleClick,
}: {
  children: JSX.Element;
  handleClick?: () => void;
}) => {
  return (
    <>
      <button
        className="text-theme-activity-bar-tab-light dark:text-theme-activity-bar-tab-dark
        hover:text-theme-activity-bar-tab-hover-light dark:hover:text-theme-activity-bar-tab-hover-dark"
        onClick={handleClick}
      >
        {children}
      </button>
    </>
  );
};
------------------------
./components/Home/components/PrimaryMenu/components/ActivityBar/components/ActivityBarTab.tsx
export const ActivityBarTab = ({
  children,
  index,
  isSelected,
  handleSelect,
}: {
  children: JSX.Element;
  index: number;
  isSelected: boolean;
  handleSelect: (index: number) => void;
}) => {
  return (
    <>
      <button
        className={`py-3 ${
          isSelected
            ? 'text-theme-activity-bar-tab-selected-light dark:text-theme-activity-bar-tab-selected-dark'
            : 'text-theme-activity-bar-tab-light dark:text-theme-activity-bar-tab-dark'
        } ${
          isSelected
            ? ''
            : 'hover:text-theme-activity-bar-tab-hover-light dark:hover:text-theme-activity-bar-tab-hover-dark'
        }`}
        onClick={() => handleSelect(index)}
      >
        {children}
      </button>
    </>
  );
};
------------------------
./components/Home/components/PrimaryMenu/components/ActivityBar/ActivityBar.tsx
import {
  IconBrandDiscord,
  IconBrandGithub,
  IconLogout,
  IconSettings,
} from '@tabler/icons-react';
import { signOut } from 'next-auth/react';
import { useContext, useState } from 'react';

import { deleteSelectedConversation } from '@/utils/app/storage/selectedConversation';

import { ActivityBarButton } from './components/ActivityBarButton';
import { ActivityBarTab } from './components/ActivityBarTab';
import HomeContext from '@/components/Home/home.context';

import PrimaryMenuContext from '../../PrimaryMenu.context';

const ActivityBar = ({ icons }: { icons: JSX.Element[] }) => {
  const {
    state: { user, database, showPrimaryMenu, display },
    dispatch: homeDispatch,
  } = useContext(HomeContext);

  const {
    state: { selectedIndex },
    dispatch: primaryMenuDispatch,
  } = useContext(PrimaryMenuContext);

  const handleSelect = (index: number) => {
    if (selectedIndex === index) {
      homeDispatch({ field: 'showPrimaryMenu', value: !showPrimaryMenu });
    }

    if (!showPrimaryMenu) {
      homeDispatch({ field: 'showPrimaryMenu', value: !showPrimaryMenu });
    }
    primaryMenuDispatch({ field: 'selectedIndex', value: index });
  };

  const handleSignOut = () => {
    if (database!.name !== 'local') {
      deleteSelectedConversation(user!);
    }

    signOut();
  };

  const handleShowSettings = () => {
    if (display !== 'settings') {
      homeDispatch({ field: 'display', value: 'settings' });
    } else {
      if (window.innerWidth < 640) {
        homeDispatch({ field: 'showPrimaryMenu', value: false });
      } else {
        homeDispatch({ field: 'display', value: 'chat' });
      }
    }
  };

  // VS Code Activity Bar with tabs at the top and setting button at the bottom
  return (
    <div
      className={`relative border-r border-theme-border-light dark:border-theme-border-dark top-0 z-40 flex h-full w-[48px] flex-none flex-col
          ${showPrimaryMenu ? 'left-[0]' : 'hidden sm:flex'}
          space-y-6 bg-theme-activity-bar-light dark:bg-theme-activity-bar-dark items-center align-middle py-4 text-[14px] transition-all sm:relative sm:top-0
          sm:left-[0]
          justify-between`}
    >
      {/* Tabs aligns to top */}
      <div className="flex flex-col items-center">
        {icons.map((icon, index) => (
          <ActivityBarTab
            handleSelect={handleSelect}
            isSelected={index === selectedIndex}
            index={index}
            key={index}
          >
            {icon}
          </ActivityBarTab>
        ))}
      </div>

      {/* Settings buttons align to bottom */}
      <div className="flex flex-col items-center space-y-6">
        
        
        <ActivityBarButton handleClick={handleSignOut}>
          <IconLogout size={28} />
        </ActivityBarButton>
        <ActivityBarButton handleClick={handleShowSettings}>
          <IconSettings size={28} />
        </ActivityBarButton>
      </div>
    </div>
  );
};

export default ActivityBar;
------------------------
./components/Home/components/PrimaryMenu/PrimaryMenu.state.tsx
export interface PrimaryMenuInitialState {
  selectedIndex: number;
}

export const initialState: PrimaryMenuInitialState = {
  selectedIndex: 0,
};
------------------------
./components/Home/components/Mobile/Navbar.tsx
import { IconPlus } from '@tabler/icons-react';
import { FC, useContext } from 'react';

import {
  localSaveShowPrimaryMenu,
  localSaveShowSecondaryMenu,
} from '@/utils/app/storage/local/uiState';

import { Conversation } from '@/types/chat';

import {
  PrimaryMenuOpener,
  SecondaryMenuOpener,
} from '../../../Common/Sidebar/components/OpenCloseButton';
import HomeContext from '@/components/Home/home.context';

interface Props {
  selectedConversation: Conversation;
  onNewConversation: () => void;
}

export const Navbar: FC<Props> = ({
  selectedConversation,
  onNewConversation,
}) => {
  const {
    state: { showPrimaryMenu, showSecondaryMenu, user },
    dispatch: homeDispatch,
  } = useContext(HomeContext);

  const handleShowPrimaryMenu = () => {
    if (!showPrimaryMenu) {
      homeDispatch({ field: 'showPrimaryMenu', value: true });
      homeDispatch({ field: 'showSecondaryMenu', value: false });
    } else {
      homeDispatch({ field: 'showPrimaryMenu', value: false });
    }
    localSaveShowPrimaryMenu(user!, showPrimaryMenu);
  };

  const handleShowSecondaryMenu = () => {
    if (!showSecondaryMenu) {
      homeDispatch({ field: 'showPrimaryMenu', value: false });
      homeDispatch({ field: 'showSecondaryMenu', value: true });
    } else {
      homeDispatch({ field: 'showSecondaryMenu', value: false });
    }
    localSaveShowSecondaryMenu(user!, showSecondaryMenu);
  };

  return (
    <nav className="h-[50px] bg-[#efefef] dark:bg-[#202123] flex w-full justify-between py-3 px-4">
      {' '}
      <PrimaryMenuOpener
        visible={true}
        onClick={handleShowPrimaryMenu}
        open={showPrimaryMenu}
      />
      <div className="flex w-full justify-between px-8">
        <div
          className="left-[100px] text-black dark:text-white max-w-[280px]
        overflow-hidden text-ellipsis whitespace-nowrap"
        >
          {selectedConversation.name}
        </div>
        <IconPlus
          className="cursor-pointer hover:text-neutral-500 dark:hover:text-neutral-400
          text-black dark:text-white"
          onClick={onNewConversation}
        />
      </div>
      <SecondaryMenuOpener
        visible={true}
        onClick={handleShowSecondaryMenu}
        open={showSecondaryMenu}
      />
    </nav>
  );
};
------------------------
./components/Home/components/SecondaryMenu/SecondaryMenu.tsx
import { IconAdjustments, IconBrain, IconPlug } from '@tabler/icons-react';

import { useCreateReducer } from '@/hooks/useCreateReducer';

import ActivityBar from './components/ActivityBar/ActivityBar';
import Menu from './components/Menu/Menu';
import { ModelSettings } from './components/Menu/components/Screens/ModelSettings/ModelSettings';

import SecondaryMenuContext from './SecondaryMenu.context';
import { SecondaryMenuInitialState, initialState } from './SecondaryMenu.state';

export const SecondaryMenu = () => {
  const secondaryMenuContextValue = useCreateReducer<SecondaryMenuInitialState>(
    {
      initialState,
    },
  );

  const icons = [<IconAdjustments size={28} key={0} />];

  const screens = [<ModelSettings key={0} />];

  return (
    <SecondaryMenuContext.Provider value={secondaryMenuContextValue}>
      <Menu screens={screens} />
      <ActivityBar icons={icons} />
    </SecondaryMenuContext.Provider>
  );
};
------------------------
./components/Home/components/SecondaryMenu/SecondaryMenu.state.tsx
export interface SecondaryMenuInitialState {
  selectedIndex: number;
}

export const initialState: SecondaryMenuInitialState = {
  selectedIndex: 0,
};
------------------------
./components/Home/components/SecondaryMenu/components/Menu/components/Screens/ModelSettings/components/ModelSelect.tsx
import { useContext } from 'react';

import { AiModel, PossibleAiModels } from '@/types/ai-models';

import HomeContext from '@/components/Home/home.context';

export const ModelSelect = () => {
  const {
    state: { selectedConversation, models, defaultModelId },
    handleUpdateConversation,
  } = useContext(HomeContext);

  const handleChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const model_id = e.target.value as string;
    const model: AiModel = PossibleAiModels[model_id];
    selectedConversation &&
      handleUpdateConversation(selectedConversation, {
        key: 'model',
        value: model,
      });
  };

  return (
    <div
      className="
      w-full rounded-sm 
      bg-transparent text-white
      bg-gradient-to-r from-black-600 via-violet-900 to-indigo-500
      dark:from-black-500 dark:via-violet-600 dark:to-indigo-400
      bg-175% animate-bg-pan-slow appearance-none dark:bg-gray-700 hover:opacity-90
      "
    >
      <select
        className="text-left w-full bg-transparent p-1 text-sm"
        value={selectedConversation?.model?.id || defaultModelId}
        onChange={handleChange}
      >
        {models.map((model) => (
          <option
            key={model.id}
            value={model.id}
            className="bg-theme-primary-menu-light dark:bg-theme-primary-menu-dark text-black dark:text-white"
          >
            {model.id}
          </option>
        ))}
      </select>
    </div>
  );
};
------------------------
./components/Home/components/SecondaryMenu/components/Menu/components/Screens/ModelSettings/components/SystemPromptSelect.tsx
import { useCallback, useContext, useEffect, useState } from 'react';

import { PossibleAiModels } from '@/types/ai-models';
import { SystemPrompt } from '@/types/system-prompt';

import HomeContext from '@/components/Home/home.context';

export const SystemPromptSelect = () => {
  const {
    state: { selectedConversation, systemPrompts, builtInSystemPrompts },
    handleUpdateConversation,
  } = useContext(HomeContext);

  const [availableSystemPrompts, setAvailableSystemPrompts] = useState<
    SystemPrompt[]
  >([]);
  const [defaultSystemPromptId, setDefaultSystemPromptId] = useState<
    string | null
  >(null);
  const [currentSystemPromptId, setCurrentSystemPromptId] = useState<string>(
    selectedConversation!.model?.vendor,
  );

  useEffect(() => {
    if (selectedConversation && selectedConversation.systemPrompt) {
      setCurrentSystemPromptId(selectedConversation.systemPrompt.id);
    } else {
      setCurrentSystemPromptId(defaultSystemPromptId!);
    }
  }, [selectedConversation, defaultSystemPromptId]);

  const getDefaultSystemPrompt = useCallback(() => {
    let model = selectedConversation!.model;

    if (!model || model.vendor === undefined) {
      selectedConversation!.model = PossibleAiModels['gpt-3.5-turbo'];
      model = selectedConversation!.model;
    }

    // const sectionId = model.vendor.toLocaleLowerCase();
    // const settingId = `${model.id}_default_system_prompt`;

    // let systemPromptId = getSavedSettingValue(
    //   savedSettings,
    //   sectionId,
    //   settingId,
    //   settings,
    // );

    let systemPromptId = null;

    if (!systemPromptId && builtInSystemPrompts.length > 0) {
      systemPromptId = builtInSystemPrompts.filter(
        (prompt) => prompt.name === `${model?.vendor} Built-In`,
      )[0].id;
    }

    setDefaultSystemPromptId(systemPromptId);
  }, [selectedConversation, builtInSystemPrompts]);

  useEffect(() => {
    getDefaultSystemPrompt();
  }, [availableSystemPrompts, getDefaultSystemPrompt, builtInSystemPrompts]);

  const getAvailableSystemPrompts = useCallback(() => {
    const model = selectedConversation!.model;

    const availablePrompts = systemPrompts.filter((prompt) =>
      prompt.models.includes(model.id),
    );

    const defaultSystemPrompt = builtInSystemPrompts.filter(
      (prompt) => prompt.name === `${model?.vendor} Built-In`,
    )[0];

    if (defaultSystemPrompt) {
      availablePrompts.push(defaultSystemPrompt);
    }

    setAvailableSystemPrompts(availablePrompts);
  }, [selectedConversation, systemPrompts, builtInSystemPrompts]);

  useEffect(() => {
    if (systemPrompts) {
      getAvailableSystemPrompts();
    }
  }, [
    selectedConversation,
    systemPrompts,
    getAvailableSystemPrompts,
    builtInSystemPrompts,
  ]);

  const handleChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const systemPrompt =
      systemPrompts.filter((prompt) => prompt.id === e.target.value)[0] || null;

    selectedConversation &&
      handleUpdateConversation(selectedConversation, {
        key: 'systemPrompt',
        value: systemPrompt,
      });
  };

  return (
    <div
      className="
      w-full rounded-sm
      bg-transparent text-white
      bg-gradient-to-r from-black-600 via-violet-900 to-indigo-500
      dark:from-black-500 dark:via-violet-600 dark:to-indigo-400
      bg-175% animate-bg-pan-slow appearance-none dark:bg-gray-700 hover:opacity-90
      "
    >
      <select
        className="text-left w-full bg-transparent p-1 text-sm"
        value={currentSystemPromptId || ''}
        onChange={handleChange}
      >
        {availableSystemPrompts.map((prompt) => (
          <option
            key={prompt.id}
            value={prompt.id}
            className="bg-theme-primary-menu-light dark:bg-theme-primary-menu-dark text-black dark:text-white"
          >
            {prompt.id === defaultSystemPromptId
              ? `Default (${prompt.name})`
              : prompt.name}
          </option>
        ))}
      </select>
    </div>
  );
};
------------------------
./components/Home/components/SecondaryMenu/components/Menu/components/Screens/ModelSettings/components/Temperature.tsx
import { FC, useContext, useState } from 'react';

import { useTranslation } from 'next-i18next';

import { DEFAULT_TEMPERATURE } from '@/utils/app/const';

import HomeContext from '@/components/Home/home.context';

export const TemperatureSlider = () => {
  const { t } = useTranslation('chat');
  const {
    state: { selectedConversation },
    handleUpdateConversation,
  } = useContext(HomeContext);
  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = parseFloat(event.target.value);
    if (selectedConversation) {
      handleUpdateConversation(selectedConversation, {
        key: 'temperature',
        value: newValue,
      });
    }
  };

  return (
    <div className="flex flex-col">
      <span className="mb-1 text-center text-neutral-900 dark:text-neutral-100">
        {selectedConversation?.temperature.toFixed(1)}
      </span>
      <input
        className="w-full h-1 bg-gradient-to-r from-black-600 via-violet-900 to-indigo-500
        dark:from-black-500 dark:via-violet-600 dark:to-indigo-400
        bg-175% animate-bg-pan-fast rounded-lg appearance-none cursor-pointer dark:bg-gray-700"
        type="range"
        min={0}
        max={1}
        step={0.1}
        value={selectedConversation?.temperature ?? DEFAULT_TEMPERATURE}
        onChange={handleChange}
      />
      <ul className="w mt-2 pb-8 flex justify-between px-[24px] text-neutral-900 dark:text-neutral-100">
        <li className="flex justify-center">
          <span className="absolute">{t('Precise')}</span>
        </li>
        <li className="flex justify-center">
          <span className="absolute">{t('Neutral')}</span>
        </li>
        <li className="flex justify-center">
          <span className="absolute">{t('Creative')}</span>
        </li>
      </ul>
    </div>
  );
};
------------------------
./components/Home/components/SecondaryMenu/components/Menu/components/Screens/ModelSettings/components/InfoTooltip.tsx
import * as Tooltip from '@radix-ui/react-tooltip';
import { IconInfoCircle } from '@tabler/icons-react';

export const InfoTooltip = ({ children }: any) => {
  return (
    <Tooltip.Provider>
      <Tooltip.Root>
        <Tooltip.Trigger asChild>
          <button
            className="shadow-sm inline-flex items-center justify-center
          rounded-full outline-none focus:shadow-black"
          >
            <IconInfoCircle height={18} width={18} className="ml-1" />
          </button>
        </Tooltip.Trigger>
        <Tooltip.Portal>
          <Tooltip.Content
            className="z-50 max-w-sm data-[state=delayed-open]:data-[side=top]:animate-slideDownAndFade
            data-[state=delayed-open]:data-[side=right]:animate-slideLeftAndFade 
            data-[state=delayed-open]:data-[side=left]:animate-slideRightAndFade 
            data-[state=delayed-open]:data-[side=bottom]:animate-slideUpAndFade 
            select-none rounded-[4px] px-[15px] py-[10px] 
            text-[15px] leading-none will-change-[transform,opacity]
            bg-theme-tooltip-light dark:bg-theme-tooltip-dark"
            sideOffset={5}
          >
            {children}
            <Tooltip.Arrow className="fill-theme-tooltip-light dark:fill-theme-tooltip-dark" />
          </Tooltip.Content>
        </Tooltip.Portal>
      </Tooltip.Root>
    </Tooltip.Provider>
  );
};
------------------------
./components/Home/components/SecondaryMenu/components/Menu/components/Screens/ModelSettings/ModelSettings.tsx
import { useTranslation } from 'react-i18next';

import { ModelSelect } from './components/ModelSelect';
import { SystemPromptSelect } from './components/SystemPromptSelect';
import { TemperatureSlider } from './components/Temperature';
import { PrimaryLabel } from '@/components/Common/Labels/PrimaryLabel';

export const ModelSettings = () => {
  const { t } = useTranslation('modelSettings');

  return (
    <div className="pt-2 px-1 space-y-1">
      <PrimaryLabel tip={t('The model used for this conversation')}>
        {t('Model')}
      </PrimaryLabel>
      <ModelSelect />

      <PrimaryLabel tip={t('The system prompt to use when sending a message')}>
        {t('System Prompt')}
      </PrimaryLabel>
      <SystemPromptSelect />

      <PrimaryLabel
        tip={t(
          'Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.',
        )}
      >
        {t('Temperature')}
      </PrimaryLabel>
      <TemperatureSlider />
    </div>
  );
};
------------------------
./components/Home/components/SecondaryMenu/components/Menu/Menu.tsx
import { useContext } from 'react';

import HomeContext from '@/components/Home/home.context';

import SecondaryMenuContext from '../../SecondaryMenu.context';

const Menu = ({ screens }: { screens: JSX.Element[] }) => {
  const {
    state: { showSecondaryMenu },
  } = useContext(HomeContext);

  const {
    state: { selectedIndex },
  } = useContext(SecondaryMenuContext);

  const selectedScreen = screens[selectedIndex];

  return (
    <div
      className={`relative sm:w-[280px] h-full z-30 ${
        !showSecondaryMenu ? 'hidden' : 'right-[0] w-full'
      } flex flex-col bg-theme-primary-menu-light dark:bg-theme-primary-menu-dark p-2 
        text-[14px] transition-all sm:relative sm:top-0 border-theme-border-light
        dark:border-theme-border-dark sm:border-l`}
    >
      {selectedScreen}
    </div>
  );
};

export default Menu;
------------------------
./components/Home/components/SecondaryMenu/components/ActivityBar/components/ActivityBarButton.tsx
export const ActivityBarButton = ({
  children,
  handleClick,
}: {
  children: JSX.Element;
  handleClick: () => void;
}) => {
  return (
    <>
      <button
        className="text-theme-activity-bar-tab-light dark:text-theme-activity-bar-tab-dark
        hover:text-theme-activity-bar-tab-hover-light dark:hover:text-theme-activity-bar-tab-hover-dark"
        onClick={handleClick}
      >
        {children}
      </button>
    </>
  );
};
------------------------
./components/Home/components/SecondaryMenu/components/ActivityBar/components/ActivityBarTab.tsx
export const ActivityBarTab = ({
  children,
  index,
  isSelected,
  handleSelect,
}: {
  children: JSX.Element;
  index: number;
  isSelected: boolean;
  handleSelect: (index: number) => void;
}) => {
  return (
    <>
      <button
        className={`py-3 ${
          isSelected
            ? 'text-theme-activity-bar-tab-selected-light dark:text-theme-activity-bar-tab-selected-dark'
            : 'text-theme-activity-bar-tab-light dark:text-theme-activity-bar-tab-dark'
        } ${
          isSelected
            ? ''
            : 'hover:text-theme-activity-bar-tab-hover-light dark:hover:text-theme-activity-bar-tab-hover-dark'
        }`}
        onClick={() => handleSelect(index)}
      >
        {children}
      </button>
    </>
  );
};
------------------------
./components/Home/components/SecondaryMenu/components/ActivityBar/ActivityBar.tsx
import { useContext } from 'react';

import { ActivityBarTab } from './components/ActivityBarTab';
import HomeContext from '@/components/Home/home.context';

import SecondaryMenuContext from '../../SecondaryMenu.context';

const ActivityBar = ({ icons }: { icons: JSX.Element[] }) => {
  const {
    state: { showSecondaryMenu },
    dispatch: homeDispatch,
  } = useContext(HomeContext);

  const {
    state: { selectedIndex },
    dispatch: secondaryMenuDispatch,
  } = useContext(SecondaryMenuContext);

  const handleSelect = (index: number) => {
    if (selectedIndex === index) {
      homeDispatch({ field: 'showSecondaryMenu', value: !showSecondaryMenu });
    }

    if (!showSecondaryMenu) {
      homeDispatch({ field: 'showSecondaryMenu', value: !showSecondaryMenu });
    }
    secondaryMenuDispatch({ field: 'selectedIndex', value: index });
  };

  // VS Code Activity Bar with tabs at the top and setting button at the bottom
  return (
    <div
      className={`relative border-l border-theme-border-light dark:border-theme-border-dark
      top-0 z-30 flex h-full w-[48px] flex-none flex-col
      ${showSecondaryMenu ? 'right-[0]' : 'hidden sm:flex'}
      space-y-6 bg-theme-activity-bar-light dark:bg-theme-activity-bar-dark items-center
      align-middle py-4 text-[14px] transition-all sm:relative sm:top-0
      sm:left-[0] justify-between`}
    >
      {/* Tabs aligns to top */}
      <div className="flex flex-col items-center">
        {icons.map((icon, index) => (
          <ActivityBarTab
            handleSelect={handleSelect}
            isSelected={index === selectedIndex}
            index={index}
            key={index}
          >
            {icon}
          </ActivityBarTab>
        ))}
      </div>
    </div>
  );
};

export default ActivityBar;
------------------------
./components/Home/components/SecondaryMenu/SecondaryMenu.context.tsx
import { Dispatch, createContext } from 'react';

import { ActionType } from '@/hooks/useCreateReducer';

import { SecondaryMenuInitialState } from './SecondaryMenu.state';

export interface SecondaryMenuContextProps {
  state: SecondaryMenuInitialState;
  dispatch: Dispatch<ActionType<SecondaryMenuInitialState>>;
}

const SecondaryMenuContext = createContext<SecondaryMenuContextProps>(
  undefined!,
);

export default SecondaryMenuContext;
------------------------
./components/Home/components/ChatZone/ChatZone.state.tsx
export interface ChatZoneInitialState {
  selectedIndex: number;
}

export const initialState: ChatZoneInitialState = {
  selectedIndex: 0,
};
------------------------
./components/Home/components/ChatZone/Screens/Settings/Settings.tsx
import { IconDeviceFloppy, IconX } from '@tabler/icons-react';
import { useContext, useEffect } from 'react';

import { useTranslation } from 'next-i18next';

import { useCreateReducer } from '@/hooks/useCreateReducer';

import {
  setSavedSetting,
  setSavedSettings,
} from '@/utils/app/storage/local/settings';

import { Setting, SettingsSection } from '@/types/settings';

import { SettingsSectionComponent } from './components/SettingsSectionComponent';
import HomeContext from '@/components/Home/home.context';

import SettingsContext from './Settings.context';
import { SettingsInitialState, initialState } from './Settings.state';

export const Settings = () => {
  const { t } = useTranslation('settings');

  const settingsContextValue = useCreateReducer<SettingsInitialState>({
    initialState,
  });

  const {
    state: { searchQuery, selectedSection },
    dispatch: settingsDispatch,
  } = settingsContextValue;

  const {
    state: { user, settings },
    dispatch: homeDispatch,
  } = useContext(HomeContext);

  useEffect(() => {
    // fetchFiles(searchQuery);
  }, [searchQuery, settingsDispatch]);

  const doSearch = (query: string) =>
    settingsDispatch({ field: 'searchQuery', value: query });

  const handleSave = (
    section: SettingsSection,
    setting: Setting,
    value: any,
  ) => {
    const newSavedSettings = setSavedSetting(
      user!,
      section.id,
      setting.id,
      value,
    );
    homeDispatch({ field: 'savedSettings', value: newSavedSettings });
  };

  const handleSelect = (section: SettingsSection, setting: Setting) => {
    settingsDispatch({
      field: 'selectedSection',
      value: section,
    });
    settingsDispatch({
      field: 'selectedSetting',
      value: setting,
    });
  };

  const handleClose = () => {
    homeDispatch({ field: 'display', value: 'chat' });
  };

  return (
    <SettingsContext.Provider
      value={{
        ...settingsContextValue,
        handleSelect,
        handleSave,
      }}
    >
      <div className="relative flex-1 overflow-scroll bg-theme-light dark:bg-theme-dark">
        <div className="max-h-full overflow-x-hidden"></div>
        <div
          className={`group md:px-4 bg-theme-light text-gray-800
       dark:border-gray-900/50 dark:bg-theme-dark dark:text-gray-100'`}
          style={{ overflowWrap: 'anywhere' }}
        >
          <div className="flex w-full p-4 text-base">
            <div className="w-full">
              <div className="block">
                <h1 className="text-3xl font-bold text-center text-black dark:text-white">
                  Settings
                </h1>
                {settings &&
                  Object.values(settings).map((section, index) => (
                    <SettingsSectionComponent
                      isSelected={selectedSection?.id === section.id}
                      key={index}
                      section={section}
                    />
                  ))}
              </div>
            </div>
          </div>
        </div>
      </div>
      <div>
        <button
          className="
          absolute top-2 right-2 w-6 h-6 m-2 cursor-pointer rounded-sm
          text-gray-700 dark:text-gray-100
          hover:bg-theme-hover-dark dark:hover:bg-theme-hover-dark 
          "
          onClick={handleClose}
        >
          <IconX />
        </button>
      </div>
    </SettingsContext.Provider>
  );
};
------------------------
./components/Home/components/ChatZone/Screens/Settings/Settings.context.tsx
import { Dispatch, createContext } from 'react';

import { ActionType } from '@/hooks/useCreateReducer';

import { Setting, SettingsSection } from '@/types/settings';

import { SettingsInitialState } from './Settings.state';

export interface SettingsContextProps {
  state: SettingsInitialState;
  dispatch: Dispatch<ActionType<SettingsInitialState>>;
  handleSelect: (section: SettingsSection, setting: Setting) => void;
  handleSave: (section: SettingsSection, setting: Setting, value: any) => void;
}

const PrimaryMenuContext = createContext<SettingsContextProps>(undefined!);

export default PrimaryMenuContext;
------------------------
./components/Home/components/ChatZone/Screens/Settings/components/SettingsSectionComponent.tsx
import { useContext } from 'react';

import { SettingsSection } from '@/types/settings';

import SettingsContext from '../Settings.context';
import { SettingComponent } from './SettingComponent';

interface Props {
  section: SettingsSection;
  isSelected: boolean;
}

export const SettingsSectionComponent = ({ section, isSelected }: Props) => {
  const {
    state: { selectedSetting },
    dispatch: settingsDispatch,
  } = useContext(SettingsContext);

  return (
    <div className="block w-full flex-col gap-1 mb-5">
      <h2 className="mb-2 mt-2 pl-3 font-semibold text-2xl text-black dark:text-white">
        {section.name}
      </h2>
      {Object.values(section.settings).map((setting, index) => (
        <SettingComponent
          isSelected={isSelected && selectedSetting?.name === setting.name}
          key={index}
          section={section}
          setting={setting}
        />
      ))}
    </div>
  );
};
------------------------
./components/Home/components/ChatZone/Screens/Settings/components/SettingComponent.tsx
import { useContext, useEffect, useState } from 'react';

import { getSavedSettingValue } from '@/utils/app/storage/local/settings';

import { Setting, SettingsSection } from '@/types/settings';

import HomeContext from '@/components/Home/home.context';

import SettingsContext from '../Settings.context';

interface Props {
  section: SettingsSection;
  setting: Setting;
  isSelected: boolean;
}

export const SettingComponent = ({ section, setting, isSelected }: Props) => {
  const [value, setValue] = useState('');

  const {
    state: { settings, savedSettings },
  } = useContext(HomeContext);
  const { handleSelect, handleSave } = useContext(SettingsContext);

  useEffect(() => {
    if (savedSettings && settings) {
      const savedValue = getSavedSettingValue(
        savedSettings,
        section.id,
        setting.id,
        settings,
      );
      if (savedValue !== undefined) {
        setValue(savedValue);
      }
    }
  }, [savedSettings, settings, section.id, setting.id]);

  let component = <></>;
  if (setting.type === 'string') {
    component = (
      <div className="relative h-fit flex w-full flex-col gap-1">
        <input
          type="text"
          value={value}
          className={`w-full flex-1 rounded-sm border border-theme-border-light dark:border-theme-border-dark
            bg-theme-light dark:bg-theme-dark px-2 py-1 text-[14px] leading-3 text-black dark:text-white`}
          onChange={(event) =>
            handleSave(section, setting, event.target.value as string)
          }
        />
      </div>
    );
  } else if (setting.type === 'choice') {
    component = (
      <>
        <div className="w-1/2 p-0 m-0">
          <select
            className={`p-1 text-sm w-full bg-theme-light dark:bg-theme-select-dark cursor-pointer text-neutral-700
          dark:text-neutral-200 border border-theme-border-light dark:border-theme-border-dark`}
            value={value}
            onChange={(event) =>
              handleSave(section, setting, event.target.value)
            }
          >
            {setting.choices!.map((choice, index) => (
              <option key={index} value={choice.value}>
                {choice.default ? `Default(${choice.name})` : choice.name}
              </option>
            ))}
          </select>
        </div>
      </>
    );
  }
  return (
    <div
      className={`block w-full p-4 pt-2 border ${
        isSelected
          ? `
            bg-theme-setting-selected-light dark:bg-theme-setting-selected-dark
            border-[#005cc5]
            `
          : `
            bg-theme-light dark:bg-theme-dark border-transparent
            hover:bg-theme-setting-hover-light dark:hover:bg-theme-setting-hover-dark
            `
      } 
       `}
      onClick={() => handleSelect(section, setting)}
    >
      <div className="ml-1 my-2 flex">
        <div className="text-sm font-medium text-black dark:text-neutral-100">
          {section.name}:
        </div>
        &nbsp;
        <div className="text-sm font-semibold text-black dark:text-white">
          {setting.name}
        </div>
      </div>
      <p className="ml-1 mb-4 text-sm text-black dark:text-white">
        {setting.description}
      </p>
      {component}
    </div>
  );
};
------------------------
./components/Home/components/ChatZone/Screens/Settings/Settings.state.tsx
import { Setting, SettingsSection } from '@/types/settings';

export interface SettingsInitialState {
  searchQuery: string;
  filteredSettings: Setting[];
  selectedSection: SettingsSection | null;
  selectedSetting: Setting | null;
}

export const initialState: SettingsInitialState = {
  searchQuery: '',
  filteredSettings: [],
  selectedSection: null,
  selectedSetting: null,
};
------------------------
./components/Home/components/ChatZone/Screens/Chat/Chat.state.tsx
export interface ChatInitialState {}

export const initialState: ChatInitialState = {};
------------------------
./components/Home/components/ChatZone/Screens/Chat/Temperature.tsx
import { FC, useContext, useState } from 'react';

import { useTranslation } from 'next-i18next';

import { DEFAULT_TEMPERATURE } from '@/utils/app/const';

import HomeContext from '@/components/Home/home.context';

interface Props {
  label: string;
  onChangeTemperature: (temperature: number) => void;
}

export const TemperatureSlider: FC<Props> = ({
  label,
  onChangeTemperature,
}) => {
  const {
    state: { conversations },
  } = useContext(HomeContext);
  const lastConversation = conversations[conversations.length - 1];
  const [temperature, setTemperature] = useState(
    lastConversation?.temperature ?? DEFAULT_TEMPERATURE,
  );
  const { t } = useTranslation('chat');
  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = parseFloat(event.target.value);
    setTemperature(newValue);
    onChangeTemperature(newValue);
  };

  return (
    <div className="flex flex-col">
      <label className="mb-2 text-left text-neutral-700 dark:text-neutral-400">
        {label}
      </label>
      <span className="text-[12px] text-black/50 dark:text-white/50 text-sm">
        {t(
          'Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.',
        )}
      </span>
      <span className="mt-2 mb-1 text-center text-neutral-900 dark:text-neutral-100">
        {temperature.toFixed(1)}
      </span>
      <input
        className="cursor-pointer"
        type="range"
        min={0}
        max={1}
        step={0.1}
        value={temperature}
        onChange={handleChange}
      />
      <ul className="w mt-2 pb-8 flex justify-between px-[24px] text-neutral-900 dark:text-neutral-100">
        <li className="flex justify-center">
          <span className="absolute">{t('Precise')}</span>
        </li>
        <li className="flex justify-center">
          <span className="absolute">{t('Neutral')}</span>
        </li>
        <li className="flex justify-center">
          <span className="absolute">{t('Creative')}</span>
        </li>
      </ul>
    </div>
  );
};
------------------------
./components/Home/components/ChatZone/Screens/Chat/Chat.context.tsx
import { Dispatch, createContext } from 'react';

import { ActionType } from '@/hooks/useCreateReducer';

import { ChatInitialState } from './Chat.state';

export interface ChatContextProps {
  state: ChatInitialState;
  dispatch: Dispatch<ActionType<ChatInitialState>>;
}

const PrimaryMenuContext = createContext<ChatContextProps>(undefined!);

export default PrimaryMenuContext;
------------------------
./components/Home/components/ChatZone/Screens/Chat/Regenerate.tsx
import { IconRefresh } from '@tabler/icons-react';
import { FC } from 'react';

import { useTranslation } from 'next-i18next';

interface Props {
  onRegenerate: () => void;
}

export const Regenerate: FC<Props> = ({ onRegenerate }) => {
  const { t } = useTranslation('chat');
  return (
    <div className="fixed bottom-4 left-0 right-0 ml-auto mr-auto w-full px-2 sm:absolute sm:bottom-8 sm:left-[280px] sm:w-1/2 lg:left-[200px]">
      <div className="mb-4 text-center text-red-500">
        {t('Sorry, there was an error.')}
      </div>
      <button
        className="flex h-12 gap-2 w-full items-center justify-center rounded-lg border border-b-neutral-300 bg-neutral-100 text-sm font-semibold text-neutral-500 dark:border-none dark:bg-[#444654] dark:text-neutral-200"
        onClick={onRegenerate}
      >
        <IconRefresh />
        <div>{t('Regenerate response')}</div>
      </button>
    </div>
  );
};
------------------------
./components/Home/components/ChatZone/Screens/Chat/VariableModal.tsx
import { FC, KeyboardEvent, useEffect, useRef, useState } from 'react';

import { Prompt } from '@/types/prompt';

interface Props {
  prompt: Prompt;
  variables: string[];
  onSubmit: (updatedVariables: string[]) => void;
  onClose: () => void;
}

export const VariableModal: FC<Props> = ({
  prompt,
  variables,
  onSubmit,
  onClose,
}) => {
  const [updatedVariables, setUpdatedVariables] = useState<
    { key: string; value: string }[]
  >(
    variables
      .map((variable) => ({ key: variable, value: '' }))
      .filter(
        (item, index, array) =>
          array.findIndex((t) => t.key === item.key) === index,
      ),
  );

  const modalRef = useRef<HTMLDivElement>(null);
  const nameInputRef = useRef<HTMLTextAreaElement>(null);

  const handleChange = (index: number, value: string) => {
    setUpdatedVariables((prev) => {
      const updated = [...prev];
      updated[index].value = value;
      return updated;
    });
  };

  const handleSubmit = () => {
    if (updatedVariables.some((variable) => variable.value === '')) {
      alert('Please fill out all variables');
      return;
    }

    onSubmit(updatedVariables.map((variable) => variable.value));
    onClose();
  };

  const handleKeyDown = (e: KeyboardEvent<HTMLDivElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSubmit();
    } else if (e.key === 'Escape') {
      onClose();
    }
  };

  useEffect(() => {
    const handleOutsideClick = (e: MouseEvent) => {
      if (modalRef.current && !modalRef.current.contains(e.target as Node)) {
        onClose();
      }
    };

    window.addEventListener('click', handleOutsideClick);

    return () => {
      window.removeEventListener('click', handleOutsideClick);
    };
  }, [onClose]);

  useEffect(() => {
    if (nameInputRef.current) {
      nameInputRef.current.focus();
    }
  }, []);

  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50"
      onKeyDown={handleKeyDown}
    >
      <div
        ref={modalRef}
        className="dark:border-netural-400 inline-block max-h-[400px] transform overflow-y-auto rounded-lg border border-gray-300 bg-white px-4 pt-5 pb-4 text-left align-bottom shadow-xl transition-all dark:bg-[#202123] sm:my-8 sm:max-h-[600px] sm:w-full sm:max-w-lg sm:p-6 sm:align-middle"
        role="dialog"
      >
        <div className="mb-4 text-xl font-bold text-black dark:text-neutral-200">
          {prompt.name}
        </div>

        <div className="mb-4 text-sm italic text-black dark:text-neutral-200">
          {prompt.description}
        </div>

        {updatedVariables.map((variable, index) => (
          <div className="mb-4" key={index}>
            <div className="mb-2 text-sm font-bold text-neutral-200">
              {variable.key}
            </div>

            <textarea
              ref={index === 0 ? nameInputRef : undefined}
              className="mt-1 w-full rounded-lg border border-neutral-500 px-4 py-2 text-neutral-900 shadow focus:outline-none dark:border-neutral-800 dark:border-opacity-50 dark:bg-[#40414F] dark:text-neutral-100"
              style={{ resize: 'none' }}
              placeholder={`Enter a value for ${variable.key}...`}
              value={variable.value}
              onChange={(e) => handleChange(index, e.target.value)}
              rows={3}
            />
          </div>
        ))}

        <button
          className="mt-6 w-full rounded-lg border border-neutral-500 px-4 py-2 text-neutral-900 shadow hover:bg-neutral-100 focus:outline-none dark:border-neutral-800 dark:border-opacity-50 dark:bg-white dark:text-black dark:hover:bg-neutral-300"
          onClick={handleSubmit}
        >
          Submit
        </button>
      </div>
    </div>
  );
};
------------------------
./components/Home/components/ChatZone/Screens/Chat/PromptList.tsx
import { FC, MutableRefObject } from 'react';

import { Prompt } from '@/types/prompt';

interface Props {
  prompts: Prompt[];
  activePromptIndex: number;
  onSelect: () => void;
  onMouseOver: (index: number) => void;
  promptListRef: MutableRefObject<HTMLUListElement | null>;
}

export const PromptList: FC<Props> = ({
  prompts,
  activePromptIndex,
  onSelect,
  onMouseOver,
  promptListRef,
}) => {
  return (
    <ul
      ref={promptListRef}
      className="z-10 p-0 max-h-52 w-full overflow-scroll
      rounded border border-black/10
      shadow-[0_0_10px_rgba(0,0,0,0.10)]
      text-black dark:text-white dark:shadow-[0_0_15px_rgba(0,0,0,0.10)]"
    >
      {prompts.map((prompt, index) => (
        <li
          key={prompt.id}
          className={`${
            index === activePromptIndex
              ? 'bg-gray-200 dark:bg-[#202123] dark:text-white'
              : ''
          } px-3 py-2 text-sm text-black dark:text-white`}
          onClick={(e) => {
            e.preventDefault();
            e.stopPropagation();
            onSelect();
          }}
          onMouseEnter={() => onMouseOver(index)}
        >
          {prompt.name}
        </li>
      ))}
    </ul>
  );
};
------------------------
./components/Home/components/ChatZone/Screens/Chat/Chat.tsx
import {
  MutableRefObject,
  memo,
  useCallback,
  useContext,
  useEffect,
  useRef,
  useState,
} from 'react';

import { useTranslation } from 'next-i18next';
import Image from 'next/image';

import { useCreateReducer } from '@/hooks/useCreateReducer';

import { editMessageHandler } from '@/utils/app/handlers/EditMessage';
import { regenerateMessageHandler } from '@/utils/app/handlers/RegenerateMessage';
import { sendHandlerFunction } from '@/utils/app/handlers/SendMessage';
import { throttle } from '@/utils/data/throttle';

import { Message } from '@/types/chat';

import { ErrorMessageDiv } from '@/components/Common/ErrorMessageDiv';
import HomeContext from '@/components/Home/home.context';

import ChatContext from './Chat.context';
import { ChatInitialState, initialState } from './Chat.state';
import { ChatInput } from './ChatInput';
import { ChatLoader } from './ChatLoader';
import { MemoizedChatMessage } from './MemoizedChatMessage';

interface Props {
  stopConversationRef: MutableRefObject<boolean>;
}

export const Chat = memo(({ stopConversationRef }: Props) => {
  const chatContextValue = useCreateReducer<ChatInitialState>({
    initialState,
  });

  const {
    state: {
      selectedConversation,
      conversations,
      database,
      models,
      modelError,
      loading,
      builtInSystemPrompts,
      user,
      savedSettings,
    },
    dispatch: homeDispatch,
  } = useContext(HomeContext);

  const [currentMessage, setCurrentMessage] = useState<Message>();
  const [autoScrollEnabled, setAutoScrollEnabled] = useState<boolean>(true);
  const [showScrollDownButton, setShowScrollDownButton] =
    useState<boolean>(false);

  const getRandomQuote = useCallback(() => {
    const quotes = [
      "Proceed, pal...",
      "Perfect period to partake in pedagogy.",
      "Pursue proficiency.",
      "Piece together projects.",
      "Ponder possibilities.",
      "Plunge into the peculiar.",
      "Pick a pioneering path.",
      "Produce a peculiar piece.",
      "Pursue a pioneering perspective.",
      "Procure a progressive product.",
      "Pen something pristine.",
      "Present a pristine perspective.",
      "Probe into the peculiar.",
      "Poke at the paradoxical.",
      "Pursue the perplexing.",
      "Perpetual process of personal progress.",
      "Precious period, pick up proficiency.",
      "Perpetual pedagogy pays off perpetually.",
      "Passion and perseverance produce proficiency.",
      "Participation, not passive perusal, promotes proficiency."
    ];
    

    return quotes[Math.floor(Math.random() * quotes.length)];
  }, []);

  const [quote, setQuote] = useState<string>(getRandomQuote());
  const [lastConversation, setLastConversation] =
    useState(selectedConversation);

  const messagesEndRef = useRef<HTMLDivElement>(null);
  const chatContainerRef = useRef<HTMLDivElement>(null);
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  const handleSend = useCallback(sendHandlerFunction, [
    conversations,
    homeDispatch,
    selectedConversation,
    stopConversationRef,
    database,
  ]);

  const handleEdit = useCallback(editMessageHandler, [
    conversations,
    homeDispatch,
    selectedConversation,
    stopConversationRef,
    database,
  ]);

  const handleRegenerate = useCallback(regenerateMessageHandler, [
    conversations,
    homeDispatch,
    selectedConversation,
    stopConversationRef,
    database,
  ]);

  const scrollToBottom = useCallback(() => {
    if (autoScrollEnabled) {
      messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
      textareaRef.current?.focus();
    }
  }, [autoScrollEnabled]);

  const handleScroll = () => {
    if (chatContainerRef.current) {
      const { scrollTop, scrollHeight, clientHeight } =
        chatContainerRef.current;
      const bottomTolerance = 30;

      if (scrollTop + clientHeight < scrollHeight - bottomTolerance) {
        setAutoScrollEnabled(false);
        setShowScrollDownButton(true);
      } else {
        setAutoScrollEnabled(true);
        setShowScrollDownButton(false);
      }
    }
  };

  const handleScrollDown = () => {
    chatContainerRef.current?.scrollTo({
      top: chatContainerRef.current.scrollHeight,
      behavior: 'smooth',
    });
  };

  const scrollDown = () => {
    if (autoScrollEnabled) {
      messagesEndRef.current?.scrollIntoView(true);
    }
  };
  const throttledScrollDown = throttle(scrollDown, 250);

  useEffect(() => {
    throttledScrollDown();
    selectedConversation &&
      setCurrentMessage(
        selectedConversation.messages[selectedConversation.messages.length - 2],
      );
  }, [selectedConversation, throttledScrollDown]);

  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        setAutoScrollEnabled(entry.isIntersecting);
        if (entry.isIntersecting) {
          textareaRef.current?.focus();
        }
      },
      {
        root: null,
        threshold: 0.5,
      },
    );
    const messagesEndElement = messagesEndRef.current;
    if (messagesEndElement) {
      observer.observe(messagesEndElement);
    }
    return () => {
      if (messagesEndElement) {
        observer.unobserve(messagesEndElement);
      }
    };
  }, [messagesEndRef]);

  useEffect(() => {
    if (lastConversation && selectedConversation) {
      if (lastConversation.id !== selectedConversation.id) {
        setLastConversation(selectedConversation);
        setQuote(getRandomQuote());
      }
    }
  }, [selectedConversation, getRandomQuote, lastConversation]);

  return (
    <ChatContext.Provider value={{ ...chatContextValue }}>
      <div
        className="relative flex-1 overflow-hidden bg-theme-light dark:bg-theme-dark
      "
      >
        {models.length === 0 ? (
          <div className="mx-auto flex h-full w-[300px] flex-col justify-center space-y-6 sm:w-[600px]">
            <div className="text-center text-4xl font-bold text-black dark:text-white">
              Welcome to poiesisPete
            </div>
          </div>
        ) : modelError ? (
          <ErrorMessageDiv error={modelError} />
        ) : (
          <>
            <div
              className="max-h-full h-full overflow-x-hidden"
              ref={chatContainerRef}
              onScroll={handleScroll}
            >
              {selectedConversation?.messages.length === 0 ? (
                <div className="h-full w-full px-4 flex flex-col self-center items-center align-middle justify-center select-none">
                  <div className="text-center text-black dark:text-white mb-2 text-xl font-light">
                    {quote}
                  </div>
                  <div className="animate-zoom-pulse-slow">
                    <div className="flex flex-row self-center items-center align-middle justify-center">
                      <div
                        className=" z-10 flex flex-row self-center items-start align-middle justify-center
                          w-fit bg-[#e7eaf5] rounded-2xl px-2 py-1 shadow-xl"
                      >
                        <Image
                          src="./icon-64.svg"
                          height={64}
                          width={264}
                          alt="logo"
                        />
                        <div
                          className="flex flex-row self-center items-end align-middle justify-center text-transparent 
                          bg-gradient-to-r from-black-700 via-violet-900 to-indigo-500
                          dark:from-black-500 dark:via-violet-600 dark:to-indigo-400
                          bg-clip-text bg-175% animate-bg-pan-fast rotate-0"
                        >
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              ) : (
                <>
                  {selectedConversation?.messages.map((message, index) => (
                    <MemoizedChatMessage
                      key={index}
                      message={message}
                      messageIndex={index}
                      onEdit={(conversation, editedMessage) => {
                        setCurrentMessage(editedMessage);
                        // discard edited message and the ones that come after then resend
                        handleEdit(
                          user!,
                          editedMessage,
                          index,
                          stopConversationRef,
                          builtInSystemPrompts,
                          conversation,
                          conversations,
                          database!,
                          savedSettings,
                          homeDispatch,
                        );
                      }}
                    />
                  ))}

                  {loading && <ChatLoader />}

                  <div
                    className="h-[100px] sm:h-[162px] bg-theme-light dark:bg-theme-dark"
                    ref={messagesEndRef}
                  />
                </>
              )}
            </div>

            <ChatInput
              stopConversationRef={stopConversationRef}
              textareaRef={textareaRef}
              onSend={(conversation, message) => {
                setCurrentMessage(message);
                handleSend(
                  user!,
                  message,
                  stopConversationRef,
                  builtInSystemPrompts,
                  conversation,
                  conversations,
                  database!,
                  savedSettings,
                  homeDispatch,
                );
              }}
              onScrollDownClick={handleScrollDown}
              onRegenerate={(conversation) => {
                if (currentMessage) {
                  handleRegenerate(
                    user!,
                    stopConversationRef,
                    builtInSystemPrompts,
                    conversation,
                    conversations,
                    database!,
                    savedSettings,
                    homeDispatch,
                  );
                }
              }}
              showScrollDownButton={showScrollDownButton}
            />
          </>
        )}
      </div>
    </ChatContext.Provider>
  );
});
Chat.displayName = 'Chat';
------------------------
./components/Home/components/ChatZone/Screens/Chat/MemoizedChatMessage.tsx
import { FC, memo } from "react";
import { ChatMessage, Props } from "./ChatMessage";

export const MemoizedChatMessage: FC<Props> = memo(
    ChatMessage,
    (prevProps, nextProps) => (
        prevProps.message.content === nextProps.message.content
    )
);
------------------------
./components/Home/components/ChatZone/Screens/Chat/ChatMessage.tsx
import {
  IconCheck,
  IconCopy,
  IconEdit,
  IconRobot,
  IconTrash,
  IconUser,
} from '@tabler/icons-react';
import { FC, memo, useContext, useEffect, useRef, useState } from 'react';

import { useTranslation } from 'next-i18next';
import Image from 'next/image';

import { storageDeleteMessages } from '@/utils/app/storage/messages';

import { Conversation, Message } from '@/types/chat';

import HomeContext from '@/components/Home/home.context';
import { CodeBlock } from '@/components/Markdown/CodeBlock';
import { MemoizedReactMarkdown } from '@/components/Markdown/MemoizedReactMarkdown';

import rehypeRaw from 'rehype-raw';
import remarkGfm from 'remark-gfm';
import remarkMath from 'remark-math';

export interface Props {
  message: Message;
  messageIndex: number;
  onEdit?: (conversation: Conversation, editedMessage: Message) => void;
}

export const ChatMessage: FC<Props> = memo(
  ({ message, messageIndex, onEdit }) => {
    const { t } = useTranslation('chat');

    const {
      state: {
        selectedConversation,
        conversations,
        messageIsStreaming,
        database,
        user,
      },
      dispatch: homeDispatch,
    } = useContext(HomeContext);

    const [isEditing, setIsEditing] = useState<boolean>(false);
    const [isTyping, setIsTyping] = useState<boolean>(false);
    const [messageContent, setMessageContent] = useState(message.content);
    const [messagedCopied, setMessageCopied] = useState(false);

    const [authUrl, setAuthUrl] = useState<string | undefined>();

    const textareaRef = useRef<HTMLTextAreaElement>(null);

    const toggleEditing = () => {
      setIsEditing(!isEditing);
    };

    const handleInputChange = (
      event: React.ChangeEvent<HTMLTextAreaElement>,
    ) => {
      setMessageContent(event.target.value);
      if (textareaRef.current) {
        textareaRef.current.style.height = 'inherit';
        textareaRef.current.style.height = `${textareaRef.current.scrollHeight}px`;
      }
    };

    const handleEditMessage = () => {
      if (message.content != messageContent) {
        if (selectedConversation && onEdit) {
          onEdit(selectedConversation, { ...message, content: messageContent });
        }
      }
      setIsEditing(false);
    };

    const handleDeleteMessage = () => {
      if (!selectedConversation) return;

      const { messages } = selectedConversation;
      const findIndex = messages.findIndex((elm) => elm === message);

      let messagesToBeDeleted = [];
      if (findIndex < 0) return;

      if (
        findIndex < messages.length - 1 &&
        messages[findIndex + 1].role === 'assistant'
      ) {
        messagesToBeDeleted.push(
          messages[findIndex].id,
          messages[findIndex + 1].id,
        );
        messages.splice(findIndex, 2);
      } else {
        messagesToBeDeleted.push(messages[findIndex].id);
        messages.splice(findIndex, 1);
      }

      const { single, all } = storageDeleteMessages(
        database!,
        user!,
        messagesToBeDeleted,
        selectedConversation,
        messages,
        conversations,
      );
      homeDispatch({ field: 'selectedConversation', value: single });
      homeDispatch({ field: 'conversations', value: all });
    };

    const handlePressEnter = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
      if (e.key === 'Enter' && !isTyping && !e.shiftKey) {
        e.preventDefault();
        handleEditMessage();
      }
    };

    const copyOnClick = () => {
      if (!navigator.clipboard) return;

      navigator.clipboard.writeText(message.content).then(() => {
        setMessageCopied(true);
        setTimeout(() => {
          setMessageCopied(false);
        }, 2000);
      });
    };

    useEffect(() => {
      setMessageContent(message.content);
    }, [message.content]);

    useEffect(() => {
      if (textareaRef.current) {
        textareaRef.current.style.height = 'inherit';
        textareaRef.current.style.height = `${textareaRef.current.scrollHeight}px`;
      }
    }, [isEditing]);

    return (
      <div
        className={`sm:px-4 lg:px-8
        ${
          message.role === 'assistant'
            ? 'bg-gray-200 text-gray-800 dark:bg-[#444654] dark:text-gray-100'
            : 'bg-theme-light text-gray-800 dark:bg-theme-dark dark:text-gray-100'
        }`}
        style={{ overflowWrap: 'anywhere' }}
      >
        <div className="group relative m-auto flex p-4 text-base md:max-w-2xl md:gap-6 md:py-6 lg:max-w-2xl lg:px-0 xl:max-w-3xl">
          <div className="min-w-[40px] text-right font-bold">
            {message.role === 'assistant' && <IconRobot size={30} />}
            {message.role === 'user' && <IconUser size={30} />}
          </div>

          <div className="prose mt-[-2px] w-full dark:prose-invert">
            {message.role === 'user' && (
              <div className="flex w-full">
                {isEditing ? (
                  <div className="flex w-full flex-col">
                    <textarea
                      ref={textareaRef}
                      className="w-full resize-none whitespace-pre-wrap border-none bg-theme-light dark:bg-theme-dark"
                      value={messageContent}
                      onChange={handleInputChange}
                      onKeyDown={handlePressEnter}
                      onCompositionStart={() => setIsTyping(true)}
                      onCompositionEnd={() => setIsTyping(false)}
                      style={{
                        fontFamily: 'inherit',
                        fontSize: 'inherit',
                        lineHeight: 'inherit',
                        padding: '0',
                        margin: '0',
                        overflow: 'hidden',
                      }}
                    />

                    <div className="mt-10 flex justify-center space-x-4">
                      <button
                        className="h-[40px] rounded-md bg-blue-500 px-4 py-1 text-sm font-medium text-white enabled:hover:bg-blue-600 disabled:opacity-50"
                        onClick={handleEditMessage}
                        disabled={messageContent.trim().length <= 0}
                      >
                        {t('Save & Submit')}
                      </button>
                      <button
                        className="h-[40px] rounded-md border border-neutral-300 px-4 py-1 text-sm font-medium text-neutral-700 hover:bg-neutral-100 dark:border-neutral-700 dark:text-neutral-300 dark:hover:bg-neutral-800"
                        onClick={() => {
                          setMessageContent(message.content);
                          setIsEditing(false);
                        }}
                      >
                        {t('Cancel')}
                      </button>
                    </div>
                  </div>
                ) : (
                  <div className="prose whitespace-pre-wrap dark:prose-invert flex-1">
                    {message.content}
                  </div>
                )}

                {!isEditing && (
                  <div className="md:-mr-8 ml-1 md:ml-0 flex flex-col md:flex-row gap-4 md:gap-1 items-center md:items-start justify-end md:justify-start">
                    <button
                      className="invisible group-hover:visible focus:visible text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
                      onClick={toggleEditing}
                    >
                      <IconEdit size={20} />
                    </button>
                    <button
                      className="invisible group-hover:visible focus:visible text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
                      onClick={handleDeleteMessage}
                    >
                      <IconTrash size={20} />
                    </button>
                  </div>
                )}
              </div>
            )}
            {message.role === 'assistant' && (
              <div className="flex flex-row">
                <MemoizedReactMarkdown
                  className="prose dark:prose-invert flex-1"
                  remarkPlugins={[remarkGfm, remarkMath]}
                  rehypePlugins={[rehypeRaw]}
                  components={{
                    code({ node, inline, className, children, ...props }) {
                      if (children.length) {
                        if (children[0] == '▍') {
                          return (
                            <span className="animate-pulse cursor-default mt-1">
                              ▍
                            </span>
                          );
                        }

                        children[0] = (children[0] as string).replace(
                          '`▍`',
                          '▍',
                        );
                      }

                      const match = /language-(\w+)/.exec(className || '');

                      return !inline ? (
                        <CodeBlock
                          key={Math.random()}
                          language={(match && match[1]) || ''}
                          value={String(children).replace(/\n$/, '')}
                          {...props}
                        />
                      ) : (
                        <code className={className} {...props}>
                          {children}
                        </code>
                      );
                    },
                    table({ children }) {
                      return (
                        <table className="border-collapse border border-black px-3 py-1 dark:border-white">
                          {children}
                        </table>
                      );
                    },
                    th({ children }) {
                      return (
                        <th className="break-words border border-black bg-gray-500 px-3 py-1 text-white dark:border-white">
                          {children}
                        </th>
                      );
                    },
                    td({ children }) {
                      return (
                        <td className="break-words border border-black px-3 py-1 dark:border-white">
                          {children}
                        </td>
                      );
                    },
                    a({ children, ...props }) {
                      return (
                        <a {...props} target="_blank">
                          {children}
                        </a>
                      );
                    },
                    img({ src, alt, width, height }) {
                      if (!width && !height) {
                        width = '1024px';
                        height = '1024px';
                      }
                      return (
                        // eslint-disable-next-line @next/next/no-img-element
                        <img
                          src={src!}
                          alt={alt!}
                          width={parseInt(width as string)}
                          height={parseInt(height as string)}
                          className="m-1"
                        />
                      );
                    },
                  }}
                >
                  {`${message.content}${
                    messageIsStreaming &&
                    messageIndex ==
                      (selectedConversation?.messages.length ?? 0) - 1
                      ? '`▍`'
                      : ''
                  }`}
                </MemoizedReactMarkdown>

                <div className="md:-mr-8 ml-1 md:ml-0 flex flex-col md:flex-row gap-4 md:gap-1 items-center md:items-start justify-end md:justify-start">
                  {messagedCopied ? (
                    <IconCheck
                      size={20}
                      className="text-green-500 dark:text-green-400"
                    />
                  ) : (
                    <button
                      className="invisible group-hover:visible focus:visible text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
                      onClick={copyOnClick}
                    >
                      <IconCopy size={20} />
                    </button>
                  )}
                </div>
              </div>
            )}
          </div>
        </div>
      </div>
    );
  },
);
ChatMessage.displayName = 'ChatMessage';
------------------------
./components/Home/components/ChatZone/Screens/Chat/ChatInput.tsx
import {
  IconArrowDown,
  IconBolt,
  IconBrandGoogle,
  IconPlayerStop,
  IconRepeat,
  IconSend,
} from '@tabler/icons-react';
import {
  KeyboardEvent,
  MutableRefObject,
  useCallback,
  useContext,
  useEffect,
  useRef,
  useState,
} from 'react';

import { useTranslation } from 'next-i18next';

import { getTimestampWithTimezoneOffset } from '@/utils/app/time/time';

import { Conversation, Message } from '@/types/chat';
import { Prompt } from '@/types/prompt';

import HomeContext from '@/components/Home/home.context';

import { PromptList } from './PromptList';
import { VariableModal } from './VariableModal';

import { v4 as uuidv4 } from 'uuid';

interface Props {
  onSend: (conversation: Conversation | undefined, message: Message) => void;
  onRegenerate: (conversation: Conversation | undefined) => void;
  onScrollDownClick: () => void;
  stopConversationRef: MutableRefObject<boolean>;
  textareaRef: MutableRefObject<HTMLTextAreaElement | null>;
  showScrollDownButton: boolean;
}

export const ChatInput = ({
  onSend,
  onRegenerate,
  onScrollDownClick,
  stopConversationRef,
  textareaRef,
  showScrollDownButton,
}: Props) => {
  const { t } = useTranslation('chat');

  const {
    state: { selectedConversation, messageIsStreaming, prompts },

    dispatch: homeDispatch,
  } = useContext(HomeContext);

  const [content, setContent] = useState<string>();
  const [isTyping, setIsTyping] = useState<boolean>(false);
  const [showPromptList, setShowPromptList] = useState(false);
  const [activePromptIndex, setActivePromptIndex] = useState(0);
  const [promptInputValue, setPromptInputValue] = useState('');
  const [variables, setVariables] = useState<string[]>([]);
  const [isModalVisible, setIsModalVisible] = useState(false);

  const promptListRef = useRef<HTMLUListElement | null>(null);

  const filteredPrompts = prompts.filter((prompt) =>
    prompt.name.toLowerCase().includes(promptInputValue.toLowerCase()),
  );

  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const value = e.target.value;
    const maxLength = selectedConversation?.model.maxLength;

    if (maxLength && value.length > maxLength) {
      alert(
        t(
          `Message limit is {{maxLength}} characters. You have entered {{valueLength}} characters.`,
          { maxLength, valueLength: value.length },
        ),
      );
      return;
    }

    setContent(value);
    updatePromptListVisibility(value);
  };

  const handleSend = () => {
    if (messageIsStreaming) {
      return;
    }

    if (!content) {
      alert(t('Please enter a message'));
      return;
    }

    const messageId = uuidv4();
    onSend(selectedConversation, {
      id: messageId,
      role: 'user',
      content: content.trim(),
      timestamp: getTimestampWithTimezoneOffset(),
    });
    setContent('');

    if (window.innerWidth < 640 && textareaRef && textareaRef.current) {
      textareaRef.current.blur();
    }
  };

  const handleRegenerate = () => {
    onRegenerate(selectedConversation);
  };

  const handleStopConversation = () => {
    stopConversationRef.current = true;
    setTimeout(() => {
      stopConversationRef.current = false;
    }, 1000);
  };

  const isMobile = () => {
    const userAgent =
      typeof window.navigator === 'undefined' ? '' : navigator.userAgent;
    const mobileRegex =
      /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Mobile|mobile|CriOS/i;
    return mobileRegex.test(userAgent);
  };

  const handleInitModal = () => {
    const selectedPrompt = filteredPrompts[activePromptIndex];
    if (selectedPrompt) {
      setContent((prevContent) => {
        const newContent = prevContent?.replace(
          /\/\w*$/,
          selectedPrompt.content,
        );
        return newContent;
      });
      handlePromptSelect(selectedPrompt);
    }
    setShowPromptList(false);
  };

  const handleKeyDown = (e: KeyboardEvent<HTMLTextAreaElement>) => {
    if (showPromptList) {
      if (e.key === 'ArrowDown') {
        e.preventDefault();
        setActivePromptIndex((prevIndex) =>
          prevIndex < prompts.length - 1 ? prevIndex + 1 : prevIndex,
        );
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        setActivePromptIndex((prevIndex) =>
          prevIndex > 0 ? prevIndex - 1 : prevIndex,
        );
      } else if (e.key === 'Tab') {
        e.preventDefault();
        setActivePromptIndex((prevIndex) =>
          prevIndex < prompts.length - 1 ? prevIndex + 1 : 0,
        );
      } else if (e.key === 'Enter') {
        e.preventDefault();
        handleInitModal();
      } else if (e.key === 'Escape') {
        e.preventDefault();
        setShowPromptList(false);
      } else {
        setActivePromptIndex(0);
      }
    } else if (e.key === 'Enter' && !isTyping && !isMobile() && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  };

  const parseVariables = (content: string) => {
    const regex = /{{(.*?)}}/g;
    const foundVariables = [];
    let match;

    while ((match = regex.exec(content)) !== null) {
      foundVariables.push(match[1]);
    }

    return foundVariables;
  };

  const updatePromptListVisibility = useCallback((text: string) => {
    const match = text.match(/\/\w*$/);

    if (match) {
      setShowPromptList(true);
      setPromptInputValue(match[0].slice(1));
    } else {
      setShowPromptList(false);
      setPromptInputValue('');
    }
  }, []);

  const handlePromptSelect = (prompt: Prompt) => {
    const parsedVariables = parseVariables(prompt.content);
    setVariables(parsedVariables);

    if (parsedVariables.length > 0) {
      setIsModalVisible(true);
    } else {
      setContent((prevContent) => {
        const updatedContent = prevContent?.replace(/\/\w*$/, prompt.content);
        return updatedContent;
      });
      updatePromptListVisibility(prompt.content);
    }
  };

  const handleSubmit = (updatedVariables: string[]) => {
    const newContent = content?.replace(/{{(.*?)}}/g, (match, variable) => {
      const index = variables.indexOf(variable);
      return updatedVariables[index];
    });

    setContent(newContent);

    if (textareaRef && textareaRef.current) {
      textareaRef.current.focus();
    }
  };

  useEffect(() => {
    if (promptListRef.current) {
      promptListRef.current.scrollTop = activePromptIndex * 30;
    }
  }, [activePromptIndex]);

  useEffect(() => {
    if (textareaRef && textareaRef.current) {
      textareaRef.current.style.height = 'inherit';
      textareaRef.current.style.height = `${textareaRef.current?.scrollHeight}px`;
      textareaRef.current.style.overflow = `${
        textareaRef?.current?.scrollHeight > 400 ? 'auto' : 'hidden'
      }`;
    }
  }, [content, textareaRef]);

  useEffect(() => {
    const handleOutsideClick = (e: MouseEvent) => {
      if (
        promptListRef.current &&
        !promptListRef.current.contains(e.target as Node)
      ) {
        setShowPromptList(false);
      }
    };

    window.addEventListener('click', handleOutsideClick);

    return () => {
      window.removeEventListener('click', handleOutsideClick);
    };
  }, []);

  return (
    <div
      className="absolute bottom-0 left-0 w-full border-transparent bg-gradient-to-b 
      dark:border-white/20 from-transparent via-[#f6f7ff] to-[#e9ebff]
      dark:via-[#1e2328] dark:to-[#191d22]"
    >
      <div
        className="relative flex flex-col mb-2 mt-4 last:mb-2 md:mx-4 md:mt-[52px]
      md:last:mb-6 lg:mx-auto lg:max-w-3xl"
      >
        <div className="flex flex-row justify-center items-center">
          {messageIsStreaming && (
            <button
              className="relative top-0 left-0 right-0 mx-auto mb-3 flex w-fit
            items-center gap-3 rounded border border-neutral-200 bg-theme-light
            py-2 px-4 text-black hover:opacity-50 dark:border-neutral-600
            dark:bg-theme-dark dark:text-white md:mt-2"
              onClick={handleStopConversation}
            >
              <IconPlayerStop size={16} /> {t('Stop Generating')}
            </button>
          )}

          {!messageIsStreaming &&
            selectedConversation &&
            selectedConversation.messages.length > 0 && (
              <button
                className="relative top-0 left-0 right-0 mx-auto mb-3 flex w-fit 
              items-center gap-3 rounded border border-neutral-200 bg-theme-light
              py-2 px-4 text-black hover:opacity-50 dark:border-neutral-600 
              dark:bg-theme-dark dark:text-white md:mt-2"
                onClick={handleRegenerate}
              >
                <IconRepeat size={16} /> {t('Regenerate response')}
              </button>
            )}

          {showScrollDownButton && (
            <div className="absolute right-0 mr-4">
              <button
                className="flex h-7 w-7 items-center justify-center rounded-full bg-neutral-300 text-gray-800 shadow-md hover:shadow-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-neutral-200"
                onClick={onScrollDownClick}
              >
                <IconArrowDown size={18} />
              </button>
            </div>
          )}
        </div>

        <div
          className="relative mx-4 mb-4 flex flex-grow flex-col rounded-md border
        border-black/10 bg-white shadow-[0_0_10px_rgba(0,0,0,0.10)] dark:border-gray-900/50
        dark:shadow-[0_0_15px_rgba(0,0,0,0.10)]
        bg-gradient-to-r from-white via-[#fdf4ff] to-white
        dark:from-[#40414F] dark:via-[#4d3f55] dark:to-[#40414F]
        bg-175% animate-bg-pan-slow"
        >
          <textarea
            ref={textareaRef}
            className="m-0 min-h-[38px] w-full resize-none border-0 bg-transparent p-0 py-2 pr-8 pl-2
             text-black dark:text-white md:py-3 md:pl-3"
            style={{
              resize: 'none',
              bottom: `${textareaRef?.current?.scrollHeight}px`,
              maxHeight: '400px',
              overflow: `${
                textareaRef.current && textareaRef.current.scrollHeight > 400
                  ? 'auto'
                  : 'hidden'
              }`,
            }}
            placeholder={
              t('Start typing, type / to select a template...') || ''
            }
            value={content}
            rows={1}
            onCompositionStart={() => setIsTyping(true)}
            onCompositionEnd={() => setIsTyping(false)}
            onChange={handleChange}
            onKeyDown={handleKeyDown}
          />

          <button
            className="absolute right-2 top-2 rounded-sm p-1 text-neutral-800 opacity-60 hover:bg-neutral-200 hover:text-neutral-900 dark:bg-opacity-50 dark:text-neutral-100 dark:hover:text-neutral-200"
            onClick={handleSend}
          >
            {messageIsStreaming ? (
              <div className="h-4 w-4 animate-spin rounded-full border-t-2 border-neutral-800 opacity-60 dark:border-neutral-100"></div>
            ) : (
              <IconSend size={18} />
            )}
          </button>

          {showPromptList && filteredPrompts.length > 0 && (
            <div className="absolute bottom-12 w-full">
              <PromptList
                activePromptIndex={activePromptIndex}
                prompts={filteredPrompts}
                onSelect={handleInitModal}
                onMouseOver={setActivePromptIndex}
                promptListRef={promptListRef}
              />
            </div>
          )}

          {isModalVisible && (
            <VariableModal
              prompt={filteredPrompts[activePromptIndex]}
              variables={variables}
              onSubmit={handleSubmit}
              onClose={() => setIsModalVisible(false)}
            />
          )}
        </div>
      </div>
    </div>
  );
};
------------------------
./components/Home/components/ChatZone/Screens/Chat/ChatLoader.tsx
import { IconRobot } from '@tabler/icons-react';
import { FC } from 'react';

interface Props {}

export const ChatLoader: FC<Props> = () => {
  return (
    <div
      className="sm:px-4 lg:px-8 group border-b border-theme-border-light dark:border-theme-border-dark
      bg-gray-50 text-gray-800 dark:bg-[#444654] dark:text-gray-100"
      style={{ overflowWrap: 'anywhere' }}
    >
      <div className="group relative m-auto flex p-4 text-base md:max-w-2xl md:gap-6 md:py-6 lg:max-w-2xl lg:px-0 xl:max-w-3xl">
        <div className="min-w-[40px] items-end">
          <IconRobot size={30} />
        </div>
        <span className="animate-pulse cursor-default mt-1">▍</span>
      </div>
    </div>
  );
};
------------------------
./components/Home/components/ChatZone/ChatZone.context.tsx
import { Dispatch, createContext } from 'react';

import { ActionType } from '@/hooks/useCreateReducer';

import { ChatZoneInitialState } from './ChatZone.state';

export interface ChatZoneContextProps {
  state: ChatZoneInitialState;
  dispatch: Dispatch<ActionType<ChatZoneInitialState>>;
}

const PrimaryMenuContext = createContext<ChatZoneContextProps>(undefined!);

export default PrimaryMenuContext;
------------------------
./components/Home/components/ChatZone/ChatZone.tsx
import { useContext, useRef } from 'react';

import { useCreateReducer } from '@/hooks/useCreateReducer';

import HomeContext from '@/components/Home/home.context';

import ChatZoneContext from './ChatZone.context';
import { ChatZoneInitialState, initialState } from './ChatZone.state';
import { Chat } from './Screens/Chat/Chat';
import { Settings } from './Screens/Settings/Settings';

export const ChatZone = () => {
  const chatBarContextValue = useCreateReducer<ChatZoneInitialState>({
    initialState,
  });

  const {
    state: { display, showPrimaryMenu, showSecondaryMenu },
  } = useContext(HomeContext);

  const stopConversationRef = useRef<boolean>(false);

  return (
    <ChatZoneContext.Provider value={chatBarContextValue}>
      <div
        className={`relative sm:flex flex-1 ${
          showPrimaryMenu || showSecondaryMenu ? 'hidden' : 'flex'
        }`}
      >
        {display == 'settings' && <Settings />}
        {display == 'chat' && (
          <Chat stopConversationRef={stopConversationRef} />
        )}
      </div>
    </ChatZoneContext.Provider>
  );
};
------------------------
./components/Home/home.context.tsx
import { Dispatch, createContext } from 'react';

import { ActionType } from '@/hooks/useCreateReducer';

import { Conversation } from '@/types/chat';
import { KeyValuePair } from '@/types/data';
import { FolderInterface } from '@/types/folder';

import { HomeInitialState } from './home.state';

export interface HomeContextProps {
  state: HomeInitialState;
  dispatch: Dispatch<ActionType<HomeInitialState>>;
  handleNewConversation: () => void;
  handleCreateFolder: (name: string, type: FolderInterface['type']) => void;
  handleDeleteFolder: (folderId: string) => void;
  handleUpdateFolder: (folderId: string, name: string) => void;
  handleSelectConversation: (conversation: Conversation) => void;
  handleUpdateConversation: (
    conversation: Conversation,
    data: KeyValuePair,
  ) => void;
}

const HomeContext = createContext<HomeContextProps>(undefined!);

export default HomeContext;
------------------------
./components/Home/home.state.tsx
import { DEFAULT_MODEL } from '@/utils/app/const';

import { AiModel } from '@/types/ai-models';
import { User } from '@/types/auth';
import { Conversation, Message } from '@/types/chat';
import { Database } from '@/types/database';
import { ErrorMessage } from '@/types/error';
import { FolderInterface } from '@/types/folder';
import { Prompt } from '@/types/prompt';
import { SavedSetting, SettingsSection } from '@/types/settings';
import { SystemPrompt } from '@/types/system-prompt';

export interface HomeInitialState {
  database: Database | null;
  loading: boolean;
  lightMode: 'light' | 'dark';
  messageIsStreaming: boolean;
  modelError: ErrorMessage | null;
  models: AiModel[];
  folders: FolderInterface[];
  conversations: Conversation[];
  selectedConversation: Conversation | undefined;
  currentMessage: Message | undefined;
  prompts: Prompt[];
  temperature: number;
  showPrimaryMenu: boolean;
  showSecondaryMenu: boolean;
  currentFolder: FolderInterface | undefined;
  messageError: boolean;
  searchTerm: string;
  defaultModelId: string | undefined;
  serverSideApiKeyIsSet: boolean;
  systemPrompts: SystemPrompt[];
  builtInSystemPrompts: SystemPrompt[];
  user: User | null;
  display: 'chat' | 'settings';
  savedSettings: SavedSetting[];
  settings: SettingsSection[];
  fetchComplete: boolean;
  settingsLoaded: boolean;
  currentDate: Date;

}

export const initialState: HomeInitialState = {
  database: null,
  loading: false,
  lightMode: 'dark',
  messageIsStreaming: false,
  modelError: null,
  models: [],
  folders: [],
  conversations: [],
  selectedConversation: undefined,
  currentMessage: undefined,
  prompts: [],
  temperature: 1,
  showPrimaryMenu: true,
  showSecondaryMenu: true,
  currentFolder: undefined,
  messageError: false,
  searchTerm: '',
  defaultModelId: DEFAULT_MODEL,
  serverSideApiKeyIsSet: false,
  systemPrompts: [],
  builtInSystemPrompts: [],
  user: null,
  display: 'chat',
  savedSettings: [],
  settings: [],
  fetchComplete: false,
  settingsLoaded: false,
  currentDate: new Date(),
};
------------------------
./components/Markdown/MemoizedReactMarkdown.tsx
import { FC, memo } from 'react';
import ReactMarkdown, { Options } from 'react-markdown';

export const MemoizedReactMarkdown: FC<Options> = memo(
    ReactMarkdown,
    (prevProps, nextProps) => (
        prevProps.children === nextProps.children
    )
);
------------------------
./components/Markdown/CodeBlock.tsx
import { IconCheck, IconClipboard, IconDownload } from '@tabler/icons-react';
import { FC, memo, useState } from 'react';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { oneDark } from 'react-syntax-highlighter/dist/cjs/styles/prism';

import { useTranslation } from 'next-i18next';

import {
  generateRandomString,
  programmingLanguages,
} from '@/utils/app/codeblock';

interface Props {
  language: string;
  value: string;
}

export const CodeBlock: FC<Props> = memo(({ language, value }) => {
  const { t } = useTranslation('markdown');
  const [isCopied, setIsCopied] = useState<Boolean>(false);

  const copyToClipboard = () => {
    if (!navigator.clipboard || !navigator.clipboard.writeText) {
      return;
    }

    navigator.clipboard.writeText(value).then(() => {
      setIsCopied(true);

      setTimeout(() => {
        setIsCopied(false);
      }, 2000);
    });
  };
  const downloadAsFile = () => {
    const fileExtension = programmingLanguages[language] || '.file';
    const suggestedFileName = `file-${generateRandomString(
      3,
      true,
    )}${fileExtension}`;
    const fileName = window.prompt(
      t('Enter file name') || '',
      suggestedFileName,
    );

    if (!fileName) {
      // user pressed cancel on prompt
      return;
    }

    const blob = new Blob([value], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.download = fileName;
    link.href = url;
    link.style.display = 'none';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  };
  return (
    <div className="codeblock relative font-sans text-[16px]">
      <div className="flex items-center justify-between py-1.5 px-4">
        <span className="text-xs lowercase text-black dark:text-white">
          {language}
        </span>

        <div className="flex items-center">
          <button
            className="flex gap-1.5 items-center rounded bg-none p-1 text-xs text-black dark:text-white"
            onClick={copyToClipboard}
          >
            {isCopied ? <IconCheck size={18} /> : <IconClipboard size={18} />}
            {isCopied ? t('Copied!') : t('Copy code')}
          </button>
          <button
            className="flex items-center rounded bg-none p-1 text-xs text-black dark:text-white"
            onClick={downloadAsFile}
          >
            <IconDownload size={18} />
          </button>
        </div>
      </div>

      <SyntaxHighlighter
        language={language}
        style={oneDark}
        customStyle={{ margin: 0 }}
      >
        {value}
      </SyntaxHighlighter>
    </div>
  );
});
CodeBlock.displayName = 'CodeBlock';
------------------------
./components/Common/Sidebar/components/OpenCloseButton.tsx
import {
  IconArrowBarLeft,
  IconArrowBarRight,
  IconLayoutSidebarLeftCollapse,
  IconLayoutSidebarLeftExpand,
  IconLayoutSidebarRightCollapse,
  IconLayoutSidebarRightExpand,
} from '@tabler/icons-react';

interface Props {
  onClick: any;
  side: 'left' | 'right';
}

export const CloseSidebarButton = ({ onClick, side }: Props) => {
  return (
    <>
      <button
        className={`fixed top-5 ${
          side === 'right' ? 'right-[270px]' : 'left-[340px]'
        } z-50 h-7 w-7 hover:text-gray-400 text-black dark:text-white dark:hover:text-gray-300 sm:top-0.5 sm:${
          side === 'right' ? 'right-[270px]' : 'left-[340px]'
        } sm:h-8 sm:w-8 sm:text-neutral-700`}
        onClick={onClick}
      >
        {side === 'right' ? <IconArrowBarRight /> : <IconArrowBarLeft />}
      </button>
      <div
        onClick={onClick}
        className="absolute top-0 left-0 z-10 h-full w-full bg-black opacity-70 sm:hidden"
      ></div>
    </>
  );
};

export const OpenSidebarButton = ({ onClick, side }: Props) => {
  return (
    <button
      className={`fixed top-2.5 ${
        side === 'right' ? 'right-2' : 'left-2'
      } z-50 h-7 w-7  hover:text-gray-400 text-black dark:text-white dark:hover:text-gray-300 sm:top-0.5 sm:${
        side === 'right' ? 'right-2' : 'left-2'
      } sm:h-8 sm:w-8 sm:text-neutral-700`}
      onClick={onClick}
    >
      {side === 'right' ? <IconArrowBarLeft /> : <IconArrowBarRight />}
    </button>
  );
};

export const PrimaryMenuOpener = ({ onClick, open, visible }: any) => {
  return (
    <button
      className={`${visible ? 'block' : 'invisible'}
         hover:text-neutral-500 dark:hover:text-neutral-400
        text-black dark:text-white`}
      onClick={onClick}
    >
      {open ? (
        <IconLayoutSidebarLeftCollapse />
      ) : (
        <IconLayoutSidebarLeftExpand />
      )}
    </button>
  );
};

export const SecondaryMenuOpener = ({ onClick, open, visible }: any) => {
  return (
    <button
      className={`${visible ? 'block' : 'invisible'}
         hover:text-neutral-500 dark:hover:text-neutral-400
        text-black dark:text-white`}
      onClick={onClick}
    >
      {open ? (
        <IconLayoutSidebarRightCollapse />
      ) : (
        <IconLayoutSidebarRightExpand />
      )}
    </button>
  );
};
------------------------
./components/Common/Sidebar/SidebarButton.tsx
import { FC } from 'react';

interface Props {
  text: string;
  icon: JSX.Element;
  onClick: () => void;
}

export const SidebarButton: FC<Props> = ({ text, icon, onClick }) => {
  return (
    <button
      className="flex w-full cursor-pointer select-none items-center gap-3 rounded-md py-3 px-3 text-[14px] leading-3 text-black dark:text-white transition-colors duration-200 hover:bg-gray-500/10"
      onClick={onClick}
    >
      <div>{icon}</div>
      <span>{text}</span>
    </button>
  );
};
------------------------
./components/Common/Sidebar/Sidebar.tsx
import { IconFolderPlus, IconMistOff, IconPlus } from '@tabler/icons-react';
import { ReactNode } from 'react';
import { useTranslation } from 'react-i18next';

import {
  CloseSidebarButton,
  OpenSidebarButton,
} from './components/OpenCloseButton';

import Search from '../Search';

interface Props<T> {
  isOpen: boolean;
  addItemButtonTitle: string;
  side: 'left' | 'right';
  items: T[];
  itemComponent: ReactNode;
  folderComponent: ReactNode;
  footerComponent?: ReactNode;
  searchTerm: string;
  handleSearchTerm: (searchTerm: string) => void;
  toggleOpen: () => void;
  handleCreateItem: () => void;
  handleCreateFolder: () => void;
  handleDrop: (e: any) => void;
}

const Sidebar = <T,>({
  isOpen,
  addItemButtonTitle,
  side,
  items,
  itemComponent,
  folderComponent,
  footerComponent,
  searchTerm,
  handleSearchTerm,
  toggleOpen,
  handleCreateItem,
  handleCreateFolder,
  handleDrop,
}: Props<T>) => {
  const { t } = useTranslation('promptbar');

  const allowDrop = (e: any) => {
    e.preventDefault();
  };

  const highlightDrop = (e: any) => {
    e.target.style.background = '#343541';
  };

  const removeHighlight = (e: any) => {
    e.target.style.background = 'none';
  };

  return isOpen ? (
    <div>
      <div
        className={`relative top-0 ${side}-0 z-40 flex h-full w-[260px] flex-none flex-col space-y-2 bg-[#202123] p-2 text-[14px] transition-all sm:relative sm:top-0`}
      >
        <div className="flex items-center">
          <button
            className="text-sidebar flex w-[190px] flex-shrink-0 cursor-pointer select-none items-center gap-3 rounded-md border border-white/20 p-3 text-black dark:text-white transition-colors duration-200 hover:bg-gray-500/10"
            onClick={() => {
              handleCreateItem();
              handleSearchTerm('');
            }}
          >
            <IconPlus size={16} />
            {addItemButtonTitle}
          </button>

          <button
            className="ml-2 flex flex-shrink-0 cursor-pointer items-center gap-3 rounded-md border border-white/20 p-3 text-sm text-black dark:text-white transition-colors duration-200 hover:bg-gray-500/10"
            onClick={handleCreateFolder}
          >
            <IconFolderPlus size={16} />
          </button>
        </div>
        <Search
          placeholder={t('Search...') || ''}
          searchTerm={searchTerm}
          onSearch={handleSearchTerm}
        />

        <div className="flex-grow overflow-auto">
          {items?.length > 0 && (
            <div className="flex border-b border-white/20 pb-2">
              {folderComponent}
            </div>
          )}

          {items?.length > 0 ? (
            <div
              className="pt-2"
              onDrop={handleDrop}
              onDragOver={allowDrop}
              onDragEnter={highlightDrop}
              onDragLeave={removeHighlight}
            >
              {itemComponent}
            </div>
          ) : (
            <div className="mt-8 select-none text-center text-white opacity-50">
              <IconMistOff className="mx-auto mb-3" />
              <span className="text-[14px] leading-normal">
                {t('No data.')}
              </span>
            </div>
          )}
        </div>
        {footerComponent}
      </div>

      <CloseSidebarButton onClick={toggleOpen} side={side} />
    </div>
  ) : (
    <OpenSidebarButton onClick={toggleOpen} side={side} />
  );
};

export default Sidebar;
------------------------
./components/Common/Sidebar/index.ts
export { default } from './Sidebar';
------------------------
./components/Common/Buttons/ModelSelect.tsx
import { useContext } from 'react';

import { AiModel, PossibleAiModels } from '@/types/ai-models';

import HomeContext from '@/components/Home/home.context';

export const ModelSelect = () => {
  const {
    state: { selectedConversation, models, defaultModelId },
    handleUpdateConversation,
  } = useContext(HomeContext);

  const handleChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const model_id = e.target.value as string;
    const model: AiModel = PossibleAiModels[model_id];
    selectedConversation &&
      handleUpdateConversation(selectedConversation, {
        key: 'model',
        value: model,
      });
  };

  return (
    <div
      className="
      w-full rounded-sm 
      bg-transparent text-black
      bg-gradient-to-r from-black-600 via-violet-900 to-indigo-500
      dark:from-black-500 dark:via-violet-600 dark:to-indigo-400
      bg-175% animate-bg-pan-slow appearance-none dark:bg-gray-700 hover:opacity-90
      "
    >
      <select
        className="text-left w-full bg-transparent p-1 text-sm"
        value={selectedConversation?.model?.id || defaultModelId}
        onChange={handleChange}
      >
        {models.map((model) => (
          <option
            key={model.id}
            value={model.id}
            className="bg-theme-primary-menu-light dark:bg-theme-primary-menu-dark text-black dark:black"
          >
            {model.id}
          </option>
        ))}
      </select>
    </div>
  );
};
------------------------
./components/Common/Buttons/MiniButtons.tsx
import { MouseEventHandler } from 'react';

interface Props {
  handleClick: MouseEventHandler<HTMLButtonElement>;
  children: string;
  className?: string;
}

export const MiniGreenButton = ({ handleClick, children }: Props) => (
  <button
    className={
      'text-[12px] px-[4px] bg-green-700 text-neutral-100 hover:bg-green-500 rounded-sm'
    }
    onClick={handleClick}
  >
    {children}
  </button>
);

export const MiniRedButton = ({ handleClick, children }: Props) => (
  <button
    className={
      'text-[12px] px-[4px]  bg-red-700 text-neutral-100 hover:bg-red-500 rounded-sm'
    }
    onClick={handleClick}
  >
    {children}
  </button>
);
------------------------
./components/Common/Buttons/PrimaryButton.tsx
import { MouseEventHandler } from 'react';

interface Props {
  onClick: MouseEventHandler<HTMLButtonElement>;
  children: any;
  className?: string;
  disabled?: boolean;
}

export const PrimaryButton = ({ onClick, children, disabled }: Props) => (
  <button
    disabled={disabled}
    className="
    py-3 sm:py-2 w-full flex flex-shrink cursor-pointer select-none items-center justify-center gap-1
    text-white
    rounded-md border border-theme-border-light dark:border-theme-border-dark
    bg-gradient-to-r from-black-600 via-violet-900 to-indigo-500
    dark:from-black-500 dark:via-violet-600 dark:to-indigo-400
    bg-175% animate-bg-pan-slow appearance-none dark:bg-gray-700 hover:opacity-90
    "
    onClick={onClick}
  >
    {children}
  </button>
);

export const PrimaryButtonAlt = ({ onClick, children }: Props) => (
  <button
    className="
    p-3 sm:p-2  text-sidebar flex w-full flex-shrink-0 cursor-pointer select-none items-center
    gap-3 rounded-md border 
    border-theme-button-border-light dark:border-theme-button-border-dark
    text-black dark:text-white transition-colors duration-200
    hover:bg-theme-hover-light dark:hover:bg-theme-hover-dark"
    onClick={onClick}
  >
    {children}
  </button>
);
------------------------
./components/Common/Buttons/SidebarActionButton/SidebarActionButton.tsx
import { MouseEventHandler, ReactElement } from 'react';

interface Props {
  handleClick: MouseEventHandler<HTMLButtonElement>;
  children: ReactElement;
  className?: string;
}

const SidebarActionButton = ({ handleClick, children, className }: Props) => (
  <button
    className={
      className ||
      `min-w-[20px] p-1 text-theme-button-icon-light dark:text-theme-button-icon-dark
      hover:text-theme-button-icon-hover-light dark:hover:text-theme-button-icon-hover-dark`
    }
    onClick={handleClick}
  >
    {children}
  </button>
);

export default SidebarActionButton;
------------------------
./components/Common/Buttons/SidebarActionButton/index.ts
export { default } from './SidebarActionButton';
------------------------
./components/Common/Buttons/SecondaryButton.tsx
import { MouseEventHandler } from 'react';

interface Props {
  children: any;
  onClick?: MouseEventHandler<HTMLButtonElement>;
  className?: string;
}

export const SecondaryButton = ({ onClick, children }: Props) => (
  <button
    className="
    p-3 sm:p-2 flex flex-shrink-0 cursor-pointer items-center gap-3 rounded-md border
    border-theme-button-border-light dark:border-theme-button-border-dark
    text-black dark:text-white transition-colors duration-200 hover:bg-gray-500/10
    "
    onClick={onClick}
  >
    {children}
  </button>
);
------------------------
./components/Common/ErrorMessageDiv.tsx
import { IconCircleX } from '@tabler/icons-react';
import { FC } from 'react';

import { ErrorMessage } from '@/types/error';

interface Props {
  error: ErrorMessage;
}

export const ErrorMessageDiv: FC<Props> = ({ error }) => {
  return (
    <div className="mx-6 flex h-full flex-col items-center justify-center text-red-500">
      <div className="mb-5">
        <IconCircleX size={36} />
      </div>
      <div className="mb-3 text-2xl font-medium">{error.title}</div>
      {error.messageLines.map((line, index) => (
        <div key={index} className="text-center">
          {' '}
          {line}{' '}
        </div>
      ))}
      <div className="mt-4 text-xs opacity-50 dark:text-red-400">
        {error.code ? <i>Code: {error.code}</i> : ''}
      </div>
    </div>
  );
};
------------------------
./components/Common/Chips/Chip.tsx
import { IconCheck } from '@tabler/icons-react';

export const Chip = ({ children, isSelected, handleSelect, id }: any) => {
  return (
    <div
      className={`
      flex flex-row items-center justify-center rounded-full
      text-black dark:text-white
      border text-[12px]
      whitespace-nowrap px-2 py-1 cursor-pointer select-none
      mt-2 mr-2"
      ${
        isSelected
          ? 'bg-[#2e9052] dark:bg-[#257944] text-white border-transparent dark:border-transparent'
          : 'border-neutral-500 dark:border-neutral-500 '
      }
      `}
      onClick={() => handleSelect(id)}
    >
      {isSelected && (
        <IconCheck width={15} height={15} className="mr-1 select-none" />
      )}
      {children}
    </div>
  );
};
------------------------
./components/Common/Search.tsx
import { IconX } from '@tabler/icons-react';
import { FC } from 'react';

import { useTranslation } from 'next-i18next';

interface Props {
  placeholder: string;
  searchTerm: string;
  onSearch: (searchTerm: string) => void;
}
const Search: FC<Props> = ({ placeholder, searchTerm, onSearch }) => {
  const { t } = useTranslation('sidebar');

  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    onSearch(e.target.value);
  };

  const clearSearch = () => {
    onSearch('');
  };

  return (
    <div className="relative w-full flex flex-shrink items-center">
      <input
        className="w-full flex flex-shrink rounded-md border
        border-theme-button-border-light dark:border-theme-button-border-dark
        bg-theme-primary-menu-light dark:bg-theme-primary-menu-dark px-4 py-3 sm:py-2 pr-10
        text-[14px] leading-3 text-black dark:text-white"
        type="text"
        placeholder={t(placeholder) || ''}
        value={searchTerm}
        onChange={handleSearchChange}
      />

      {searchTerm && (
        <IconX
          className="absolute right-4 cursor-pointer text-neutral-600 dark:text-neutral-300
          hover:text-neutral-500 dark:hover:text-neutral-400"
          size={18}
          onClick={clearSearch}
        />
      )}
    </div>
  );
};

export default Search;
------------------------
./components/Common/Folder/Folder.tsx
import {
  IconCaretDown,
  IconCaretRight,
  IconCheck,
  IconPencil,
  IconTrash,
  IconX,
} from '@tabler/icons-react';
import {
  KeyboardEvent,
  ReactElement,
  useContext,
  useEffect,
  useState,
} from 'react';

import { FolderInterface } from '@/types/folder';

import SidebarActionButton from '@/components/Common/Buttons/SidebarActionButton';
import HomeContext from '@/components/Home/home.context';

interface Props {
  currentFolder: FolderInterface;
  searchTerm: string;
  handleDrop: (e: any, folder: FolderInterface) => void;
  folderComponent: (ReactElement | undefined)[];
}

const Folder = ({
  currentFolder,
  searchTerm,
  handleDrop,
  folderComponent,
}: Props) => {
  const { handleDeleteFolder, handleUpdateFolder } = useContext(HomeContext);

  const [isDeleting, setIsDeleting] = useState(false);
  const [isRenaming, setIsRenaming] = useState(false);
  const [renameValue, setRenameValue] = useState('');
  const [isOpen, setIsOpen] = useState(false);

  const handleEnterDown = (e: KeyboardEvent<HTMLDivElement>) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      handleRename();
    }
  };

  const handleRename = () => {
    handleUpdateFolder(currentFolder.id, renameValue);
    setRenameValue('');
    setIsRenaming(false);
  };

  const dropHandler = (e: any) => {
    if (e.dataTransfer) {
      setIsOpen(true);

      handleDrop(e, currentFolder);

      e.target.style.background = 'none';
    }
  };

  const allowDrop = (e: any) => {
    e.preventDefault();
  };

  const highlightDrop = (e: any) => {
    e.target.style.background = '#343541';
  };

  const removeHighlight = (e: any) => {
    e.target.style.background = 'none';
  };

  useEffect(() => {
    if (isRenaming) {
      setIsDeleting(false);
    } else if (isDeleting) {
      setIsRenaming(false);
    }
  }, [isRenaming, isDeleting]);

  useEffect(() => {
    if (searchTerm) {
      setIsOpen(true);
    } else {
      setIsOpen(false);
    }
  }, [searchTerm]);

  return (
    <>
      <div className="relative flex items-center">
        {isRenaming ? (
          <div className="flex w-full items-center gap-3 bg-theme-light dark:bg-theme-dark p-3">
            {isOpen ? (
              <IconCaretDown size={18} />
            ) : (
              <IconCaretRight size={18} />
            )}
            <input
              className="mr-12 flex-1 overflow-hidden overflow-ellipsis border
              bg-transparent text-left text-[12.5px] leading-3 text-black dark:text-white outline-none
              focus:border-neutral-100 border-theme-border-light dark:border-theme-border-dark"
              type="text"
              value={renameValue}
              onChange={(e) => setRenameValue(e.target.value)}
              onKeyDown={handleEnterDown}
              autoFocus
            />
          </div>
        ) : (
          <button
            className={`flex w-full cursor-pointer items-center gap-3 rounded-lg p-3 text-sm transition-colors
            duration-200 hover:bg-theme-hover-light dark:hover:bg-theme-hover-dark
            text-black dark:text-white`}
            onClick={() => setIsOpen(!isOpen)}
            onDrop={(e) => dropHandler(e)}
            onDragOver={allowDrop}
            onDragEnter={highlightDrop}
            onDragLeave={removeHighlight}
          >
            {isOpen ? (
              <IconCaretDown size={18} />
            ) : (
              <IconCaretRight size={18} />
            )}

            <div className="relative max-h-5 flex-1 overflow-hidden text-ellipsis whitespace-nowrap break-all text-left text-[12.5px] leading-3">
              {currentFolder.name}
            </div>
          </button>
        )}

        {(isDeleting || isRenaming) && (
          <div className="absolute right-1 z-10 flex text-gray-300">
            <SidebarActionButton
              handleClick={(e) => {
                e.stopPropagation();

                if (isDeleting) {
                  handleDeleteFolder(currentFolder.id);
                } else if (isRenaming) {
                  handleRename();
                }

                setIsDeleting(false);
                setIsRenaming(false);
              }}
            >
              <IconCheck size={18} />
            </SidebarActionButton>
            <SidebarActionButton
              handleClick={(e) => {
                e.stopPropagation();
                setIsDeleting(false);
                setIsRenaming(false);
              }}
            >
              <IconX size={18} />
            </SidebarActionButton>
          </div>
        )}

        {!isDeleting && !isRenaming && (
          <div className="absolute right-1 z-10 flex text-gray-300">
            <SidebarActionButton
              handleClick={(e) => {
                e.stopPropagation();
                setIsRenaming(true);
                setRenameValue(currentFolder.name);
              }}
            >
              <IconPencil size={18} />
            </SidebarActionButton>
            <SidebarActionButton
              handleClick={(e) => {
                e.stopPropagation();
                setIsDeleting(true);
              }}
            >
              <IconTrash size={18} />
            </SidebarActionButton>
          </div>
        )}
      </div>

      {isOpen ? folderComponent : null}
    </>
  );
};

export default Folder;
------------------------
./components/Common/Folder/index.ts
export { default } from './Folder';
------------------------
./components/Common/Labels/PrimaryLabel.tsx
import { InfoTooltip } from '@/components/Home/components/SecondaryMenu/components/Menu/components/Screens/ModelSettings/components/InfoTooltip';

export const PrimaryLabel = ({ children, tip }: any) => {
  return (
    <label className="pt-3 flex items-center text-left pl-1 text-black dark:text-white">
      {children}
      {tip && <InfoTooltip>{tip}</InfoTooltip>}
    </label>
  );
};
------------------------
./components/Common/Spinner/index.ts
export { default } from './Spinner';
------------------------
./components/Common/Spinner/Spinner.tsx
import { FC } from 'react';

interface Props {
  size?: string;
  className?: string;
}

const Spinner = ({ size = '1em', className = '' }: Props) => {
  return (
    <svg
      stroke="currentColor"
      fill="none"
      strokeWidth="2"
      viewBox="0 0 24 24"
      strokeLinecap="round"
      strokeLinejoin="round"
      className={`animate-spin ${className}`}
      height={size}
      width={size}
      xmlns="http://www.w3.org/2000/svg"
    >
      <line x1="12" y1="2" x2="12" y2="6"></line>
      <line x1="12" y1="18" x2="12" y2="22"></line>
      <line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line>
      <line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line>
      <line x1="2" y1="12" x2="6" y2="12"></line>
      <line x1="18" y1="12" x2="22" y2="12"></line>
      <line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line>
      <line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line>
    </svg>
  );
};

export default Spinner;
------------------------
./__tests__/utils/app/importExports.test.ts
import { DEFAULT_SYSTEM_PROMPT, DEFAULT_TEMPERATURE } from '@/utils/app/const';
import {
  cleanData,
  isExportFormatV1,
  isExportFormatV2,
  isExportFormatV3,
  isExportFormatV4,
  isLatestExportFormat,
} from '@/utils/app/importExport';

import {
  ChatbotUIFormatV4,
  ExportFormatV1,
  ExportFormatV2,
} from '@/types/export';
import { OpenAIModelID, OpenAIModels } from '@/types/openai';

import { describe, expect, it } from 'vitest';

describe('Export Format Functions', () => {
  describe('isExportFormatV1', () => {
    it('should return true for v1 format', () => {
      const obj = [{ id: 1 }];
      expect(isExportFormatV1(obj)).toBe(true);
    });

    it('should return false for non-v1 formats', () => {
      const obj = { version: 3, history: [], folders: [] };
      expect(isExportFormatV1(obj)).toBe(false);
    });
  });

  describe('isExportFormatV2', () => {
    it('should return true for v2 format', () => {
      const obj = { history: [], folders: [] };
      expect(isExportFormatV2(obj)).toBe(true);
    });

    it('should return false for non-v2 formats', () => {
      const obj = { version: 3, history: [], folders: [] };
      expect(isExportFormatV2(obj)).toBe(false);
    });
  });

  describe('isExportFormatV3', () => {
    it('should return true for v3 format', () => {
      const obj = { version: 3, history: [], folders: [] };
      expect(isExportFormatV3(obj)).toBe(true);
    });

    it('should return false for non-v3 formats', () => {
      const obj = { version: 4, history: [], folders: [] };
      expect(isExportFormatV3(obj)).toBe(false);
    });
  });

  describe('isExportFormatV4', () => {
    it('should return true for v4 format', () => {
      const obj = { version: 4, history: [], folders: [], prompts: [] };
      expect(isExportFormatV4(obj)).toBe(true);
    });

    it('should return false for non-v4 formats', () => {
      const obj = { version: 5, history: [], folders: [], prompts: [] };
      expect(isExportFormatV4(obj)).toBe(false);
    });
  });
});

describe('cleanData Functions', () => {
  describe('cleaning v1 data', () => {
    it('should return the latest format', () => {
      const data = [
        {
          id: 1,
          name: 'conversation 1',
          messages: [
            {
              role: 'user',
              content: "what's up ?",
            },
            {
              role: 'assistant',
              content: 'Hi',
            },
          ],
        },
      ] as ExportFormatV1;
      const obj = cleanData(data);
      expect(isLatestExportFormat(obj)).toBe(true);
      expect(obj).toEqual({
        version: 4,
        history: [
          {
            id: 1,
            name: 'conversation 1',
            messages: [
              {
                role: 'user',
                content: "what's up ?",
              },
              {
                role: 'assistant',
                content: 'Hi',
              },
            ],
            model: OpenAIModels[OpenAIModelID.GPT_3_5],
            prompt: DEFAULT_SYSTEM_PROMPT,
            temperature: DEFAULT_TEMPERATURE,
            folderId: null,
          },
        ],
        folders: [],
        prompts: [],
      });
    });
  });

  describe('cleaning v2 data', () => {
    it('should return the latest format', () => {
      const data = {
        history: [
          {
            id: '1',
            name: 'conversation 1',
            messages: [
              {
                role: 'user',
                content: "what's up ?",
              },
              {
                role: 'assistant',
                content: 'Hi',
              },
            ],
          },
        ],
        folders: [
          {
            id: 1,
            name: 'folder 1',
          },
        ],
      } as ExportFormatV2;
      const obj = cleanData(data);
      expect(isLatestExportFormat(obj)).toBe(true);
      expect(obj).toEqual({
        version: 4,
        history: [
          {
            id: '1',
            name: 'conversation 1',
            messages: [
              {
                role: 'user',
                content: "what's up ?",
              },
              {
                role: 'assistant',
                content: 'Hi',
              },
            ],
            model: OpenAIModels[OpenAIModelID.GPT_3_5],
            prompt: DEFAULT_SYSTEM_PROMPT,
            temperature: DEFAULT_TEMPERATURE,
            folderId: null,
          },
        ],
        folders: [
          {
            id: '1',
            name: 'folder 1',
            type: 'chat',
          },
        ],
        prompts: [],
      });
    });
  });

  describe('cleaning v4 data', () => {
    it('should return the latest format', () => {
      const data = {
        version: 4,
        history: [
          {
            id: '1',
            name: 'conversation 1',
            messages: [
              {
                role: 'user',
                content: "what's up ?",
              },
              {
                role: 'assistant',
                content: 'Hi',
              },
            ],
            model: OpenAIModels[OpenAIModelID.GPT_3_5],
            prompt: DEFAULT_SYSTEM_PROMPT,
            temperature: DEFAULT_TEMPERATURE,
            folderId: null,
          },
        ],
        folders: [
          {
            id: '1',
            name: 'folder 1',
            type: 'chat',
          },
        ],
        prompts: [
          {
            id: '1',
            name: 'prompt 1',
            description: '',
            content: '',
            model: OpenAIModels[OpenAIModelID.GPT_3_5],
            folderId: null,
          },
        ],
      } as ChatbotUIFormatV4;

      const obj = cleanData(data);
      expect(isLatestExportFormat(obj)).toBe(true);
      expect(obj).toEqual({
        version: 4,
        history: [
          {
            id: '1',
            name: 'conversation 1',
            messages: [
              {
                role: 'user',
                content: "what's up ?",
              },
              {
                role: 'assistant',
                content: 'Hi',
              },
            ],
            model: OpenAIModels[OpenAIModelID.GPT_3_5],
            prompt: DEFAULT_SYSTEM_PROMPT,
            temperature: DEFAULT_TEMPERATURE,
            folderId: null,
          },
        ],
        folders: [
          {
            id: '1',
            name: 'folder 1',
            type: 'chat',
          },
        ],
        prompts: [
          {
            id: '1',
            name: 'prompt 1',
            description: '',
            content: '',
            model: OpenAIModels[OpenAIModelID.GPT_3_5],
            folderId: null,
          },
        ],
      });
    });
  });
});
------------------------
./hooks/useCreateReducer.ts
import { useMemo, useReducer } from 'react';

// Extracts property names from initial state of reducer to allow typesafe dispatch objects
export type FieldNames<T> = {
  [K in keyof T]: T[K] extends string ? K : K;
}[keyof T];

// Returns the Action Type for the dispatch object to be used for typing in things like context
export type ActionType<T> =
  | { type: 'reset' }
  | { type?: 'change'; field: FieldNames<T>; value: any };

// Returns a typed dispatch and state
export const useCreateReducer = <T>({ initialState }: { initialState: T }) => {
  type Action =
    | { type: 'reset' }
    | { type?: 'change'; field: FieldNames<T>; value: any };

  const reducer = (state: T, action: Action) => {
    if (!action.type) return { ...state, [action.field]: action.value };

    if (action.type === 'reset') return initialState;

    throw new Error();
  };

  const [state, dispatch] = useReducer(reducer, initialState);

  return useMemo(() => ({ state, dispatch }), [state, dispatch]);
};
------------------------
./hooks/useFetch.ts
export type RequestModel = {
  params?: object;
  headers?: object;
  signal?: AbortSignal;
};

export type RequestWithBodyModel = RequestModel & {
  body?: object | FormData;
};

export const useFetch = () => {
  const handleFetch = async (
    url: string,
    request: any,
    signal?: AbortSignal,
  ) => {
    const requestUrl = request?.params ? `${url}${request.params}` : url;

    const requestBody = request?.body
      ? request.body instanceof FormData
        ? { ...request, body: request.body }
        : { ...request, body: JSON.stringify(request.body) }
      : request;

    const headers = {
      ...(request?.headers
        ? request.headers
        : request?.body && request.body instanceof FormData
        ? {}
        : { 'Content-type': 'application/json' }),
    };

    return fetch(requestUrl, { ...requestBody, headers, signal })
      .then((response) => {
        if (!response.ok) throw response;

        const contentType = response.headers.get('content-type');
        const contentDisposition = response.headers.get('content-disposition');

        const headers = response.headers;

        const result =
          contentType &&
          (contentType?.indexOf('application/json') !== -1 ||
            contentType?.indexOf('text/plain') !== -1)
            ? response.json()
            : contentDisposition?.indexOf('attachment') !== -1
            ? response.blob()
            : response;

        return result;
      })
      .catch(async (err) => {
        const contentType = err.headers.get('content-type');

        const errResult =
          contentType && contentType?.indexOf('application/problem+json') !== -1
            ? await err.json()
            : err;

        throw errResult;
      });
  };

  return {
    get: async <T>(url: string, request?: RequestModel): Promise<T> => {
      return handleFetch(url, { ...request, method: 'get' });
    },
    post: async <T>(
      url: string,
      request?: RequestWithBodyModel,
    ): Promise<T> => {
      return handleFetch(url, { ...request, method: 'post' });
    },
    put: async <T>(url: string, request?: RequestWithBodyModel): Promise<T> => {
      return handleFetch(url, { ...request, method: 'put' });
    },
    patch: async <T>(
      url: string,
      request?: RequestWithBodyModel,
    ): Promise<T> => {
      return handleFetch(url, { ...request, method: 'patch' });
    },
    delete: async <T>(url: string, request?: RequestModel): Promise<T> => {
      return handleFetch(url, { ...request, method: 'delete' });
    },
  };
};
------------------------
./vitest.config.ts
import path from 'path';
import { defineConfig } from 'vite';

export default defineConfig({
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './'),
    },
  },
});
------------------------
./services/errorService.ts
import { useMemo } from 'react';

import { useTranslation } from 'next-i18next';

import { ErrorMessage } from '@/types/error';

const useErrorService = () => {
  const { t } = useTranslation('chat');

  return {
    getModelsError: useMemo(
      () => (error: any) => {
        return !error
          ? null
          : ({
              title: t('Error fetching models.'),
              code: error.status || 'unknown',
              messageLines: error.statusText
                ? [error.statusText]
                : [
                    t(
                      'Make sure your OpenAI API key is set in the bottom left of the sidebar.',
                    ),
                    t(
                      'If you completed this step, OpenAI may be experiencing issues.',
                    ),
                  ],
            } as ErrorMessage);
      },
      [t],
    ),
  };
};

export default useErrorService;
------------------------
